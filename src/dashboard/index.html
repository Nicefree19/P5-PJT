<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5 Live Grid Dashboard v2.4</title>
    
    <!-- Security: Content Security Policy (Updated for GIS + SheetJS + jsPDF) -->
    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self';
                   script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://accounts.google.com https://cdn.sheetjs.com https://cdnjs.cloudflare.com;
                   style-src 'self' 'unsafe-inline';
                   img-src 'self' data: blob: https://*.googleusercontent.com;
                   connect-src 'self' https://script.google.com https://*.googleusercontent.com https://oauth2.googleapis.com;
                   font-src 'self' https://fonts.gstatic.com;
                   frame-src https://accounts.google.com;">
    
    <!-- Security: Referrer Policy -->
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <!-- PWA: Web App Manifest -->
    <link rel="manifest" href="./manifest.json">

    <!-- PWA: Theme Color -->
    <meta name="theme-color" content="#4a90d9">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="P5 Dashboard">

    <!-- PWA: Apple Touch Icons -->
    <link rel="apple-touch-icon" href="./assets/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./assets/icons/icon-192x192.png">

    <!-- PWA: Microsoft Tile -->
    <meta name="msapplication-TileColor" content="#1a1a2e">
    <meta name="msapplication-TileImage" content="./assets/icons/icon-144x144.png">

    <!-- Google Identity Services (GIS) SDK -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Alpine.js (Core) -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.1/dist/cdn.min.js"></script>

    <!-- WP-5: SheetJS & jsPDF are now lazy-loaded on first export -->
    <!-- Previously loaded: xlsx.full.min.js, jspdf.umd.min.js, jspdf.plugin.autotable.min.js -->
    <!-- See loadExportLibs() function for dynamic loading -->

    <!-- LZ-String for localStorage compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

    <!-- P5 Modules -->
    <script type="module" src="./js/auth.js"></script>
    <script type="module" src="./js/api.js"></script>
    <script type="module" src="./js/sync-module.js"></script>
    
    <!-- WP-9-1: Global Error Handler & Circuit Breaker -->
    <script src="./js/error-handler.js"></script>

    <!-- WP-1-A: Modular JS Stores (exposes window.ColumnStore, window.IssueStore) -->
    <script src="./js/stores/column-store.js"></script>
    <script src="./js/stores/issue-store.js"></script>

    <!-- WP-1-A: Utility Modules (exposes window.PdfGenerator) -->
    <script src="./js/utils/pdf-generator.js"></script>

    <!-- Production Status Data (PSRC 제작현황) -->
    <script src="./data/production_status_import.js"></script>
    
    <!-- Column Data Generator (전수 기둥 데이터) -->
    <script src="./data/column_data_generator.js"></script>
    
    <!-- Phase 7: Modular CSS (WP-1 Refactoring) -->
    <link rel="stylesheet" href="./css/main.css">
    <link rel="stylesheet" href="./css/reports.css">
    <!-- WP-1-B: Component Styles -->
    <link rel="stylesheet" href="./css/components.css">

    <style>
        /* Moved to components.css (Phase 8 WP-1-B) */
    </style>

</head>
<body x-data="dashboard()" x-init="init()">

<!-- Skip Link for Accessibility -->
<a href="#main-content" class="skip-link">메인 콘텐츠로 건너뛰기</a>

<!-- Screen Reader Announcements -->
<div id="sr-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
<div id="sr-errors" aria-live="assertive" aria-atomic="true" class="sr-only"></div>

<!-- Loading Overlay -->
<div x-show="isLoading" x-cloak class="loading-overlay" role="status" aria-live="polite">
    <div class="spinner spinner-lg"></div>
    <span x-text="loadingMessage || '로딩 중...'"></span>
</div>

<!-- Phase 7: 실시간 알림 Toast 컨테이너 -->
<div class="notification-container">
    <template x-for="notification in activeNotifications" :key="notification.id">
        <div class="notification-toast" 
             :class="[notification.type, notification.closing ? 'closing' : '']"
             @click="handleNotificationClick(notification)">
            <span class="notification-icon" x-text="getNotificationIcon(notification.type)"></span>
            <div class="notification-content">
                <div class="notification-title" x-text="notification.title"></div>
                <div class="notification-message" x-text="notification.message"></div>
                <div class="notification-time" x-text="formatNotificationTime(notification.timestamp)"></div>
            </div>
            <button class="notification-close" @click.stop="dismissNotification(notification.id)" aria-label="알림 닫기">✕</button>
        </div>
    </template>
</div>

<!-- Phase 7: 알림 히스토리 패널 -->
<div class="notification-history-panel" :class="notificationPanelOpen ? 'open' : ''">
    <div class="notification-history-header">
        <h3>📋 알림 히스토리</h3>
        <div class="notification-history-actions">
            <button class="btn" @click="markAllNotificationsRead()" style="font-size:11px; padding:4px 8px;">
                모두 읽음
            </button>
            <button class="btn" @click="clearNotificationHistory()" style="font-size:11px; padding:4px 8px;">
                전체 삭제
            </button>
            <button class="notification-close" @click="toggleNotificationPanel()" style="font-size:18px;" aria-label="알림 패널 닫기">✕</button>
        </div>
    </div>
    <div class="notification-history-list">
        <template x-if="notificationHistory.length === 0">
            <div class="notification-history-empty">
                <div style="font-size:40px; margin-bottom:10px;">🔔</div>
                <div>알림이 없습니다</div>
            </div>
        </template>
        <template x-for="notification in notificationHistory" :key="notification.id">
            <div class="notification-history-item" 
                 :class="notification.read ? '' : 'unread'"
                 @click="handleHistoryItemClick(notification)">
                <div style="display:flex; align-items:flex-start; gap:10px;">
                    <span x-text="getNotificationIcon(notification.type)" style="font-size:16px;"></span>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:12px; font-weight:600; color:#fff;" x-text="notification.title"></div>
                        <div style="font-size:11px; color:#8b949e; margin-top:4px; line-height:1.4;" x-text="notification.message"></div>
                        <div style="font-size:10px; color:#484f58; margin-top:6px;" x-text="formatNotificationTime(notification.timestamp)"></div>
                    </div>
                </div>
            </div>
        </template>
    </div>
</div>

<!-- Header -->
<header role="banner">
    <div class="brand">
        <h1>P5 Live Grid</h1>
        <span class="project-tag">v2.0 Admin</span>

        <!-- Phase 7: 층 선택기 -->
        <div class="floor-selector" @click.outside="floorSelectorOpen = false">
            <button class="floor-selector-btn" @click="floorSelectorOpen = !floorSelectorOpen"
                    aria-label="층 선택"
                    :aria-expanded="floorSelectorOpen"
                    aria-haspopup="listbox">
                <span class="floor-icon">🏢</span>
                <span class="floor-label" x-text="currentFloorLabel"></span>
                <span class="floor-arrow" :class="{'open': floorSelectorOpen}">▼</span>
            </button>

            <!-- 층 드롭다운 -->
            <div class="floor-dropdown" x-show="floorSelectorOpen" x-transition style="display: none;"
                 role="listbox" aria-label="층 목록">
                <template x-for="floor in floors" :key="floor.floorId">
                    <div class="floor-item"
                         :class="{'active': selectedFloor === floor.floorId, 'has-variation': floor.hasVariation}"
                         @click="selectFloor(floor.floorId)"
                         role="option"
                         :aria-selected="selectedFloor === floor.floorId">
                        <span class="floor-item-label" x-text="floor.label"></span>
                        <span class="floor-item-badge" x-show="floor.hasVariation" title="표준층과 차이">⚠</span>
                        <span class="floor-item-check" x-show="selectedFloor === floor.floorId">✓</span>
                    </div>
                </template>
            </div>
        </div>

        <!-- Phase 6: Progress Summary -->
        <div class="progress-summary" style="margin-left: 15px;">
            <template x-for="stage in stageConfigs" :key="stage.code">
                <div class="stage-mini">
                    <span class="stage-label" x-text="stage.label"></span>
                    <span class="stage-progress"
                          :style="'color:' + stage.color"
                          x-text="getStageProgress(stage.code) + '%'"></span>
                    <div class="stage-bar">
                        <div class="stage-bar-fill"
                             :style="'width:' + getStageProgress(stage.code) + '%; background:' + stage.color">
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
    <div class="controls">
        <div class="stat-box">
            <span class="stat-label">전체 기둥</span>
            <span class="stat-val" x-text="totalColumns + '개'"></span>
        </div>
        <div class="stat-box">
            <span class="stat-label">선택됨</span>
            <span class="stat-val" style="color:#58a6ff" x-text="selectedCells.length + '개'"></span>
        </div>
        <!-- Sync Status Indicator -->
        <div class="stat-box" x-show="syncEnabled">
            <span class="stat-label">동기화 대기</span>
            <span class="stat-val" :style="syncStatus.pending > 0 ? 'color:#d29922' : 'color:#238636'" 
                  x-text="syncStatus.pending + '개 대기중'"></span>
        </div>
        <button class="btn" @click="clearSelection()" aria-label="선택 해제">선택 해제</button>
        <button class="btn" @click="syncNow()" x-show="syncEnabled" :disabled="syncStatus.pending === 0" aria-label="지금 동기화">
            🔄 지금 동기화
        </button>
        <!-- Phase 5: AI 분석 버튼 -->
        <button class="btn" @click="triggerAnalysis()"
                :disabled="analysisJob.status === 'pending' || analysisJob.status === 'running'"
                :style="analysisJob.status === 'running' ? 'border-color:#d29922; color:#d29922;' : ''"
                aria-label="AI 분석 실행">
            <span x-show="analysisJob.status !== 'running'">🔍 분석</span>
            <span x-show="analysisJob.status === 'running'">⏳ 분석 중...</span>
        </button>
        <div class="controls">
            <!-- Phase 7: 스마트 검색 -->
            <div class="search-panel" @click.outside="searchDropdownOpen = false" role="search">
                <div class="search-input-wrapper">
                    <span class="search-icon" aria-hidden="true">🔍</span>
                    <input type="text"
                           class="search-input"
                           placeholder="기둥/Zone/상태 검색 (예: A-1)"
                           x-model="searchQuery"
                           @focus="if(searchQuery) searchDropdownOpen = true"
                           @input="performSearchDebounced()"
                           @keydown.escape="clearSearch()"
                           @keydown="handleSearchKeydown($event)"
                           aria-label="기둥, Zone, 상태 검색"
                           :aria-expanded="searchDropdownOpen"
                           aria-autocomplete="list"
                           aria-controls="search-results-dropdown">
                    <button class="search-clear-btn" x-show="searchQuery" @click="clearSearch()" aria-label="검색어 지우기">✕</button>

                    <!-- 검색 결과 드롭다운 -->
                    <div class="search-dropdown" x-show="searchDropdownOpen && searchResults.length > 0" x-transition style="display: none;"
                         id="search-results-dropdown" role="listbox" aria-label="검색 결과">
                        <template x-if="searchResults.length === 0">
                            <div class="search-dropdown-section" style="padding: 16px; text-align: center; color: #8b949e;">
                                검색 결과가 없습니다
                            </div>
                        </template>

                        <div class="search-dropdown-section" x-show="searchResults.some(r => r.type === 'column')">
                            <div class="search-section-title" style="padding: 4px 12px; font-size: 10px; color: #8b949e;">기둥</div>
                            <template x-for="result in searchResults.filter(r => r.type === 'column')" :key="result.id">
                                <div class="quick-action-menu-item" @click="selectSearchResult(result)">
                                    <span x-text="result.icon"></span>
                                    <span x-text="result.text"></span>
                                    <span style="margin-left: auto; font-size: 10px; color: #8b949e;" x-text="result.hint"></span>
                                </div>
                            </template>
                        </div>
                        
                        <div class="search-dropdown-section" x-show="searchResults.some(r => r.type === 'zone')">
                            <div class="search-section-title" style="padding: 4px 12px; font-size: 10px; color: #8b949e;">Zone</div>
                            <template x-for="result in searchResults.filter(r => r.type === 'zone')" :key="result.id">
                                <div class="quick-action-menu-item" @click="selectSearchResult(result)">
                                    <span x-text="result.icon"></span>
                                    <span x-text="result.text"></span>
                                </div>
                            </template>
                        </div>

                         <div class="search-dropdown-section" x-show="searchResults.some(r => r.type === 'issue')">
                            <div class="search-section-title" style="padding: 4px 12px; font-size: 10px; color: #8b949e;">이슈</div>
                            <template x-for="result in searchResults.filter(r => r.type === 'issue')" :key="result.id">
                                <div class="quick-action-menu-item" @click="selectSearchResult(result)">
                                    <span x-text="result.icon"></span>
                                    <span x-text="result.text"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stat-box" style="min-width: 100px;">
                <span class="stat-label">층 선택</span>
                <select class="floor-select" x-model="currentFloor" @change="loadFloorDataLegacy()"
                        style="background:#161b22; color:#c9d1d9; border:1px solid #30363d; border-radius:4px; padding:4px 8px; font-size:12px; cursor:pointer;">
                    <option value="F1">1층</option>
                    <option value="F2">2층</option>
                    <option value="ALL">전체</option>
                </select>
            </div>
        <!-- Excel Export Dropdown -->
        <div class="header-export-btn" x-data="{ headerExportOpen: false }" @click.outside="headerExportOpen = false">
            <button class="btn btn-primary" @click="headerExportOpen = !headerExportOpen">
                📥 내보내기 <span style="font-size:10px;">▼</span>
            </button>
            <div class="header-export-dropdown" x-show="headerExportOpen" x-transition style="display:none;">
                <div class="header-export-item" @click="exportData(); headerExportOpen = false;">
                    📄 JSON (전체 백업)
                </div>
                <div class="header-export-item" @click="exportToCSV(); headerExportOpen = false;">
                    📊 CSV (기둥 데이터)
                </div>
                <div class="header-export-item" @click="exportToExcel({ scope: 'all' }); headerExportOpen = false;">
                    📗 Excel (전체)
                </div>
                <div class="header-export-item" @click="exportToExcel({ scope: 'filtered' }); headerExportOpen = false;">
                    🔍 Excel (필터됨)
                </div>
                <div class="header-export-item"
                     :class="{ 'disabled': selectedCells.length === 0 }"
                     @click="selectedCells.length > 0 && (exportToExcel({ scope: 'selected' }), headerExportOpen = false)">
                    ✓ Excel (선택: <span x-text="selectedCells.length"></span>개)
                </div>
                <div style="border-top: 1px solid var(--border-color); margin: 4px 0;"></div>
                <div class="header-export-item" @click="generatePDFReport('summary'); headerExportOpen = false;">
                    📕 PDF 요약 보고서
                </div>
                <div class="header-export-item" @click="generatePDFReport('detailed'); headerExportOpen = false;">
                    📘 PDF 상세 보고서
                </div>
                <div class="header-export-item" @click="generatePDFReport('issues'); headerExportOpen = false;">
                    📙 PDF 이슈 보고서
                </div>
            </div>
        </div>
        <!-- WP-4: Report Panel Button -->
        <button class="btn" @click="openReportPanel()" style="background:#238636; border-color:#238636;">
            📊 리포트
        </button>
        <button class="btn" @click="toggleIssuePanel()" :style="openIssues.length > 0 ? 'border-color:#da3633; color:#f85149;' : ''">
            🚨 이슈 <span x-show="openIssues.length > 0" x-text="`(${openIssues.length})`" style="font-weight:bold;"></span>
        </button>
        <!-- Phase 7: 알림 버튼 -->
        <div class="notification-bell" @click="toggleNotificationPanel()">
            <button class="btn">🔔</button>
            <template x-if="unreadNotificationCount > 0">
                <span class="notification-badge" x-text="unreadNotificationCount > 9 ? '9+' : unreadNotificationCount"></span>
            </template>
        </div>
        <button class="btn" @click="showAdminPanel = true">⚙️ 관리자</button>
    </div>
</header>

<!-- Admin Panel Overlay -->
<div class="admin-panel-overlay" x-show="showAdminPanel" x-cloak @click.self="showAdminPanel = false"
     role="dialog" aria-modal="true" aria-labelledby="admin-panel-title">
    <div class="admin-panel">
        <div class="admin-panel-header">
            <h2 id="admin-panel-title">⚙️ P5 관리자 패널</h2>
            <button class="btn" @click="showAdminPanel = false" aria-label="관리자 패널 닫기">✕</button>
        </div>

        <div class="admin-tabs" role="tablist" aria-label="관리자 설정 탭">
            <button class="admin-tab" :class="adminTab === 'zones' && 'active'" @click="adminTab = 'zones'" role="tab" :aria-selected="adminTab === 'zones'" aria-controls="tab-zones">🗂️ Zone</button>
            <button class="admin-tab" :class="adminTab === 'issues' && 'active'" @click="adminTab = 'issues'" role="tab" :aria-selected="adminTab === 'issues'" aria-controls="tab-issues">🚨 이슈</button>
            <button class="admin-tab" :class="adminTab === 'project' && 'active'" @click="adminTab = 'project'" role="tab" :aria-selected="adminTab === 'project'" aria-controls="tab-project">📁 프로젝트</button>
            <button class="admin-tab" :class="adminTab === 'settings' && 'active'" @click="adminTab = 'settings'" role="tab" :aria-selected="adminTab === 'settings'" aria-controls="tab-settings">🔧 설정</button>
        </div>
        
        <div class="admin-content">
            <!-- Zone Manager Tab -->
            <template x-if="adminTab === 'zones'">
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                        <h3 style="margin:0; color:#fff;">Zone 목록</h3>
                        <button class="btn btn-primary" @click="openZoneEditor(null)">+ 새 Zone</button>
                    </div>
                    <template x-for="zone in zones" :key="zone.id">
                        <div class="zone-card">
                            <div class="zone-card-header">
                                <div class="zone-card-title">
                                    <div class="zone-color-dot" :style="'background:' + zone.color"></div>
                                    <span style="font-weight:600; color:#fff;" x-text="zone.name"></span>
                                </div>
                                <div class="zone-card-actions">
                                    <button class="btn" style="padding:4px 8px; font-size:11px;" @click="openZoneEditor(zone)">편집</button>
                                    <button class="btn" style="padding:4px 8px; font-size:11px; color:#f85149;" @click="deleteZone(zone.id)">삭제</button>
                                </div>
                            </div>
                            <div style="font-size:12px; color:#8b949e; margin-bottom:8px;">
                                X<span x-text="zone.startColumn"></span> ~ X<span x-text="zone.endColumn"></span>
                            </div>
                            <div class="zone-progress-bar">
                                <div class="zone-progress-fill" :style="'width:' + getZoneProgress(zone.id) + '%; background:' + zone.color"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
            
            <!-- Issue Tracker Tab -->
            <template x-if="adminTab === 'issues'">
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                        <h3 style="margin:0; color:#fff;">이슈 목록</h3>
                        <button class="btn btn-primary" @click="openNewIssueModal()">+ 새 이슈</button>
                    </div>
                    <template x-for="issue in filteredIssues" :key="issue.id">
                        <div class="issue-card" :class="issue.severity">
                            <div class="issue-header">
                                <div class="issue-title" x-text="issue.title"></div>
                                <span class="issue-badge" :class="issue.status" x-text="issue.status === 'open' ? '열림' : '해결됨'"></span>
                            </div>
                            <div class="issue-meta" x-text="issue.type + ' · ' + (issue.affectedColumns?.length || 0) + '개 기둥'"></div>
                            <template x-if="issue.status === 'open'">
                                <button class="btn btn-success" style="margin-top:8px; padding:4px 8px; font-size:11px;" @click="resolveIssue(issue.id)">해결</button>
                            </template>
                        </div>
                    </template>
                </div>
            </template>
            
            <!-- Project Manager Tab -->
            <template x-if="adminTab === 'project'">
                <div>
                    <h3 style="margin:0 0 16px 0; color:#fff;">📁 프로젝트 스냅샷 관리</h3>
                    <p style="font-size:12px; color:#8b949e; margin-bottom:20px;">
                        현재 대시보드의 모든 설정(층, 절주, 구간, Zone)과 데이터(기둥 상태, 이슈)를 하나의 파일로 저장하거나 불러옵니다.
                    </p>
                    
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
                        <div style="padding:20px; background:#0d1117; border:1px solid var(--border-color); border-radius:12px; text-align:center;">
                            <div style="font-size:32px; margin-bottom:12px;">📤</div>
                            <h4 style="margin:0 0 8px 0; font-size:14px; color:#fff;">스냅샷 내보내기</h4>
                            <p style="font-size:11px; color:#8b949e; margin-bottom:16px;">현재 상태를 JSON 파일로 다운로드합니다.</p>
                            <button class="btn btn-primary" style="width:100%;" @click="exportProjectSnapshot()">스냅샷 저장</button>
                        </div>
                        
                        <div style="padding:20px; background:#0d1117; border:1px solid var(--border-color); border-radius:12px; text-align:center;">
                            <div style="font-size:32px; margin-bottom:12px;">📥</div>
                            <h4 style="margin:0 0 8px 0; font-size:14px; color:#fff;">스냅샷 불러오기</h4>
                            <p style="font-size:11px; color:#8b949e; margin-bottom:16px;">저장된 스냅샷 파일을 선택하여 복원합니다.</p>
                            <label class="btn btn-success" style="width:100%; display:inline-block; cursor:pointer;">
                                파일 선택
                                <input type="file" style="display:none;" @change="importProjectSnapshot($event)" accept=".json">
                            </label>
                        </div>
                    </div>

                    <div style="margin-top:24px; padding:16px; background:rgba(210,153,34,0.1); border:1px solid rgba(210,153,34,0.3); border-radius:8px;">
                        <h4 style="margin:0 0 8px 0; font-size:12px; color:#d29922;">⚠️ 주의사항</h4>
                        <ul style="margin:0; padding-left:18px; font-size:11px; color:#8b949e; line-height:1.6;">
                            <li>스냅샷을 불러오면 현재 브라우저에 저장된 데이터가 모두 덮어씌워집니다.</li>
                            <li>불러오기 완료 후 페이지가 자동으로 새로고침됩니다.</li>
                            <li>대량의 데이터(8,000개 이상)가 포함된 경우 처리 시 약간의 지연이 발생할 수 있습니다.</li>
                        </ul>
                    </div>
                </div>
            </template>
            
            <!-- Settings Tab -->
            <template x-if="adminTab === 'settings'">
                <div>
                    <h3 style="margin:0 0 16px 0; color:#fff;">시스템 설정</h3>
                    <div class="form-group">
                        <label>Google Sheet 동기화</label>
                        <div style="display:flex; align-items:center; gap:12px;">
                            <input type="checkbox" x-model="syncEnabled" style="width:auto;">
                            <span x-text="syncEnabled ? '활성화' : '비활성화'"></span>
                        </div>
                    </div>
                    <div class="form-group" x-show="syncEnabled">
                        <label>API URL</label>
                        <input type="text" x-model="apiUrl" placeholder="https://script.google.com/macros/s/...">
                    </div>
                    <div class="form-group">
                        <label>데이터 관리</label>
                        <div style="display:flex; gap:8px;">
                            <button class="btn" @click="exportData()">📥 내보내기</button>
                            <button class="btn" style="color:#f85149;" @click="clearAllData()">🗑️ 초기화</button>
                        </div>
                    </div>

                    <hr style="border-color:#30363d; margin: 20px 0;">

                    <!-- Virtual Scrolling Settings -->
                    <h3 style="margin:0 0 16px 0; color:#fff;">🚀 Virtual Scrolling</h3>
                    <div class="form-group">
                        <label>Virtual Scrolling 활성화</label>
                        <div style="display:flex; align-items:center; gap:12px;">
                            <input type="checkbox" x-model="virtualScroll.enabled" style="width:auto;">
                            <span x-text="virtualScroll.enabled ? '활성화 (대규모 그리드 최적화)' : '비활성화'"></span>
                        </div>
                        <small style="color:#8b949e; display:block; margin-top:8px;">
                            1,000셀 이상 그리드에서 자동 활성화됩니다.
                            현재 그리드: <strong x-text="gridConfig.cols * gridConfig.rows"></strong>셀
                        </small>
                    </div>
                    <div class="form-group" x-show="virtualScroll.enabled">
                        <label>버퍼 셀 수</label>
                        <input type="number" x-model.number="virtualScroll.bufferCells" min="0" max="20" style="width:80px;">
                        <small style="color:#8b949e; display:block; margin-top:4px;">
                            뷰포트 외부에 미리 렌더링할 셀 수 (기본: 5)
                        </small>
                    </div>
                    <div class="form-group" x-show="virtualScroll.enabled">
                        <label>현재 렌더링</label>
                        <div style="font-family: monospace; color: #58a6ff; font-size: 12px;">
                            <span x-text="visibleCells.length"></span>셀 렌더링 중
                            (전체 <span x-text="gridCells.length"></span>셀 중)
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>

<!-- Zone Editor Modal -->
<div class="admin-panel-overlay" x-show="showZoneEditor" x-cloak @click.self="showZoneEditor = false"
     role="dialog" aria-modal="true" aria-labelledby="zone-editor-title">
    <div class="admin-panel" style="max-width:500px;">
        <div class="admin-panel-header">
            <h2 id="zone-editor-title" x-text="editingZone ? '🗂️ Zone 편집' : '🗂️ 새 Zone 추가'"></h2>
            <button class="btn" @click="showZoneEditor = false" aria-label="Zone 편집기 닫기">✕</button>
        </div>
        <div class="admin-content">
            <div class="form-group">
                <label>Zone ID</label>
                <input type="text" x-model="zoneForm.id" :disabled="editingZone" placeholder="zone_d">
            </div>
            <div class="form-group">
                <label>Zone 이름</label>
                <input type="text" x-model="zoneForm.name" placeholder="ZONE D">
            </div>
            <div class="form-group">
                <label>표시 이름</label>
                <input type="text" x-model="zoneForm.displayName" placeholder="신규">
            </div>
            <div class="form-group">
                <label>설명</label>
                <input type="text" x-model="zoneForm.description" placeholder="Zone 설명 (선택)">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>시작 컬럼 (X)</label>
                    <input type="number" x-model.number="zoneForm.startColumn" min="1" max="69">
                </div>
                <div class="form-group">
                    <label>끝 컬럼 (X)</label>
                    <input type="number" x-model.number="zoneForm.endColumn" min="1" max="69">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>시작 행 (Y)</label>
                    <select x-model="zoneForm.startRow">
                        <template x-for="(label, idx) in rowLabels" :key="idx">
                            <option :value="idx" x-text="label"></option>
                        </template>
                    </select>
                </div>
                <div class="form-group">
                    <label>끝 행 (Y)</label>
                    <select x-model="zoneForm.endRow">
                        <template x-for="(label, idx) in rowLabels" :key="idx">
                            <option :value="idx" x-text="label"></option>
                        </template>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>색상</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input type="color" x-model="zoneForm.color" style="width:60px; height:32px; padding:0; border:none; cursor:pointer;">
                    <input type="text" x-model="zoneForm.color" style="width:100px;" placeholder="#238636">
                </div>
            </div>

            <hr style="border-color:#30363d; margin:15px 0;">
            <h4 style="color:#8b949e; font-size:12px; margin-bottom:10px;">📋 관리 정보</h4>

            <div class="form-row">
                <div class="form-group">
                    <label>담당 업체</label>
                    <input type="text" x-model="zoneForm.contractor" placeholder="예: 삼성E&A">
                </div>
                <div class="form-group">
                    <label>관리 담당자</label>
                    <input type="text" x-model="zoneForm.supervisor" placeholder="예: 홍길동">
                </div>
            </div>
            <div class="form-group">
                <label>목표 완공일</label>
                <input type="date" x-model="zoneForm.targetDate">
            </div>

            <div class="form-actions">
                <button class="btn" @click="showZoneEditor = false">취소</button>
                <button class="btn btn-primary" @click="saveZone()">💾 저장</button>
            </div>
        </div>
    </div>
</div>

<!-- Issue Create Modal -->
<div class="admin-panel-overlay" x-show="showIssueEditor" x-cloak @click.self="showIssueEditor = false">
    <div class="admin-panel" style="max-width:550px;">
        <div class="admin-panel-header">
            <h2>🚨 새 이슈 등록</h2>
            <button class="btn" @click="showIssueEditor = false" aria-label="이슈 편집기 닫기">✕</button>
        </div>
        <div class="admin-content">
            <div class="form-row">
                <div class="form-group">
                    <label>이슈 유형</label>
                    <select x-model="issueForm.type">
                        <option value="tc">T/C 간섭</option>
                        <option value="design">설계 변경</option>
                        <option value="material">자재 대기</option>
                        <option value="safety">안전 점검</option>
                        <option value="quality">품질 이슈</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>심각도</label>
                    <select x-model="issueForm.severity">
                        <option value="critical">🔴 Critical</option>
                        <option value="high">🟠 High</option>
                        <option value="medium">🟡 Medium</option>
                        <option value="low">🟢 Low</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>이슈 제목</label>
                <input type="text" x-model="issueForm.title" placeholder="예: T/C #5 간섭">
            </div>
            <div class="form-group">
                <label>설명</label>
                <textarea x-model="issueForm.description" rows="3" placeholder="이슈 상세 설명"></textarea>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>영향 컬럼 범위 (시작)</label>
                    <input type="number" x-model.number="issueForm.startColumn" min="1" max="69">
                </div>
                <div class="form-group">
                    <label>영향 컬럼 범위 (끝)</label>
                    <input type="number" x-model.number="issueForm.endColumn" min="1" max="69">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>영향 행 범위 (시작)</label>
                    <select x-model="issueForm.startRow">
                        <template x-for="(label, idx) in rowLabels" :key="idx">
                            <option :value="label" x-text="label"></option>
                        </template>
                    </select>
                </div>
                <div class="form-group">
                    <label>영향 행 범위 (끝)</label>
                    <select x-model="issueForm.endRow">
                        <template x-for="(label, idx) in rowLabels" :key="idx">
                            <option :value="label" x-text="label"></option>
                        </template>
                    </select>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>담당자</label>
                    <input type="text" x-model="issueForm.assignedTo" placeholder="담당자 이름">
                </div>
                <div class="form-group">
                    <label>예상 해결일</label>
                    <input type="date" x-model="issueForm.expectedResolution">
                </div>
            </div>
            <div class="form-group" style="border-top:1px solid #30363d; padding-top:12px; margin-top:8px;">
                <label style="display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" x-model="issueForm.showOverlay" style="width:auto;">
                    그리드에 오버레이 표시
                </label>
            </div>
            <div x-show="issueForm.showOverlay" style="margin-left:20px;">
                <div class="form-row">
                    <div class="form-group">
                        <label>오버레이 라벨</label>
                        <input type="text" x-model="issueForm.overlayLabel" placeholder="⛔ T/C #5">
                    </div>
                    <div class="form-group">
                        <label>테두리 색상</label>
                        <input type="color" x-model="issueForm.overlayColor" style="width:60px; height:32px;">
                    </div>
                </div>
            </div>

            <hr style="border-color:#30363d; margin:15px 0;">
            <h4 style="color:#8b949e; font-size:12px; margin-bottom:10px;">📋 상세 정보 (선택)</h4>

            <div class="form-group">
                <label>근본 원인</label>
                <textarea x-model="issueForm.rootCause" rows="2" placeholder="예: T/C 작업반경 내 기둥 위치"></textarea>
            </div>
            <div class="form-group">
                <label>완화 계획</label>
                <textarea x-model="issueForm.mitigationPlan" rows="2" placeholder="예: X40 라인 우선 시공 후 복귀"></textarea>
            </div>
            <div class="form-group">
                <label>보고자</label>
                <input type="text" x-model="issueForm.reportedBy" placeholder="예: 현장소장">
            </div>

            <div class="form-actions">
                <button class="btn" @click="showIssueEditor = false">취소</button>
                <button class="btn btn-primary" @click="saveIssue()">🚨 이슈 등록</button>
            </div>
        </div>
    </div>
</div>

<!-- Phase 8: Import Preview Modal -->
<div class="import-preview-modal" x-show="showImportPreview" x-cloak @click.self="showImportPreview = false"
     role="dialog" aria-modal="true" aria-labelledby="import-preview-title">
    <div class="import-preview-content">
        <div class="import-preview-header">
            <h2 id="import-preview-title">📥 데이터 가져오기 미리보기</h2>
            <button class="btn" @click="showImportPreview = false" aria-label="미리보기 창 닫기">✕</button>
        </div>
        <div class="import-preview-body">
            <!-- File Info -->
            <div style="margin-bottom:16px; padding:12px; background:var(--bg-secondary); border-radius:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:13px; color:var(--text-main);">
                        📄 <strong x-text="importPreview.fileName"></strong>
                        <span style="color:var(--text-sub); margin-left:8px;" x-text="'(' + importPreview.fileType.toUpperCase() + ')'"></span>
                    </span>
                    <span style="font-size:12px; color:var(--text-sub);" x-text="importPreview.stats.total + '개 행'"></span>
                </div>
            </div>

            <!-- Import Mode Selection -->
            <div class="import-mode-select">
                <button class="import-mode-btn" :class="importPreview.mode === 'update' && 'active'" @click="importPreview.mode = 'update'">
                    <div class="import-mode-icon">🔄</div>
                    <div class="import-mode-label">업데이트</div>
                    <div class="import-mode-hint">기존 데이터만 갱신</div>
                </button>
                <button class="import-mode-btn" :class="importPreview.mode === 'merge' && 'active'" @click="importPreview.mode = 'merge'">
                    <div class="import-mode-icon">➕</div>
                    <div class="import-mode-label">병합</div>
                    <div class="import-mode-hint">새 항목 추가 + 기존 갱신</div>
                </button>
                <button class="import-mode-btn" :class="importPreview.mode === 'replace' && 'active'" @click="importPreview.mode = 'replace'">
                    <div class="import-mode-icon">♻️</div>
                    <div class="import-mode-label">대체</div>
                    <div class="import-mode-hint">모든 데이터 교체</div>
                </button>
            </div>

            <!-- Stats -->
            <div class="import-stats">
                <div class="import-stat-item">
                    <div class="import-stat-value" x-text="importPreview.stats.total"></div>
                    <div class="import-stat-label">전체</div>
                </div>
                <div class="import-stat-item new">
                    <div class="import-stat-value" x-text="importPreview.stats.new"></div>
                    <div class="import-stat-label">신규</div>
                </div>
                <div class="import-stat-item update">
                    <div class="import-stat-value" x-text="importPreview.stats.update"></div>
                    <div class="import-stat-label">업데이트</div>
                </div>
                <div class="import-stat-item error">
                    <div class="import-stat-value" x-text="importPreview.stats.errors"></div>
                    <div class="import-stat-label">오류</div>
                </div>
            </div>

            <!-- CSV Column Mapping (only for CSV) -->
            <template x-if="importPreview.fileType === 'csv' && importPreview.headers.length > 0">
                <div class="import-mapping">
                    <h4>📋 컬럼 매핑</h4>
                    <div class="import-mapping-row">
                        <label>UID (필수)</label>
                        <select x-model="importPreview.columnMapping.uid" @change="recalculateImportStats()">
                            <option value="">-- 선택 --</option>
                            <template x-for="h in importPreview.headers" :key="h">
                                <option :value="h" x-text="h"></option>
                            </template>
                        </select>
                    </div>
                    <div class="import-mapping-row">
                        <label>상태 (Status)</label>
                        <select x-model="importPreview.columnMapping.status" @change="recalculateImportStats()">
                            <option value="">-- 선택 --</option>
                            <template x-for="h in importPreview.headers" :key="h">
                                <option :value="h" x-text="h"></option>
                            </template>
                        </select>
                    </div>
                    <div class="import-mapping-row">
                        <label>잠금 (IsLocked)</label>
                        <select x-model="importPreview.columnMapping.isLocked" @change="recalculateImportStats()">
                            <option value="">-- 선택 --</option>
                            <template x-for="h in importPreview.headers" :key="h">
                                <option :value="h" x-text="h"></option>
                            </template>
                        </select>
                    </div>
                </div>
            </template>

            <!-- Data Preview Table -->
            <div style="max-height:300px; overflow:auto; border:1px solid var(--border-color); border-radius:8px;">
                <table class="import-preview-table">
                    <thead>
                        <tr>
                            <th style="width:60px;">상태</th>
                            <template x-for="h in (importPreview.fileType === 'csv' ? importPreview.headers : ['UID', 'Status', 'Zone'])" :key="h">
                                <th x-text="h"></th>
                            </template>
                        </tr>
                    </thead>
                    <tbody>
                        <template x-for="(row, idx) in importPreview.parsedData.slice(0, 50)" :key="idx">
                            <tr :class="row._importStatus === 'new' ? 'import-row-new' : (row._importStatus === 'error' ? 'import-row-error' : 'import-row-update')">
                                <td>
                                    <span x-show="row._importStatus === 'new'" style="color:#238636;">🆕</span>
                                    <span x-show="row._importStatus === 'update'" style="color:#1f6feb;">🔄</span>
                                    <span x-show="row._importStatus === 'error'" style="color:#da3633;">❌</span>
                                </td>
                                <template x-for="(val, key) in (importPreview.fileType === 'csv' ? row : {uid: row.uid, status: row.status?.code, zone: row.zone?.name})" :key="key">
                                    <td x-show="key !== '_importStatus'" x-text="val"></td>
                                </template>
                            </tr>
                        </template>
                    </tbody>
                </table>
                <template x-if="importPreview.parsedData.length > 50">
                    <div style="padding:12px; text-align:center; color:var(--text-sub); font-size:12px;">
                        ... 외 <span x-text="importPreview.parsedData.length - 50"></span>개 행
                    </div>
                </template>
            </div>

            <!-- Errors -->
            <template x-if="importPreview.errors.length > 0">
                <div class="import-errors">
                    <h4>⚠️ 가져오기 오류 (<span x-text="importPreview.errors.length"></span>건)</h4>
                    <ul>
                        <template x-for="err in importPreview.errors.slice(0, 5)" :key="err">
                            <li x-text="err"></li>
                        </template>
                        <template x-if="importPreview.errors.length > 5">
                            <li style="color:#8b949e;">... 외 <span x-text="importPreview.errors.length - 5"></span>건</li>
                        </template>
                    </ul>
                </div>
            </template>
        </div>
        <div class="import-preview-footer">
            <button class="btn" @click="showImportPreview = false">취소</button>
            <button class="btn btn-primary" @click="executeImport()" :disabled="importPreview.stats.errors > 0 && importPreview.stats.update + importPreview.stats.new === 0">
                ✅ 가져오기 실행 (<span x-text="importPreview.mode === 'merge' ? importPreview.stats.new + importPreview.stats.update : importPreview.stats.update"></span>건)
            </button>
        </div>
    </div>
</div>

<div class="main-container">




    <!-- Sidebar -->
    <aside class="sidebar" :class="{'open': sidebarOpen}" role="navigation" aria-label="사이드바 네비게이션">
        <div>
            <h3>상태 범례</h3>
            <div class="zone-legend">
                <template x-for="(status, code) in statusCodes" :key="code">
                    <div class="legend-item">
                        <div class="color-dot" :style="`background: ${status.color}`"></div>
                        <span x-text="status.label"></span>
                    </div>
                </template>
            </div>
        </div>

        <hr style="border-color:#30363d; margin: 15px 0;">

        <div>
            <h3>공간 구역</h3>
            <template x-for="zone in zones" :key="zone.id">
                <div class="zone-summary" style="margin-bottom: 10px;">
                    <div class="zone-title">
                        <span x-text="zone.name + ': ' + zone.displayName"></span>
                        <span :style="`color: ${zone.style?.primaryColor || zone.color || '#238636'}`"
                              x-text="getZoneProgress(zone.id) + '%'"></span>
                    </div>
                    <div style="font-size:10px; color:#8b949e;"
                         x-text="`X${zone.range?.startColumn || zone.startColumn || 1} ~ X${zone.range?.endColumn || zone.endColumn || 10}`"></div>
                    <div class="progress-bar">
                        <div class="progress-fill"
                             :style="`width: ${getZoneProgress(zone.id)}%; background: ${zone.style?.primaryColor || zone.color || '#238636'}`">
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <hr style="border-color:#30363d; margin: 15px 0;">

        <div>
            <h3>빠른 실행</h3>
            <button class="btn" style="width:100%; margin-bottom:8px;"
                    @click="selectByStatus('pending')">대기 중 전체 선택</button>
            <button class="btn" style="width:100%; margin-bottom:8px;"
                    @click="selectByZone(zones[0]?.id)">Zone A 선택</button>
            <button class="btn btn-success" style="width:100%;"
                    @click="saveToLocalStorage()">💾 로컬 저장</button>
        </div>

        <hr style="border-color:#30363d; margin: 15px 0;">

        <!-- Phase 9: 층-절주 입면 뷰어 (Enhanced) -->
        <div class="elevation-viewer" x-show="elevationViewOpen">
            <div class="elevation-viewer-header">
                <h3>🏗️ 층-절주 입면 뷰어</h3>
                <button class="btn elevation-viewer-toggle" @click="elevationViewOpen = false" title="접기">−</button>
            </div>

            <!-- 층-절주 2D 그리드 -->
            <div class="elevation-grid">
                <!-- 절주 헤더 행 -->
                <div class="elevation-floor-label" style="background:transparent;"></div>
                <template x-for="jeolju in jeoljuList" :key="'header-' + jeolju.jeoljuId">
                    <div class="elevation-jeolju-header" 
                         :class="{'selected': selectedJeolju === jeolju.jeoljuId}"
                         @click="filterByJeolju(jeolju.jeoljuId)"
                         :title="'X' + jeolju.startColumn + '~X' + jeolju.endColumn"
                         x-text="jeolju.label">
                    </div>
                </template>

                <!-- 층별 행 (RF부터 1F까지 역순) -->
                <template x-for="floor in [...floors].reverse()" :key="'row-' + floor.floorId">
                    <div class="elevation-row">
                        <!-- 층 라벨 -->
                        <div class="elevation-floor-label"
                             :class="{'selected': selectedFloor === floor.floorId}"
                             @click="selectFloor(floor.floorId)"
                             :title="floor.columnSize || ''"
                             x-text="floor.label">
                        </div>

                        <!-- 절주별 셀 -->
                        <template x-for="jeolju in jeoljuList" :key="floor.floorId + '-' + jeolju.jeoljuId">
                            <div class="elevation-cell"
                                 :class="getElevationCellClass(floor.floorId, jeolju.jeoljuId)"
                                 @click="selectFloorAndJeolju(floor.floorId, jeolju.jeoljuId)"
                                 :title="floor.label + ' / ' + jeolju.label">
                                <span x-text="getFloorJeoljuProgress(floor.floorId, jeolju.jeoljuId) + '%'" 
                                      style="font-size:9px;"></span>
                            </div>
                        </template>
                    </div>
                </template>
            </div>

            <!-- 범례 -->
            <div class="elevation-legend">
                <div class="elevation-legend-item">
                    <div class="elevation-legend-dot complete"></div>
                    <span>완료</span>
                </div>
                <div class="elevation-legend-item">
                    <div class="elevation-legend-dot in-progress"></div>
                    <span>진행중</span>
                </div>
                <div class="elevation-legend-item">
                    <div class="elevation-legend-dot has-issue"></div>
                    <span>이슈</span>
                </div>
                <div class="elevation-legend-item">
                    <div class="elevation-legend-dot pending"></div>
                    <span>대기</span>
                </div>
            </div>

            <!-- 선택된 층-절주 정보 -->
            <div class="elevation-info" x-show="selectedJeolju || selectedFloor" style="margin-top:12px; padding:12px; background:#0d1117; border-radius:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span style="font-size:12px; font-weight:600; color:#fff;" 
                          x-text="(floors.find(f => f.floorId === selectedFloor)?.label || '전체') + ' / ' + (getSelectedJeoljuLabel() || '전체')"></span>
                    <button class="btn" style="font-size:10px; padding:4px 8px;" 
                            @click="selectedJeolju = null; selectedFloor = 'F01'">초기화</button>
                </div>
                <div style="display:flex; gap:16px;">
                    <div style="text-align:center;">
                        <div style="font-size:18px; font-weight:bold; color:#58a6ff;" 
                             x-text="getJeoljuColumnCount(selectedJeolju) || totalColumns"></div>
                        <div style="font-size:10px; color:#8b949e;">기둥</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="font-size:18px; font-weight:bold; color:#238636;" 
                             x-text="(getJeoljuProgressPercent(selectedJeolju) || getOverallProgress()) + '%'"></div>
                        <div style="font-size:10px; color:#8b949e;">진행률</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="font-size:18px; font-weight:bold; color:#da3633;" 
                             x-text="getJeoljuIssueCount(selectedJeolju) || issues.filter(i => i.status === 'open').length"></div>
                        <div style="font-size:10px; color:#8b949e;">이슈</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 뷰어 접힌 상태 -->
        <div class="elevation-collapsed" x-show="!elevationViewOpen" @click="elevationViewOpen = true">
            <span>📐 절주 뷰어 펼치기</span>
        </div>
    </aside>

    <!-- Canvas Area -->
    <div class="canvas-area" id="main-content" role="main" aria-label="이슈 그리드">
        <!-- Phase 16: View Options Bar -->
        <div class="view-options-bar" style="display:flex; justify-content:space-between; align-items:center; padding:4px 8px; background:#161b22; border-bottom:1px solid #30363d;">
            <div>
                <template x-for="zone in zones" :key="zone.id">
                    <span class="zone-tag" :style="`color: ${zone.style?.primaryColor || zone.color || '#238636'}; margin-right:12px;`" x-text="zone.name + ' (' + zone.displayName + ')'"></span>
                </template>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
                <button class="btn btn-sm" :class="{ 'btn-active': compactMode }" @click="compactMode = !compactMode" title="컴팩트 모드 토글">
                    <span x-show="!compactMode">📐 컴팩트</span>
                    <span x-show="compactMode">🔳 기본</span>
                </button>
                <button class="btn btn-sm" :class="{ 'btn-active': invertRows }" @click="invertRows = !invertRows" title="행 순서 반전 (K→A / A→K)">
                    <span x-show="invertRows">⬇️ K→A</span>
                    <span x-show="!invertRows">⬆️ A→K</span>
                </button>
            </div>
        </div>

        <!-- Selection Banner (shown when items selected) -->
        <div class="selection-banner" x-show="selectedCells.length > 0" x-cloak>
            <div>
                <span class="count" x-text="selectedCells.length"></span> columns selected
                <span style="color:#8b949e; margin-left:10px;">
                    (Shift+Click or Drag to multi-select)
                </span>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="btn btn-primary" @click="openBulkEdit()">✏️ Bulk Edit</button>
                <button class="btn" @click="clearSelection()">✕ Clear</button>
            </div>
        </div>

        <!-- Grid with Virtual Scrolling -->
        <div class="grid-scroll-view"
             x-ref="gridScrollView"
             x-init="$nextTick(() => initVirtualScroll($refs.gridScrollView))"
             @scroll.passive="handleVirtualScroll($event)"
             @mousedown.passive="startDragSelect($event)"
             @mousemove.passive="updateDragSelect($event)"
             @mouseup.passive="endDragSelect()"
             @mouseleave.passive="endDragSelect()"
             @touchstart.passive="startTouchDragSelect($event)"
             @touchmove.passive="updateTouchDragSelect($event)"
             @touchend="endTouchDragSelect($event)"
             @touchcancel="endTouchDragSelect($event)">

            <!-- Virtual Scroll Spacer (maintains scroll area size) -->
            <div x-show="virtualScroll.enabled"
                 class="virtual-grid-spacer"
                 :style="`width: ${totalGridWidth}px; height: ${totalGridHeight}px;`"></div>

            <div class="grid-container"
                 :class="{ 'is-scrolling': virtualScroll.isScrolling, 'compact-mode': compactMode }"
                 :style="virtualScroll.enabled
                     ? `--cols: ${visibleColCount}; --rows: ${visibleRowCount}; transform: translate(${virtualScroll.visibleColStart * virtualScroll.cellWidth}px, ${virtualScroll.visibleRowStart * virtualScroll.cellHeight}px);`
                     : `--cols: ${gridConfig.cols}; --rows: ${gridConfig.rows}`"
                 id="gridMap"
                 role="grid"
                 aria-label="구조 이슈 관리 그리드">

                <!-- Cells: Virtual or Full rendering based on grid size -->
                <template x-for="cell in (virtualScroll.enabled ? visibleCells : gridCells)" :key="cell.key">
                    <div :class="[
                            cell.isHeader ? 'grid-cell-header' : 'grid-cell',
                            !cell.isHeader && isColumnHighlighted(cell.row + '-X' + cell.col) ? 'context-highlighted' : ''
                         ]"
                         :role="cell.isHeader ? 'columnheader' : 'gridcell'"
                         :aria-label="cell.isHeader ? cell.label : (cell.row + '-X' + cell.col + ' 기둥 셀')"
                         :style="!cell.isHeader && isSelected(cell.row, cell.col) ? 'background: rgba(31, 111, 235, 0.3); border-color: #1f6feb;' : ''"
                         @click="!cell.isHeader && handleCellClick($event, cell.row, cell.col)"
                         @dblclick="!cell.isHeader && openDetail(cell.row, cell.col)">
                        <template x-if="cell.isHeader">
                            <span x-text="cell.label"></span>
                        </template>
                        <template x-if="!cell.isHeader">
                            <!-- Phase 6: 2x3 Stage Grid Indicator -->
                            <div class="stage-grid"
                                 :class="{
                                     'locked': isLocked(cell.row, cell.col),
                                     'workflow-filtered': isCellFilteredByWorkflow(cell.row, cell.col),
                                     'jeolju-filtered': !isInSelectedJeolju(cell.col),
                                     'has-issue': hasIssue(cell),
                                     'has-issue-critical': hasIssue(cell) && getIssueForCell(cell)?.severity === 'critical'
                                 }"
                                 :data-uid="cell.row + '-X' + cell.col"
                                 :title="hasIssue(cell) ? getIssueTitle(cell) : getStageTooltip(cell.row, cell.col)"
                                 :data-jeolju="getJeoljuForColumn(cell.col)">
                                <!-- Row 1: hmb_fab, pre_assem, main_assem -->
                                <div class="stage-cell" data-stage="hmb_fab"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'hmb_fab')"></div>
                                <div class="stage-cell" data-stage="pre_assem"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'pre_assem')"></div>
                                <div class="stage-cell" data-stage="main_assem"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'main_assem')"></div>
                                <!-- Row 2: hmb_psrc, form, embed -->
                                <div class="stage-cell" data-stage="hmb_psrc"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'hmb_psrc')"></div>
                                <div class="stage-cell" data-stage="form"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'form')"></div>
                                <div class="stage-cell" data-stage="embed"
                                     :class="'st-' + getStageStatus(cell.row, cell.col, 'embed')"></div>

                                <!-- WP-2: Issue Pin Overlay -->
                                <template x-if="hasIssue(cell)">
                                    <div class="issue-pin"
                                         :class="getIssueSeverityClass(cell)"
                                         :title="getIssueTitle(cell)"
                                         @click.stop="openIssueDetail(cell)">
                                        📍
                                    </div>
                                </template>
                                <!-- WP-2: Multiple Issues Badge -->
                                <template x-if="getIssuesForCell(cell).length > 1">
                                    <div class="issue-count-badge"
                                         :title="getIssuesForCell(cell).length + '개 이슈'"
                                         x-text="getIssuesForCell(cell).length">
                                    </div>
                                </template>
                            </div>
                        </template>
                    </div>
                </template>
            </div>

            <!-- Phase 16: Issue Overlays (contained within grid-scroll-view) -->
            <template x-for="issue in activeIssueOverlays" :key="'overlay-' + issue.id">
                <div class="issue-overlay" 
                     :class="issue.type"
                     :style="getOverlayStyle(issue)"
                     x-text="issue.overlay?.label || issue.title">
                </div>
            </template>
        </div>

        <!-- Virtual Scroll Position Indicator -->
        <div class="virtual-scroll-indicator"
             :class="{ 'visible': virtualScroll.isScrolling && virtualScroll.enabled }"
             x-text="scrollPositionInfo"></div>
    </div>

    <!-- Detail Panel -->
    <div class="detail-panel" :class="{ 'open': detailPanelOpen }" role="complementary" aria-label="이슈 상세정보">
        <div class="panel-header">
            <div style="display:flex; align-items:center; gap:8px;">
                <h2 x-text="currentColumn?.uid || 'Select a column'"></h2>
                <span x-show="currentColumn?.status?.isLocked"
                      class="lock-badge"
                      title="This column is locked - AI cannot override">🔒</span>
            </div>
            <button @click="detailPanelOpen = false"
                    style="background:none; border:none; color:#8b949e; cursor:pointer; font-size:18px;">✕</button>
        </div>
        <div class="panel-content" x-show="currentColumn">
            <!-- Location Info -->
            <div class="prop-row">
                <span>Zone</span>
                <span class="prop-val" x-text="getZoneName(currentColumn?.location?.zoneId)"></span>
            </div>
            <div class="prop-row">
                <span>Position</span>
                <span class="prop-val" x-text="currentColumn?.uid"></span>
            </div>

            <hr style="border-color:#30363d; margin: 15px 0;">

            <!-- Status Editor -->
            <div class="form-group">
                <label>Status</label>
                <select x-model="editForm.status" @change="markDirty()">
                    <template x-for="(status, code) in statusCodes" :key="code">
                        <option :value="code" x-text="status.label"></option>
                    </template>
                </select>
            </div>

            <!-- Lock Toggle -->
            <div class="checkbox-row">
                <input type="checkbox" id="lockToggle" x-model="editForm.isLocked" @change="markDirty()">
                <label for="lockToggle">🔒 Lock (Prevent AI Override)</label>
            </div>

            <hr style="border-color:#30363d; margin: 15px 0;">

            <!-- Member Info -->
            <div class="form-group">
                <label>Member Type</label>
                <select x-model="editForm.memberType" @change="markDirty()">
                    <option value="SRC Column">SRC Column</option>
                    <option value="Steel Beam">Steel Beam</option>
                    <option value="PC Girder">PC Girder</option>
                </select>
            </div>

            <div class="form-group">
                <label>Section</label>
                <input type="text" x-model="editForm.section" @input="markDirty()">
            </div>

            <!-- Save Button -->
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button class="btn" style="flex:1" @click="cancelEdit()">Cancel</button>
                <button class="btn btn-success" style="flex:1" 
                        :disabled="!isDirty"
                        @click="saveColumn()">💾 Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Phase 6: Workflow Footer -->
<footer class="workflow-footer" role="contentinfo">
    <span class="workflow-title">Production Flow</span>

    <svg class="workflow-svg" viewBox="0 0 700 50" preserveAspectRatio="xMidYMid meet">
        <!-- Arrow Marker Definition -->
        <defs>
            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                <polygon points="0 0, 8 3, 0 6" fill="#30363d"/>
            </marker>
        </defs>

        <!-- Connection Arrows -->
        <path class="workflow-arrow" d="M 105 25 L 130 25"/>
        <path class="workflow-arrow" d="M 220 25 L 245 25"/>
        <path class="workflow-arrow" d="M 335 25 L 360 25"/>
        <path class="workflow-arrow" d="M 450 25 L 475 25"/>
        <path class="workflow-arrow" d="M 565 25 L 590 25"/>

        <!-- Stage Nodes -->
        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'hmb_fab', 'filtered': workflowFilter && workflowFilter !== 'hmb_fab' }"
           @click="toggleWorkflowFilter('hmb_fab')"
           style="color: #1f6feb;">
            <rect x="10" y="5" width="90" height="40" fill="#1f6feb" stroke="#1f6feb"/>
            <text x="55" y="20">HMB제작</text>
            <text class="node-count" x="55" y="35" x-text="getStageCount('hmb_fab')"></text>
        </g>

        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'pre_assem', 'filtered': workflowFilter && workflowFilter !== 'pre_assem' }"
           @click="toggleWorkflowFilter('pre_assem')"
           style="color: #8957e5;">
            <rect x="135" y="5" width="80" height="40" fill="#8957e5" stroke="#8957e5"/>
            <text x="175" y="20">면조립</text>
            <text class="node-count" x="175" y="35" x-text="getStageCount('pre_assem')"></text>
        </g>

        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'main_assem', 'filtered': workflowFilter && workflowFilter !== 'main_assem' }"
           @click="toggleWorkflowFilter('main_assem')"
           style="color: #d29922;">
            <rect x="250" y="5" width="80" height="40" fill="#d29922" stroke="#d29922"/>
            <text x="290" y="20">대조립</text>
            <text class="node-count" x="290" y="35" x-text="getStageCount('main_assem')"></text>
        </g>

        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'hmb_psrc', 'filtered': workflowFilter && workflowFilter !== 'hmb_psrc' }"
           @click="toggleWorkflowFilter('hmb_psrc')"
           style="color: #238636;">
            <rect x="365" y="5" width="80" height="40" fill="#238636" stroke="#238636"/>
            <text x="405" y="20">HMB+PSRC</text>
            <text class="node-count" x="405" y="35" x-text="getStageCount('hmb_psrc')"></text>
        </g>

        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'form', 'filtered': workflowFilter && workflowFilter !== 'form' }"
           @click="toggleWorkflowFilter('form')"
           style="color: #da3633;">
            <rect x="480" y="5" width="80" height="40" fill="#da3633" stroke="#da3633"/>
            <text x="520" y="20">FORM</text>
            <text class="node-count" x="520" y="35" x-text="getStageCount('form')"></text>
        </g>

        <g class="workflow-node"
           :class="{ 'active': workflowFilter === 'embed', 'filtered': workflowFilter && workflowFilter !== 'embed' }"
           @click="toggleWorkflowFilter('embed')"
           style="color: #f85149;">
            <rect x="595" y="5" width="80" height="40" fill="#f85149" stroke="#f85149"/>
            <text x="635" y="20">앰베드</text>
            <text class="node-count" x="635" y="35" x-text="getStageCount('embed')"></text>
        </g>
    </svg>

    <!-- Legend / Clear Filter -->
    <div class="workflow-legend">
        <div class="workflow-legend-item"
             :class="{ 'active': !workflowFilter }"
             @click="clearWorkflowFilter()">
            <span>🔄 All Stages</span>
        </div>
        <div class="workflow-legend-item" x-show="workflowFilter">
            <span style="color:#58a6ff">📍 Filtering: </span>
            <span x-text="getStageLabel(workflowFilter)"></span>
        </div>
    </div>
</footer>

<!-- Bulk Edit Panel -->
<div class="bulk-edit-panel" x-show="bulkEditOpen" x-cloak>
    <span class="label">일괄 편집 <strong x-text="selectedCells.length"></strong>개:</span>

    <!-- Lock Status Summary -->
    <div class="lock-status-summary" style="display:flex; align-items:center; gap:6px; background:#21262d; padding:4px 8px; border-radius:4px; font-size:11px;">
        <span>🔒</span>
        <span x-text="getSelectedLockCount() + '/' + selectedCells.length + ' 잠금'"></span>
    </div>

    <div style="display:flex; align-items:center; gap:8px;">
        <label style="font-size:12px; color:#8b949e;">상태:</label>
        <select x-model="bulkEditForm.status">
            <option value="">-- 변경 없음 --</option>
            <template x-for="(status, code) in statusCodes" :key="code">
                <option :value="code" x-text="status.label"></option>
            </template>
        </select>
    </div>

    <!-- Lock Quick Actions -->
    <div style="display:flex; gap:4px;">
        <button class="btn btn-lock" @click="bulkLockSelected(true)"
                title="Lock all selected columns (prevent AI override)"
                style="padding:4px 8px; font-size:11px; background:#2d333b; border:1px solid #444c56;">
            🔒 전체 잠금
        </button>
        <button class="btn btn-unlock" @click="bulkLockSelected(false)"
                title="Unlock all selected columns (allow AI updates)"
                style="padding:4px 8px; font-size:11px; background:#2d333b; border:1px solid #444c56;">
            🔓 전체 해제
        </button>
    </div>

    <div style="flex:1;"></div>

    <button class="btn" @click="closeBulkEdit()">취소</button>
    <button class="btn btn-success" @click="applyBulkEdit()">✅ 전체 적용</button>
</div>

<!-- Issue Panel (Right Sidebar) -->
<div class="issue-panel" :class="{ 'open': issuePanelOpen }">
    <div class="issue-panel-header">
        <h3>🚨 Issues <span style="color:#8b949e; font-weight:normal;" x-text="`(${openIssues.length})`"></span></h3>
        <div style="display:flex; gap:8px;">
            <button class="btn btn-primary" style="padding:4px 8px; font-size:11px;" @click="openNewIssueModal()">+ New</button>
            <button @click="issuePanelOpen = false" style="background:none; border:none; color:#8b949e; cursor:pointer; font-size:16px;" aria-label="이슈 상세 패널 닫기">✕</button>
        </div>
    </div>
    
    <!-- Filter Tabs -->
    <div style="display:flex; border-bottom:1px solid #30363d; padding:0 10px;">
        <button class="btn" style="border:none; border-radius:0; padding:8px 12px;" 
                :style="issueFilter === 'all' ? 'border-bottom:2px solid #1f6feb; color:#fff;' : ''"
                @click="issueFilter = 'all'">All</button>
        <button class="btn" style="border:none; border-radius:0; padding:8px 12px;"
                :style="issueFilter === 'open' ? 'border-bottom:2px solid #1f6feb; color:#fff;' : ''"
                @click="issueFilter = 'open'">Open</button>
        <button class="btn" style="border:none; border-radius:0; padding:8px 12px;"
                :style="issueFilter === 'resolved' ? 'border-bottom:2px solid #1f6feb; color:#fff;' : ''"
                @click="issueFilter = 'resolved'">Resolved</button>
    </div>
    
    <!-- Issue List -->
    <div class="issue-list">
        <template x-if="filteredIssues.length === 0">
            <div style="text-align:center; color:#8b949e; padding:20px; font-size:12px;">
                No issues found
            </div>
        </template>
        
        <template x-for="issue in filteredIssues" :key="issue.id">
            <div class="issue-card" 
                 :class="{ 'active': selectedIssue?.id === issue.id }"
                 @click="selectIssue(issue)">
                <div class="issue-card-header">
                    <div class="issue-severity" :class="issue.severity"></div>
                    <span class="issue-title" x-text="issue.title"></span>
                    <span class="issue-type-badge" :class="issue.type" x-text="issue.type.toUpperCase()"></span>
                </div>
                <div class="issue-meta">
                    <span x-text="issue.id"></span>
                    <span class="issue-status-badge" :class="issue.status.replace('-', '_')" x-text="issue.status"></span>
                </div>
                <div class="issue-affected">
                    📍 <span x-text="(issue.affectedColumns?.length || 0) + ' columns affected'"></span>
                </div>
            </div>
        </template>
    </div>
</div>

<!-- Issue Overlays moved inside grid-scroll-view for proper containment -->

<!-- New Issue Modal -->
<div class="issue-modal" x-show="newIssueModalOpen" x-cloak @click.self="newIssueModalOpen = false"
     role="dialog" aria-modal="true" aria-labelledby="new-issue-modal-title">
    <div class="issue-modal-content">
        <div class="issue-modal-header">
            <h3 id="new-issue-modal-title">➕ New Issue</h3>
            <button @click="newIssueModalOpen = false"
                    style="background:none; border:none; color:#8b949e; cursor:pointer; font-size:18px;"
                    aria-label="새 이슈 모달 닫기">✕</button>
        </div>
        <div class="issue-modal-body">
            <div class="form-group">
                <label for="issue-type">Issue Type</label>
                <select id="issue-type" x-model="newIssueForm.type">
                    <option value="tc">T/C 간섭</option>
                    <option value="design">설계 변경</option>
                    <option value="material">자재 이슈</option>
                    <option value="safety">안전 이슈</option>
                </select>
            </div>

            <div class="form-group">
                <label for="issue-title">Title</label>
                <input id="issue-title" type="text" x-model="newIssueForm.title" placeholder="이슈 제목 입력...">
            </div>

            <div class="form-group">
                <label for="issue-severity">Severity</label>
                <select id="issue-severity" x-model="newIssueForm.severity">
                    <option value="critical">Critical (즉시 조치 필요)</option>
                    <option value="high">High (24시간 내 조치)</option>
                    <option value="medium">Medium (일주일 내 조치)</option>
                    <option value="low">Low (모니터링)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="issue-description">Description</label>
                <textarea id="issue-description" x-model="newIssueForm.description" rows="3" 
                          style="width:100%; padding:8px; background:#0d1117; border:1px solid #30363d; border-radius:4px; color:#c9d1d9; font-size:12px; resize:vertical;"
                          placeholder="상세 내용 입력..."></textarea>
            </div>

            <div class="form-group">
                <label>Affected Columns (<span x-text="selectedCells.length"></span> selected)</label>
                <div style="font-size:11px; color:#8b949e; padding:8px; background:#0d1117; border:1px solid #30363d; border-radius:4px; max-height:60px; overflow-y:auto;">
                    <template x-if="selectedCells.length > 0">
                        <span x-text="selectedCells.slice(0, 20).join(', ') + (selectedCells.length > 20 ? '...' : '')"></span>
                    </template>
                    <template x-if="selectedCells.length === 0">
                        <span style="color:#f85149;">⚠️ 그리드에서 영향받는 기둥을 먼저 선택하세요</span>
                    </template>
                </div>
            </div>

            <div class="form-group">
                <label>Expected Resolution Date</label>
                <input type="date" x-model="newIssueForm.expectedResolution"
                       style="width:100%; padding:8px; background:#0d1117; border:1px solid #30363d; border-radius:4px; color:#c9d1d9; font-size:12px;">
            </div>
        </div>
        <div class="issue-modal-footer">
            <button class="btn" @click="newIssueModalOpen = false">Cancel</button>
            <button class="btn btn-success" @click="createIssue()" :disabled="!newIssueForm.title || selectedCells.length === 0">
                ✅ Create Issue
            </button>
        </div>
    </div>
</div>

<!-- Admin Modal -->
<div class="admin-modal" x-show="showAdminPanel" x-cloak @click.self="showAdminPanel = false"
     role="dialog" aria-modal="true" aria-labelledby="dashboard-settings-title">
    <div class="admin-modal-content">
        <div class="admin-modal-header">
            <h2 id="dashboard-settings-title">⚙️ Dashboard Settings</h2>
            <button @click="showAdminPanel = false"
                    style="background:none; border:none; color:#8b949e; cursor:pointer; font-size:20px;"
                    aria-label="설정 창 닫기">✕</button>
        </div>

        <!-- Tabs -->
        <div class="admin-tabs" role="tablist" aria-label="설정 탭 목록">
            <button class="admin-tab" :class="{ 'active': adminTab === 'zones' }" @click="adminTab = 'zones'" role="tab" :aria-selected="adminTab === 'zones'">📍 Zones</button>
            <button class="admin-tab" :class="{ 'active': adminTab === 'status' }" @click="adminTab = 'status'" role="tab" :aria-selected="adminTab === 'status'">🎨 Status Codes</button>
            <button class="admin-tab" :class="{ 'active': adminTab === 'import' }" @click="adminTab = 'import'" role="tab" :aria-selected="adminTab === 'import'">📥 Import/Export</button>
            <button class="admin-tab" :class="{ 'active': adminTab === 'api' }" @click="adminTab = 'api'" role="tab" :aria-selected="adminTab === 'api'">🔗 API Config</button>
            <button class="admin-tab" :class="{ 'active': adminTab === 'slack' }" @click="adminTab = 'slack'; loadSlackSettings()" role="tab" :aria-selected="adminTab === 'slack'">🔔 Slack</button>
            <button class="admin-tab" :class="{ 'active': adminTab === 'email' }" @click="adminTab = 'email'; loadEmailSettings()" role="tab" :aria-selected="adminTab === 'email'">📧 Email</button>
        </div>
        
        <div class="admin-modal-body">
            <!-- Zone Manager Tab -->
            <div x-show="adminTab === 'zones'">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h3 style="margin:0; font-size:14px; color:#fff;">Zone Configuration</h3>
                    <button class="btn btn-primary" style="padding:6px 12px; font-size:11px;" @click="addNewZone()">+ Add Zone</button>
                </div>
                
                <div class="zone-manager-list">
                    <template x-for="(zone, index) in zones" :key="zone.id">
                        <div class="zone-item">
                            <div class="zone-color-preview" :style="`background: ${zone.style?.backgroundColor || (zone.color + '1a') || 'rgba(35,134,54,0.1)'}; color: ${zone.style?.primaryColor || zone.color || '#238636'};`">
                                <span x-text="zone.name.substring(5, 6)"></span>
                            </div>
                            <div class="zone-info">
                                <h4 x-text="zone.name + ' - ' + zone.displayName"></h4>
                                <p x-text="zone.description"></p>
                            </div>
                            <div class="zone-range" x-text="`X${zone.range?.startColumn || zone.startColumn || 1} ~ X${zone.range?.endColumn || zone.endColumn || 10}`"></div>
                            <div class="zone-actions">
                                <button class="btn" style="padding:4px 8px; font-size:11px;" @click="editZone(zone)">Edit</button>
                                <input type="color" :value="zone.style?.primaryColor || zone.color || '#238636'"
                                       @change="updateZoneColor(zone.id, $event.target.value)"
                                       style="width:28px; height:28px; border:none; cursor:pointer;">
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            
            <!-- Status Codes Tab -->
            <div x-show="adminTab === 'status'">
                <div style="margin-bottom:15px;">
                    <h3 style="margin:0 0 8px 0; font-size:14px; color:#fff;">Status Code Settings</h3>
                    <p style="margin:0; font-size:11px; color:#8b949e;">각 상태의 라벨과 색상을 수정할 수 있습니다.</p>
                </div>
                
                <div class="status-code-grid">
                    <template x-for="(status, code) in statusCodes" :key="code">
                        <div class="status-code-item">
                            <div class="status-dot-preview" :style="`background: ${status.color}`"></div>
                            <div class="status-info">
                                <input type="text" :value="status.label" 
                                       @change="updateStatusLabel(code, $event.target.value)"
                                       :placeholder="code">
                                <div style="font-size:10px; color:#484f58;" x-text="code"></div>
                            </div>
                            <input type="color" :value="status.color" class="status-color-input"
                                   @change="updateStatusColor(code, $event.target.value)">
                        </div>
                    </template>
                </div>
                
                <div style="margin-top:20px; text-align:right;">
                    <button class="btn" @click="resetStatusCodes()">Reset to Default</button>
                    <button class="btn btn-success" @click="saveSettings()">💾 Save Changes</button>
                </div>
            </div>
            
            <!-- Import/Export Tab -->
            <div x-show="adminTab === 'import'">
                <div class="import-export-section">
                    <div>
                        <h3 style="margin:0 0 12px 0; font-size:14px; color:#fff;">📤 Export Data</h3>
                        <div class="export-options">
                            <button class="export-btn" @click="exportData()">
                                <span class="export-btn-icon">📄</span>
                                <span class="export-btn-label">JSON</span>
                                <span class="export-btn-hint">Full data backup</span>
                            </button>
                            <button class="export-btn" @click="exportToCSV()">
                                <span class="export-btn-icon">📊</span>
                                <span class="export-btn-label">CSV</span>
                                <span class="export-btn-hint">Column data only</span>
                            </button>
                            <!-- Excel Export with Dropdown Options -->
                            <div class="export-btn-wrapper" x-data="{ excelMenuOpen: false }" @click.outside="excelMenuOpen = false">
                                <button class="export-btn" @click="excelMenuOpen = !excelMenuOpen" style="position:relative;">
                                    <span class="export-btn-icon">📗</span>
                                    <span class="export-btn-label">Excel <span style="font-size:10px;">▼</span></span>
                                    <span class="export-btn-hint">With formatting</span>
                                </button>
                                <!-- Excel Export Dropdown Menu -->
                                <div class="excel-export-menu" x-show="excelMenuOpen" x-transition style="display:none;">
                                    <div class="excel-menu-item" @click="exportToExcel({ scope: 'all' }); excelMenuOpen = false;">
                                        <span class="excel-menu-icon">📋</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">전체 데이터</span>
                                            <span class="excel-menu-hint">모든 기둥 및 이슈 내보내기</span>
                                        </div>
                                    </div>
                                    <div class="excel-menu-item" @click="exportToExcel({ scope: 'filtered' }); excelMenuOpen = false;">
                                        <span class="excel-menu-icon">🔍</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">필터된 데이터</span>
                                            <span class="excel-menu-hint">현재 필터 조건만 내보내기</span>
                                        </div>
                                    </div>
                                    <div class="excel-menu-item"
                                         :class="{ 'disabled': selectedCells.length === 0 }"
                                         @click="selectedCells.length > 0 && (exportToExcel({ scope: 'selected' }), excelMenuOpen = false)">
                                        <span class="excel-menu-icon">✓</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">선택된 항목</span>
                                            <span class="excel-menu-hint" x-text="selectedCells.length > 0 ? selectedCells.length + '개 선택됨' : '선택된 항목 없음'"></span>
                                        </div>
                                    </div>
                                    <div class="excel-menu-divider"></div>
                                    <div class="excel-menu-item" @click="exportToExcel({ scope: 'floor', floorId: selectedFloor }); excelMenuOpen = false;">
                                        <span class="excel-menu-icon">🏢</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">현재 층만</span>
                                            <span class="excel-menu-hint" x-text="currentFloorLabel + ' 데이터만 내보내기'"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- PDF Export with Dropdown Options -->
                            <div class="export-btn-wrapper" x-data="{ pdfMenuOpen: false }" @click.outside="pdfMenuOpen = false">
                                <button class="export-btn" @click="pdfMenuOpen = !pdfMenuOpen" style="position:relative;">
                                    <span class="export-btn-icon">📕</span>
                                    <span class="export-btn-label">PDF <span style="font-size:10px;">▼</span></span>
                                    <span class="export-btn-hint">Report format</span>
                                </button>
                                <!-- PDF Export Dropdown Menu -->
                                <div class="excel-export-menu" x-show="pdfMenuOpen" x-transition style="display:none;">
                                    <div class="excel-menu-item" @click="generatePDFReport('summary'); pdfMenuOpen = false;">
                                        <span class="excel-menu-icon">📋</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">요약 보고서</span>
                                            <span class="excel-menu-hint">핵심 지표 및 진행률 (2-3페이지)</span>
                                        </div>
                                    </div>
                                    <div class="excel-menu-item" @click="generatePDFReport('detailed'); pdfMenuOpen = false;">
                                        <span class="excel-menu-icon">📚</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">상세 보고서</span>
                                            <span class="excel-menu-hint">층별 상세 현황 포함 (11+ 페이지)</span>
                                        </div>
                                    </div>
                                    <div class="excel-menu-item" @click="generatePDFReport('issues'); pdfMenuOpen = false;">
                                        <span class="excel-menu-icon">🚨</span>
                                        <div class="excel-menu-content">
                                            <span class="excel-menu-label">이슈 보고서</span>
                                            <span class="excel-menu-hint">미해결 이슈 및 통계</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <hr style="border-color:#30363d; margin:10px 0;">

                    <div>
                        <h3 style="margin:0 0 12px 0; font-size:14px; color:#fff;">📥 Import Data</h3>
                        <div class="import-box" 
                             @click="$refs.importFile.click()"
                             @dragover.prevent="$event.target.classList.add('dragover')"
                             @dragleave="$event.target.classList.remove('dragover')"
                             @drop.prevent="handleFileDrop($event)">
                            <div class="import-box-icon">📁</div>
                            <div class="import-box-text">Drop JSON/CSV file here or click to browse</div>
                            <div class="import-box-hint">Supports: .json, .csv (max 5MB)</div>
                        </div>
                        <input type="file" x-ref="importFile" accept=".json,.csv" style="display:none;" 
                               @change="handleFileImport($event)">
                    </div>
                    
                    <hr style="border-color:#30363d; margin:15px 0;">
                    
                    <!-- MGT Import Section -->
                    <div>
                        <h3 style="margin:0 0 12px 0; font-size:14px; color:#fff;">🏗️ MGT 해석모델 가져오기</h3>
                        <p style="margin:0 0 12px 0; font-size:11px; color:#8b949e;">
                            MIDAS Gen/Civil MGT 파일에서 평면 구조를 자동으로 생성합니다.
                        </p>
                        <div class="import-box" 
                             style="border-color: #8957e5; background: rgba(137, 87, 229, 0.05);"
                             @click="$refs.mgtFile.click()"
                             @dragover.prevent="$event.target.classList.add('dragover')"
                             @dragleave="$event.target.classList.remove('dragover')"
                             @drop.prevent="handleMgtDrop($event)">
                            <div class="import-box-icon">📐</div>
                            <div class="import-box-text">MGT 파일을 여기에 드래그하거나 클릭하세요</div>
                            <div class="import-box-hint">*.mgt (MIDAS 해석모델)</div>
                        </div>
                        <input type="file" x-ref="mgtFile" accept=".mgt" style="display:none;" 
                               @change="handleMgtImport($event)">
                        
                        <!-- MGT Import Progress -->
                        <div x-show="mgtImportStatus.loading" style="margin-top:12px; padding:12px; background:#0d1117; border:1px solid #30363d; border-radius:8px;">
                            <div style="display:flex; align-items:center; gap:10px;">
                                <div class="loading-spinner"></div>
                                <span style="font-size:12px; color:#8b949e;" x-text="mgtImportStatus.message"></span>
                            </div>
                        </div>
                        
                        <!-- MGT Import Result -->
                        <div x-show="mgtImportStatus.success" style="margin-top:12px; padding:12px; background:#0d1117; border:1px solid #238636; border-radius:8px;">
                            <div style="display:flex; align-items:center; gap:10px; color:#3fb950; margin-bottom:8px;">
                                <span>✅</span>
                                <span style="font-size:12px; font-weight:600;">MGT 파싱 완료</span>
                            </div>
                            <div style="font-size:11px; color:#8b949e;">
                                <div>노드: <span x-text="mgtImportStatus.nodes"></span>개 | 요소: <span x-text="mgtImportStatus.elements"></span>개</div>
                                <div>그리드: <span x-text="mgtImportStatus.cols"></span>열 × <span x-text="mgtImportStatus.rows"></span>행</div>
                                <div style="color:#58a6ff;">🏢 층 수: <span x-text="mgtImportStatus.floors"></span>개 (Z좌표 기반)</div>
                                <div x-show="mgtImportStatus.excludedCols.length > 0" style="color:#d29922;">
                                    ⚠️ 제외 열: <span x-text="mgtImportStatus.excludedCols.join(', ')"></span>
                                </div>
                            </div>
                            <div style="margin-top:10px; display:flex; gap:8px;">
                                <button class="btn btn-success" style="font-size:11px; padding:6px 12px;" @click="applyMgtConfig()">
                                    ✅ 설정 적용
                                </button>
                                <button class="btn" style="font-size:11px; padding:6px 12px;" @click="mgtImportStatus.success = false">
                                    취소
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- API Config Tab -->
            <div x-show="adminTab === 'api'">
                <div style="margin-bottom:20px;">
                    <h3 style="margin:0 0 8px 0; font-size:14px; color:#fff;">🔗 Google Apps Script API</h3>
                    <p style="margin:0; font-size:11px; color:#8b949e;">
                        웹앱 URL을 입력하면 Google Sheet과 자동 동기화됩니다.
                    </p>
                </div>
                
                <div class="form-group">
                    <label for="api-endpoint-url">API Endpoint URL</label>
                    <input id="api-endpoint-url" type="text" x-model="apiUrl" 
                           placeholder="https://script.google.com/macros/s/YOUR_DEPLOYMENT_ID/exec">
                </div>
                
                <div style="display:flex; gap:10px; margin-top:15px;">
                    <button class="btn" @click="testApiConnection()" :disabled="!apiUrl">
                        🧪 Test Connection
                    </button>
                    <button class="btn btn-success" @click="enableSync()" :disabled="!apiUrl">
                        ✅ Enable Sync
                    </button>
                </div>
                
                <div x-show="syncEnabled" style="margin-top:20px; padding:15px; background:#0d1117; border:1px solid #238636; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:10px; color:#3fb950;">
                        <span>✅</span>
                        <span style="font-size:12px; font-weight:600;">Sync Enabled</span>
                    </div>
                    <div style="font-size:11px; color:#8b949e; margin-top:8px;">
                        Last sync: <span x-text="syncStatus.lastSync || 'Never'"></span>
                    </div>
                    <div style="margin-top:10px;">
                        <button class="btn" style="font-size:11px; padding:4px 8px;" @click="syncNow()">
                            🔄 Sync Now (<span x-text="syncStatus.pending"></span> pending)
                        </button>
                        <button class="btn" style="font-size:11px; padding:4px 8px; margin-left:8px;" @click="disableSync()">
                            Disable
                        </button>
                    </div>
                </div>
            </div>

            <!-- Slack Integration Tab (Phase 11) -->
            <div x-show="adminTab === 'slack'">
                <div style="margin-bottom:20px;">
                    <h3 style="margin:0 0 8px 0; font-size:14px; color:#fff;">🔔 Slack Webhook Integration</h3>
                    <p style="margin:0; font-size:11px; color:#8b949e;">
                        Slack Webhook을 설정하여 대시보드 이벤트 알림을 받으세요.
                    </p>
                </div>

                <!-- Webhook URL Input -->
                <div class="form-group">
                    <label for="slack-webhook-url">Webhook URL</label>
                    <div style="position: relative;">
                        <input id="slack-webhook-url"
                               :type="slackSettings.showWebhookUrl ? 'text' : 'password'"
                               x-model="slackSettings.webhookUrl"
                               placeholder="https://hooks.slack.com/services/T00000000/B00000000/XXXXXXX"
                               style="padding-right: 80px;">
                        <button class="btn"
                                style="position:absolute; right:4px; top:50%; transform:translateY(-50%); padding:4px 8px; font-size:10px;"
                                @click="slackSettings.showWebhookUrl = !slackSettings.showWebhookUrl">
                            <span x-text="slackSettings.showWebhookUrl ? '숨기기' : '보기'"></span>
                        </button>
                    </div>
                    <div x-show="slackSettings.webhookConfigured && !slackSettings.webhookUrl"
                         style="font-size:11px; color:#8b949e; margin-top:4px;">
                        현재 설정됨: <span x-text="slackSettings.webhookUrlMasked"></span>
                    </div>
                </div>

                <!-- Notification Settings -->
                <div style="margin-top:20px;">
                    <h4 style="margin:0 0 12px 0; font-size:13px; color:#fff;">알림 설정</h4>

                    <div class="slack-notification-toggles" style="display:flex; flex-direction:column; gap:12px;">
                        <!-- Critical Issue -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">🚨 Critical 이슈 생성</div>
                                <div style="font-size:10px; color:#8b949e;">심각도가 Critical인 이슈가 등록될 때</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.criticalIssue"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Status Delay -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">⏳ 지연 상태 변경</div>
                                <div style="font-size:10px; color:#8b949e;">기둥 상태가 "delay"로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.statusDelay"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Status Blocked/Hold -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">🛑 Hold 상태 변경</div>
                                <div style="font-size:10px; color:#8b949e;">기둥 상태가 "blocked" 또는 "hold"로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.statusBlocked"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Bulk Update -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">📦 대량 업데이트</div>
                                <div style="font-size:10px; color:#8b949e;">10개 이상의 기둥이 한 번에 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.bulkUpdate"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Daily Summary -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">📊 일일 진행률 요약</div>
                                <div style="font-size:10px; color:#8b949e;">매일 지정된 시간에 진행률 요약 전송 (트리거 설정 필요)</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.dailySummary"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Issue Resolved -->
                        <label class="slack-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">✅ 이슈 해결</div>
                                <div style="font-size:10px; color:#8b949e;">이슈가 해결 상태로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="slackSettings.notifications.issueResolved"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display:flex; gap:10px; margin-top:20px; flex-wrap:wrap;">
                    <button class="btn btn-success" @click="saveSlackSettings()" :disabled="slackSettings.saving">
                        <span x-show="!slackSettings.saving">💾 설정 저장</span>
                        <span x-show="slackSettings.saving">저장 중...</span>
                    </button>
                    <button class="btn" @click="testSlackNotification()"
                            :disabled="slackSettings.testing || (!slackSettings.webhookUrl && !slackSettings.webhookConfigured)">
                        <span x-show="!slackSettings.testing">🧪 테스트 알림 전송</span>
                        <span x-show="slackSettings.testing">전송 중...</span>
                    </button>
                    <button class="btn" @click="clearSlackWebhook()"
                            x-show="slackSettings.webhookConfigured || slackSettings.webhookUrl"
                            style="color:#da3633;">
                        🗑️ Webhook 삭제
                    </button>
                </div>

                <!-- Status Message -->
                <div x-show="slackSettings.message"
                     :class="{'success': slackSettings.messageType === 'success', 'error': slackSettings.messageType === 'error'}"
                     style="margin-top:15px; padding:10px 12px; border-radius:6px; font-size:12px;"
                     :style="slackSettings.messageType === 'success' ? 'background:#0d1117; border:1px solid #238636; color:#3fb950;' : 'background:#0d1117; border:1px solid #da3633; color:#f85149;'">
                    <span x-text="slackSettings.message"></span>
                </div>

                <!-- Help Section -->
                <div style="margin-top:20px; padding:15px; background:#0d1117; border:1px solid var(--border-color); border-radius:8px;">
                    <h4 style="margin:0 0 10px 0; font-size:12px; color:#fff;">📖 Slack Webhook 설정 방법</h4>
                    <ol style="margin:0; padding-left:20px; font-size:11px; color:#8b949e; line-height:1.8;">
                        <li>Slack 워크스페이스에서 <a href="https://api.slack.com/apps" target="_blank" style="color:#58a6ff;">Slack App</a>을 생성합니다.</li>
                        <li>"Incoming Webhooks" 기능을 활성화합니다.</li>
                        <li>알림을 받을 채널을 선택하고 Webhook URL을 생성합니다.</li>
                        <li>생성된 URL을 위 입력란에 붙여넣고 저장합니다.</li>
                        <li>"테스트 알림 전송" 버튼으로 연동을 확인합니다.</li>
                    </ol>
                </div>
            </div>

            <!-- Email Integration Tab (Phase 12) -->
            <div x-show="adminTab === 'email'">
                <div style="margin-bottom:20px;">
                    <h3 style="margin:0 0 8px 0; font-size:14px; color:#fff;">📧 Email 알림 Integration</h3>
                    <p style="margin:0; font-size:11px; color:#8b949e;">
                        이메일 수신자를 설정하여 대시보드 이벤트 알림을 받으세요.
                    </p>
                </div>

                <!-- Email Recipients Management -->
                <div class="form-group">
                    <label>수신자 이메일 목록</label>
                    <div style="margin-bottom:12px;">
                        <div style="display:flex; gap:8px;">
                            <input type="email"
                                   x-model="emailSettings.newRecipient"
                                   placeholder="email@example.com"
                                   @keydown.enter="addEmailRecipient()"
                                   style="flex:1;">
                            <button class="btn btn-primary"
                                    style="padding:8px 16px; white-space:nowrap;"
                                    @click="addEmailRecipient()"
                                    :disabled="!emailSettings.newRecipient">
                                + 추가
                            </button>
                        </div>
                    </div>

                    <!-- Recipients List -->
                    <div x-show="emailSettings.recipients.length > 0"
                         style="max-height:150px; overflow-y:auto; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; padding:8px;">
                        <template x-for="(email, index) in emailSettings.recipients" :key="index">
                            <div style="display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-bottom:1px solid #21262d;">
                                <span style="font-size:12px; color:#c9d1d9; font-family:monospace;" x-text="email"></span>
                                <button class="btn"
                                        style="padding:2px 8px; font-size:10px; color:#f85149;"
                                        @click="removeEmailRecipient(index)"
                                        aria-label="이메일 수신자 제거">
                                    ✕
                                </button>
                            </div>
                        </template>
                    </div>
                    <div x-show="emailSettings.recipients.length === 0"
                         style="padding:20px; text-align:center; background:#0d1117; border:1px solid var(--border-color); border-radius:6px;">
                        <span style="font-size:12px; color:#8b949e;">등록된 수신자가 없습니다</span>
                    </div>
                    <div style="font-size:11px; color:#8b949e; margin-top:8px;">
                        현재 <span x-text="emailSettings.recipients.length"></span>명의 수신자가 등록되어 있습니다.
                    </div>
                </div>

                <!-- Notification Settings -->
                <div style="margin-top:20px;">
                    <h4 style="margin:0 0 12px 0; font-size:13px; color:#fff;">알림 설정</h4>

                    <div class="email-notification-toggles" style="display:flex; flex-direction:column; gap:12px;">
                        <!-- Critical Issue -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">🚨 Critical 이슈 생성</div>
                                <div style="font-size:10px; color:#8b949e;">심각도가 Critical인 이슈가 등록될 때</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.criticalIssue"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Status Delay -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">⏳ 지연 상태 변경</div>
                                <div style="font-size:10px; color:#8b949e;">기둥 상태가 "delay"로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.statusDelay"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Status Blocked/Hold -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">🚫 중단/보류 상태 변경</div>
                                <div style="font-size:10px; color:#8b949e;">기둥 상태가 "blocked" 또는 "hold"로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.statusBlocked"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Bulk Update -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">📦 대량 상태 변경</div>
                                <div style="font-size:10px; color:#8b949e;">10개 이상의 기둥이 일괄 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.bulkUpdate"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Weekly Summary -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">📊 주간 진행률 요약</div>
                                <div style="font-size:10px; color:#8b949e;">주간 진행률 요약 리포트 (트리거 필요)</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.weeklySummary"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>

                        <!-- Issue Resolved -->
                        <label class="email-toggle-item" style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#0d1117; border:1px solid var(--border-color); border-radius:6px; cursor:pointer;">
                            <div>
                                <div style="font-size:12px; color:#fff;">✅ 이슈 해결</div>
                                <div style="font-size:10px; color:#8b949e;">이슈가 해결 상태로 변경될 때</div>
                            </div>
                            <input type="checkbox" x-model="emailSettings.notifications.issueResolved"
                                   style="width:18px; height:18px; cursor:pointer;">
                        </label>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display:flex; gap:10px; margin-top:20px; flex-wrap:wrap;">
                    <button class="btn btn-success" @click="saveEmailSettings()" :disabled="emailSettings.saving">
                        <span x-show="!emailSettings.saving">💾 설정 저장</span>
                        <span x-show="emailSettings.saving">저장 중...</span>
                    </button>
                    <button class="btn" @click="testEmailNotification()"
                            :disabled="emailSettings.testing || emailSettings.recipients.length === 0">
                        <span x-show="!emailSettings.testing">🧪 테스트 이메일 전송</span>
                        <span x-show="emailSettings.testing">전송 중...</span>
                    </button>
                    <button class="btn" @click="clearAllEmailRecipients()"
                            x-show="emailSettings.recipients.length > 0"
                            style="color:#da3633;">
                        🗑️ 전체 삭제
                    </button>
                </div>

                <!-- Status Message -->
                <div x-show="emailSettings.message"
                     :class="{'success': emailSettings.messageType === 'success', 'error': emailSettings.messageType === 'error'}"
                     style="margin-top:15px; padding:10px 12px; border-radius:6px; font-size:12px;"
                     :style="emailSettings.messageType === 'success' ? 'background:#0d1117; border:1px solid #238636; color:#3fb950;' : 'background:#0d1117; border:1px solid #da3633; color:#f85149;'">
                    <span x-text="emailSettings.message"></span>
                </div>

                <!-- Help Section -->
                <div style="margin-top:20px; padding:15px; background:#0d1117; border:1px solid var(--border-color); border-radius:8px;">
                    <h4 style="margin:0 0 10px 0; font-size:12px; color:#fff;">📖 Email 알림 설정 안내</h4>
                    <ul style="margin:0; padding-left:20px; font-size:11px; color:#8b949e; line-height:1.8;">
                        <li>수신자 이메일 주소를 추가하면 해당 이메일로 알림이 발송됩니다.</li>
                        <li>Google Apps Script의 MailApp을 통해 발송되며, 발신자는 스크립트 소유자입니다.</li>
                        <li>주간 요약 리포트는 Apps Script 트리거 설정이 필요합니다.</li>
                        <li>"테스트 이메일 전송" 버튼으로 이메일 수신을 확인해주세요.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Phase 9: History Panel -->
<div class="history-panel" :class="{'open': historyPanelOpen}" x-cloak>
    <div class="history-panel-header">
        <h3>📜 변경 이력</h3>
        <div class="history-controls">
            <select x-model="historyFilter" class="history-filter-select">
                <option value="all">전체</option>
                <option value="status">상태 변경</option>
                <option value="issue">이슈 관련</option>
                <option value="lock">잠금/해제</option>
                <option value="import">데이터 가져오기</option>
            </select>
            <button class="btn" style="padding:4px 8px;" @click="historyPanelOpen = false" aria-label="변경 이력 패널 닫기">✕</button>
        </div>
    </div>
    <div class="history-panel-body">
        <template x-if="filteredHistory.length === 0">
            <div class="history-empty">
                <span>📋</span>
                <p>변경 이력이 없습니다</p>
            </div>
        </template>
        <template x-for="group in groupedHistory" :key="group.date">
            <div class="history-date-group">
                <div class="history-date-label" x-text="group.dateLabel"></div>
                <template x-for="item in group.items" :key="item.id">
                    <div class="history-item" @click="openHistoryDetail(item)">
                        <div class="history-item-icon" :class="item.type" x-text="getHistoryIcon(item.type)"></div>
                        <div class="history-item-content">
                            <div class="history-item-title" x-text="item.title"></div>
                            <div class="history-item-meta">
                                <span x-text="item.user || 'System'"></span>
                                <span>•</span>
                                <span x-text="formatHistoryTime(item.timestamp)"></span>
                            </div>
                        </div>
                        <div class="history-item-badge" :class="item.type" x-text="item.affectedCount || 1"></div>
                    </div>
                </template>
            </div>
        </template>
    </div>
    <div class="history-panel-footer">
        <button class="btn" @click="loadMoreHistory()" x-show="hasMoreHistory">더 보기</button>
        <button class="btn" @click="exportHistory()">📥 CSV 내보내기</button>
    </div>
</div>

<!-- WP-4: Report Panel -->
<div class="report-panel-overlay" x-show="showReportPanel" x-cloak @click.self="showReportPanel = false"
     role="dialog" aria-modal="true" aria-labelledby="report-panel-title">
    <div class="report-panel">
        <div class="report-panel-header">
            <h2 id="report-panel-title">📊 고급 리포트</h2>
            <button class="btn" @click="showReportPanel = false" aria-label="리포트 패널 닫기">✕</button>
        </div>

        <!-- Report Tabs -->
        <div class="report-tabs" role="tablist" aria-label="보고서 탭" style="padding: 0 20px;">
            <button class="report-tab" role="tab"
                    :class="{ 'active': reportTab === 'overview' }"
                    :aria-selected="reportTab === 'overview'"
                    :tabindex="reportTab === 'overview' ? 0 : -1"
                    @click="reportTab = 'overview'">
                📈 개요
            </button>
            <button class="report-tab" role="tab"
                    :class="{ 'active': reportTab === 'zones' }"
                    :aria-selected="reportTab === 'zones'"
                    :tabindex="reportTab === 'zones' ? 0 : -1"
                    @click="reportTab = 'zones'">
                🗂️ Zone별 현황
            </button>
            <button class="report-tab" role="tab"
                    :class="{ 'active': reportTab === 'issues' }"
                    :aria-selected="reportTab === 'issues'"
                    :tabindex="reportTab === 'issues' ? 0 : -1"
                    @click="reportTab = 'issues'">
                🚨 이슈 통계
            </button>
            <button class="report-tab" role="tab"
                    :class="{ 'active': reportTab === 'trend' }"
                    :aria-selected="reportTab === 'trend'"
                    :tabindex="reportTab === 'trend' ? 0 : -1"
                    @click="reportTab = 'trend'">
                📉 트렌드
            </button>
        </div>

        <div class="report-panel-body">
            <!-- Overview Tab -->
            <template x-if="reportTab === 'overview'">
                <div>
                    <!-- Stats Grid -->
                    <div class="stats-grid">
                        <div class="stat-card success">
                            <div class="stat-value" x-text="getOverallProgress() + '%'"></div>
                            <div class="stat-label">전체 진행률</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" x-text="Object.keys(columns).length.toLocaleString()"></div>
                            <div class="stat-label">총 기둥 수</div>
                        </div>
                        <div class="stat-card critical">
                            <div class="stat-value" x-text="openIssues.length"></div>
                            <div class="stat-label">미해결 이슈</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" x-text="Object.values(columns).filter(c => c.status?.code === 'complete').length"></div>
                            <div class="stat-label">완료 기둥</div>
                        </div>
                    </div>

                    <!-- Stage Progress -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">🔧</span>
                            공정별 진행 현황
                        </div>
                        <div class="progress-list">
                            <template x-for="stage in stageConfigs" :key="stage.code">
                                <div class="progress-item">
                                    <div class="progress-item-label" x-text="stage.label"></div>
                                    <div class="progress-item-bar">
                                        <div class="progress-item-fill"
                                             :style="`width: ${getStageProgress(stage.code)}%; background: ${stage.color};`"></div>
                                    </div>
                                    <div class="progress-item-value" x-text="getStageProgress(stage.code) + '%'"></div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Status Distribution Donut -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">🍩</span>
                            상태별 분포
                        </div>
                        <div class="donut-chart-container">
                            <svg class="donut-chart-svg" viewBox="0 0 150 150" width="150" height="150"
                                 x-html="getStatusDonutSVG()">
                            </svg>
                            <div class="donut-legend">
                                <template x-for="(item, code) in statusCodes" :key="code">
                                    <div class="donut-legend-item">
                                        <div class="donut-legend-dot" :style="`background: ${item.color}`"></div>
                                        <span x-text="item.label"></span>
                                        <span class="donut-legend-value"
                                              x-text="Object.values(columns).filter(c => c.status?.code === code).length"></span>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </template>

            <!-- Zones Tab -->
            <template x-if="reportTab === 'zones'">
                <div>
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">🗂️</span>
                            Zone별 진행률
                        </div>
                        <div class="progress-list">
                            <template x-for="zone in zones" :key="zone.id">
                                <div class="progress-item">
                                    <div class="progress-item-label" x-text="zone.name"></div>
                                    <div class="progress-item-bar">
                                        <div class="progress-item-fill"
                                             :style="`width: ${getZoneProgress(zone)}%; background: ${zone.color || '#238636'};`"></div>
                                    </div>
                                    <div class="progress-item-value" x-text="getZoneProgress(zone) + '%'"></div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Zone Detail Table -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">📋</span>
                            Zone별 상세 현황
                        </div>
                        <table class="issue-table">
                            <thead>
                                <tr>
                                    <th>Zone</th>
                                    <th>전체</th>
                                    <th>완료</th>
                                    <th>진행중</th>
                                    <th>미착수</th>
                                    <th>진행률</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="zone in zones" :key="zone.id">
                                    <tr>
                                        <td x-text="zone.name"></td>
                                        <td x-text="getZoneColumnCount(zone)"></td>
                                        <td x-text="getZoneStatusCount(zone, 'complete')"></td>
                                        <td x-text="getZoneStatusCount(zone, 'in_progress')"></td>
                                        <td x-text="getZoneStatusCount(zone, 'not_started')"></td>
                                        <td><span class="severity-badge low" x-text="getZoneProgress(zone) + '%'"></span></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </template>

            <!-- Issues Tab -->
            <template x-if="reportTab === 'issues'">
                <div>
                    <!-- Issue Stats -->
                    <div class="stats-grid">
                        <div class="stat-card critical">
                            <div class="stat-value" x-text="issues.filter(i => i.severity === 'critical' && i.status === 'open').length"></div>
                            <div class="stat-label">Critical 이슈</div>
                        </div>
                        <div class="stat-card high">
                            <div class="stat-value" x-text="issues.filter(i => i.severity === 'high' && i.status === 'open').length"></div>
                            <div class="stat-label">High 이슈</div>
                        </div>
                        <div class="stat-card medium">
                            <div class="stat-value" x-text="issues.filter(i => i.severity === 'medium' && i.status === 'open').length"></div>
                            <div class="stat-label">Medium 이슈</div>
                        </div>
                        <div class="stat-card success">
                            <div class="stat-value" x-text="issues.filter(i => i.status === 'resolved').length"></div>
                            <div class="stat-label">해결됨</div>
                        </div>
                    </div>

                    <!-- Issue Severity Donut -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">🎯</span>
                            심각도별 이슈 분포
                        </div>
                        <div class="donut-chart-container">
                            <svg class="donut-chart-svg" viewBox="0 0 150 150" width="150" height="150"
                                 x-html="getIssueSeverityDonutSVG()">
                            </svg>
                            <div class="donut-legend">
                                <div class="donut-legend-item">
                                    <div class="donut-legend-dot" style="background: #f85149;"></div>
                                    <span>Critical</span>
                                    <span class="donut-legend-value" x-text="issues.filter(i => i.severity === 'critical').length"></span>
                                </div>
                                <div class="donut-legend-item">
                                    <div class="donut-legend-dot" style="background: #f97316;"></div>
                                    <span>High</span>
                                    <span class="donut-legend-value" x-text="issues.filter(i => i.severity === 'high').length"></span>
                                </div>
                                <div class="donut-legend-item">
                                    <div class="donut-legend-dot" style="background: #d29922;"></div>
                                    <span>Medium</span>
                                    <span class="donut-legend-value" x-text="issues.filter(i => i.severity === 'medium').length"></span>
                                </div>
                                <div class="donut-legend-item">
                                    <div class="donut-legend-dot" style="background: #238636;"></div>
                                    <span>Low</span>
                                    <span class="donut-legend-value" x-text="issues.filter(i => i.severity === 'low').length"></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Recent Issues -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">📋</span>
                            최근 이슈 목록
                        </div>
                        <table class="issue-table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>제목</th>
                                    <th>심각도</th>
                                    <th>상태</th>
                                    <th>보고일</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="issue in issues.slice(0, 10)" :key="issue.id">
                                    <tr>
                                        <td x-text="issue.id"></td>
                                        <td x-text="issue.title.substring(0, 30) + (issue.title.length > 30 ? '...' : '')"></td>
                                        <td>
                                            <span class="severity-badge" :class="issue.severity" x-text="issue.severity"></span>
                                        </td>
                                        <td x-text="issue.status === 'open' ? '미해결' : '해결됨'"></td>
                                        <td x-text="issue.reportedAt ? new Date(issue.reportedAt).toLocaleDateString('ko-KR') : '-'"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </template>

            <!-- Trend Tab -->
            <template x-if="reportTab === 'trend'">
                <div>
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">📉</span>
                            일별 작업 현황 (최근 14일)
                        </div>
                        <div class="trend-chart-container" style="height: 200px; position: relative;">
                            <svg class="chart-svg" viewBox="0 0 600 180" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%;">
                                <!-- Grid lines -->
                                <line x1="40" y1="20" x2="580" y2="20" class="chart-grid-line"/>
                                <line x1="40" y1="60" x2="580" y2="60" class="chart-grid-line"/>
                                <line x1="40" y1="100" x2="580" y2="100" class="chart-grid-line"/>
                                <line x1="40" y1="140" x2="580" y2="140" class="chart-grid-line"/>

                                <!-- Trend Line - simplified for Vite compatibility -->
                                <g x-show="getTrendData().length > 0">
                                    <path :d="getTrendLinePath()" class="chart-area" fill="#238636"/>
                                    <path :d="getTrendLinePath(false)" class="chart-line" stroke="#238636" fill="none"/>
                                </g>
                            </svg>
                            <!-- Trend data labels rendered separately -->
                            <div style="display:flex; justify-content:space-between; padding: 0 40px; margin-top: 8px;">
                                <template x-for="(point, idx) in getTrendData()" :key="'label-' + idx">
                                    <span x-show="idx % 2 === 0 || idx === getTrendData().length - 1"
                                          class="chart-axis-label" style="font-size: 10px; color: var(--text-muted);"
                                          x-text="point.label"></span>
                                </template>
                            </div>
                        </div>
                    </div>

                    <!-- History Summary -->
                    <div class="chart-container">
                        <div class="chart-title">
                            <span class="chart-icon">📜</span>
                            최근 활동 요약
                        </div>
                        <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="stat-card">
                                <div class="stat-value" x-text="getTrendData().reduce((sum, d) => sum + d.changes, 0)"></div>
                                <div class="stat-label">총 변경 (14일)</div>
                            </div>
                            <div class="stat-card success">
                                <div class="stat-value" x-text="getTrendData().reduce((sum, d) => sum + d.completions, 0)"></div>
                                <div class="stat-label">완료 건수</div>
                            </div>
                            <div class="stat-card critical">
                                <div class="stat-value" x-text="getTrendData().reduce((sum, d) => sum + d.issues, 0)"></div>
                                <div class="stat-label">신규 이슈</div>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <!-- Report Actions -->
        <div class="report-actions">
            <button class="report-btn" @click="exportReportToCSV()">
                📊 CSV 내보내기
            </button>
            <button class="report-btn" @click="generatePDFReport('detailed')">
                📕 PDF 보고서
            </button>
            <button class="report-btn primary" @click="showReportPanel = false">
                닫기
            </button>
        </div>
    </div>
</div>

<!-- WP-1: FAB (Floating Action Button) -->
<div class="fab-container" x-data="{ fabOpen: false }" @click.outside="fabOpen = false">
    <!-- FAB Action Buttons -->
    <div class="fab-actions" :class="{ 'open': fabOpen }">
        <div class="fab-action">
            <span class="fab-action-label">📊 요약</span>
            <button class="fab-action-btn primary"
                    @click="fabOpen = false; showSummaryPanel = true"
                    aria-label="현황 요약 보기">
                📊
            </button>
        </div>
        <div class="fab-action">
            <span class="fab-action-label">이슈 생성</span>
            <button class="fab-action-btn warning"
                    @click="fabOpen = false; openIssueForm()"
                    aria-label="새 이슈 생성">
                🚨
            </button>
        </div>
        <div class="fab-action" x-show="selectedCells.length > 0">
            <span class="fab-action-label">일괄 편집</span>
            <button class="fab-action-btn"
                    @click="fabOpen = false; openBulkEdit()"
                    aria-label="선택 항목 일괄 편집">
                ✏️
            </button>
        </div>
        <div class="fab-action">
            <span class="fab-action-label">빠른 동기화</span>
            <button class="fab-action-btn success"
                    @click="fabOpen = false; syncNow()"
                    aria-label="Google Sheet 동기화">
                🔄
            </button>
        </div>
        <div class="fab-action">
            <span class="fab-action-label">PDF 리포트</span>
            <button class="fab-action-btn"
                    @click="fabOpen = false; generatePDFReport()"
                    aria-label="PDF 리포트 생성">
                📄
            </button>
        </div>
        <div class="fab-action">
            <span class="fab-action-label">Shop 이슈</span>
            <button class="fab-action-btn"
                    :class="{ 'has-badge': shopIssueStats.unresolved > 0 }"
                    @click="fabOpen = false; showShopIssuePanel = true"
                    aria-label="Shop Issue 현황 보기">
                📋
                <span class="fab-badge" x-show="shopIssueStats.unresolved > 0" x-text="shopIssueStats.unresolved"></span>
            </button>
        </div>
    </div>

    <!-- Main FAB Button -->
    <button class="fab-main touch-target"
            :class="{ 'open': fabOpen }"
            @click="fabOpen = !fabOpen"
            aria-label="빠른 작업 메뉴"
            aria-expanded="fabOpen">
        ➕
    </button>
</div>

<!-- Phase 12-1: Context Intelligence - Quick Paste Bar -->
<div class="context-paste-bar"
     x-show="contextPanelOpen"
     x-cloak
     x-transition:enter="transition ease-out duration-200"
     x-transition:enter-start="opacity-0 transform translate-y-full"
     x-transition:enter-end="opacity-100 transform translate-y-0"
     x-transition:leave="transition ease-in duration-150"
     x-transition:leave-start="opacity-100 transform translate-y-0"
     x-transition:leave-end="opacity-0 transform translate-y-full"
     role="dialog"
     aria-label="컨텍스트 입력 패널">

    <!-- Header -->
    <div class="context-bar-header">
        <h3>📋 Smart Paste</h3>
        <button class="context-bar-close"
                @click="contextPanelOpen = false; contextInput = ''; contextSuggestions = []; highlightedColumns = []"
                aria-label="닫기">×</button>
    </div>

    <!-- Input Area -->
    <div class="context-input-area">
        <textarea
            x-model="contextInput"
            placeholder="카톡, 메일, 회의록 내용을 붙여넣으세요...&#10;예: 'C-X1~5 설치 완료, A구역 3층 보류'&#10;🤖 AI 모드: '거기 아까 말한 3개 기둥 처리해' 같은 자연어도 OK"
            rows="3"
            class="context-textarea"
            @keydown.ctrl.enter="analyzeContext()"
            aria-label="컨텍스트 입력"></textarea>

        <!-- Phase 12-3: AI Enhanced Analysis Toggle -->
        <div class="context-ai-toggle">
            <label class="toggle-switch" title="AI 강화 분석: 모호한 표현도 이해합니다">
                <input type="checkbox" x-model="useAiNlp" aria-label="AI 강화 분석 토글">
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label" :class="{ 'active': useAiNlp }">
                <span x-show="!useAiNlp">🔤 패턴</span>
                <span x-show="useAiNlp">🤖 AI</span>
            </span>
        </div>

        <button class="context-analyze-btn"
                @click="analyzeContext()"
                :disabled="!contextInput.trim() || contextProcessing"
                :class="{ 'processing': contextProcessing, 'ai-mode': useAiNlp }">
            <span x-show="!contextProcessing && !useAiNlp">🔍 분석하기</span>
            <span x-show="!contextProcessing && useAiNlp">🤖 AI 분석</span>
            <span x-show="contextProcessing">⏳ 분석 중...</span>
        </button>
    </div>

    <!-- Suggestions List -->
    <div class="context-suggestions" x-show="contextSuggestions.length > 0">
        <h4>📊 제안 사항 (<span x-text="contextSuggestions.length"></span>개)</h4>
        <template x-for="(suggestion, idx) in contextSuggestions" :key="idx">
            <div class="context-suggestion-card"
                 :class="{
                     'status-change': suggestion.type === 'status_change',
                     'issue-create': suggestion.type === 'issue_create'
                 }">
                <div class="suggestion-content">
                    <span class="suggestion-icon" x-text="suggestion.type === 'status_change' ? '🔄' : '⚠️'"></span>
                    <div class="suggestion-text">
                        <strong x-text="suggestion.columns.map(c => c.id || c).join(', ')"></strong>
                        <template x-if="suggestion.type === 'status_change'">
                            <span> → <span x-text="getStatusLabel(suggestion.newStatus)"></span></span>
                        </template>
                        <template x-if="suggestion.type === 'issue_create'">
                            <span> 이슈 생성</span>
                        </template>
                        <div class="suggestion-confidence">
                            신뢰도: <span x-text="suggestion.confidence + '%'"></span>
                        </div>
                    </div>
                </div>
                <div class="suggestion-actions">
                    <button class="btn-approve"
                            @click="approveContextSuggestion(suggestion)"
                            aria-label="승인">✓</button>
                    <button class="btn-reject"
                            @click="rejectContextSuggestion(suggestion)"
                            aria-label="거절">✕</button>
                </div>
            </div>
        </template>
    </div>

    <!-- Source Preview -->
    <div class="context-source-preview" x-show="contextInput.trim()">
        <small>📝 원본: "<span x-text="contextInput.substring(0, 50) + (contextInput.length > 50 ? '...' : '')"></span>"</small>
    </div>
</div>

<!-- Context Paste Toggle Button (Floating) -->
<button class="context-paste-toggle"
        x-show="!contextPanelOpen"
        @click="contextPanelOpen = true"
        aria-label="Smart Paste 열기">
    📋
</button>

<!-- Phase 12-2: Context Source Modal -->
<div class="context-source-modal-overlay"
     x-show="contextSourceModal.open"
     x-cloak
     x-transition:enter="transition ease-out duration-200"
     x-transition:enter-start="opacity-0"
     x-transition:enter-end="opacity-100"
     x-transition:leave="transition ease-in duration-150"
     x-transition:leave-start="opacity-100"
     x-transition:leave-end="opacity-0"
     @click.self="closeContextSource()"
     role="dialog"
     aria-modal="true"
     aria-labelledby="context-source-title">

    <div class="context-source-modal">
        <!-- Header -->
        <div class="context-source-header">
            <h3 id="context-source-title">📄 원본 컨텍스트</h3>
            <button class="context-source-close"
                    @click="closeContextSource()"
                    aria-label="닫기">×</button>
        </div>

        <!-- Content -->
        <template x-if="contextSourceModal.context">
            <div class="context-source-content">
                <!-- Meta Info -->
                <div class="context-source-meta">
                    <div class="meta-item">
                        <span class="meta-label">📅 시간</span>
                        <span class="meta-value" x-text="new Date(contextSourceModal.context.timestamp).toLocaleString('ko-KR')"></span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">🎯 적용 작업</span>
                        <span class="meta-value" x-text="contextSourceModal.context.appliedAction"></span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">📊 신뢰도</span>
                        <span class="meta-value" x-text="contextSourceModal.context.parsedData?.confidence + '%'"></span>
                    </div>
                </div>

                <!-- Affected Columns -->
                <div class="context-source-columns">
                    <span class="section-label">🏗️ 영향받은 기둥</span>
                    <div class="column-tags">
                        <template x-for="col in contextSourceModal.context.affectedColumns" :key="col">
                            <span class="column-tag" x-text="col"></span>
                        </template>
                    </div>
                </div>

                <!-- Original Text (Highlighted) -->
                <div class="context-source-text">
                    <span class="section-label">📝 원본 텍스트</span>
                    <div class="original-text-box">
                        <p x-text="contextSourceModal.context.rawText"></p>
                    </div>
                </div>

                <!-- Parsed Data -->
                <div class="context-source-parsed">
                    <span class="section-label">🔍 파싱 결과</span>
                    <pre x-text="JSON.stringify(contextSourceModal.context.parsedData, null, 2)"></pre>
                </div>
            </div>
        </template>

        <!-- Footer -->
        <div class="context-source-footer">
            <button class="btn btn-primary" @click="closeContextSource()">확인</button>
        </div>
    </div>
</div>

<!-- Phase 13: Summary Panel (실무자용 요약 뷰) -->
<div class="summary-panel-overlay"
     x-show="showSummaryPanel"
     x-cloak
     @click.self="showSummaryPanel = false"
     role="dialog"
     aria-modal="true"
     aria-labelledby="summary-panel-title">

    <div class="summary-panel" id="summary-panel-content">
        <!-- Header -->
        <div class="summary-panel-header">
            <h2 id="summary-panel-title">📊 P5 복합동 현황</h2>
            <span class="summary-date" x-text="new Date().toLocaleDateString('ko-KR', {year:'numeric', month:'long', day:'numeric'})"></span>
            <button class="summary-close-btn"
                    @click="showSummaryPanel = false"
                    aria-label="닫기">×</button>
        </div>

        <!-- Body -->
        <div class="summary-panel-body">
            <!-- Overall Progress -->
            <div class="summary-overall">
                <div class="overall-label">전체 진행률</div>
                <div class="overall-value" x-text="getOverallProgress() + '%'"></div>
                <div class="overall-bar">
                    <div class="overall-bar-fill" :style="`width: ${getOverallProgress()}%`"></div>
                </div>
            </div>

            <!-- Zone Cards -->
            <div class="summary-zones">
                <template x-for="zone in zones" :key="zone.id">
                    <div class="summary-zone-card" :style="`border-color: ${zone.color}`">
                        <div class="zone-card-name" x-text="zone.displayName || zone.name"></div>
                        <div class="zone-card-progress" x-text="getZoneProgress(zone.id) + '%'"></div>
                        <div class="zone-card-bar">
                            <div class="zone-card-bar-fill" :style="`width: ${getZoneProgress(zone.id)}%; background: ${zone.color}`"></div>
                        </div>
                        <div class="zone-card-stats">
                            <span>완료: <strong x-text="getZoneCompletedCount(zone.id)"></strong></span>
                            <span>전체: <strong x-text="getZoneTotalCount(zone.id)"></strong></span>
                        </div>
                    </div>
                </template>
            </div>

            <!-- Quick Stats -->
            <div class="summary-quick-stats">
                <div class="quick-stat" :class="{'has-critical': openIssues.some(i => i.severity === 'critical')}">
                    <div class="stat-icon">🚨</div>
                    <div class="stat-value" x-text="openIssues.length"></div>
                    <div class="stat-label">열린 이슈</div>
                    <template x-if="openIssues.some(i => i.severity === 'critical')">
                        <div class="stat-badge critical">Critical <span x-text="openIssues.filter(i => i.severity === 'critical').length"></span></div>
                    </template>
                </div>
                <div class="quick-stat">
                    <div class="stat-icon">🔄</div>
                    <div class="stat-value" x-text="getActiveColumnsCount()"></div>
                    <div class="stat-label">진행중</div>
                </div>
                <div class="quick-stat">
                    <div class="stat-icon">✅</div>
                    <div class="stat-value" x-text="getCompletedColumnsCount()"></div>
                    <div class="stat-label">완료</div>
                </div>
            </div>

            <!-- Stage Progress (6단계 공정) -->
            <div class="summary-stages">
                <div class="stages-title">공정별 진행 현황</div>
                <div class="stages-list">
                    <template x-for="stage in stageConfigs" :key="stage.id">
                        <div class="stage-item">
                            <span class="stage-name" x-text="stage.name"></span>
                            <span class="stage-count" x-text="getStageCount(stage.id)"></span>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="summary-panel-footer">
            <button class="btn btn-secondary" @click="saveSummaryAsImage()">
                📷 이미지 저장
            </button>
            <button class="btn btn-secondary" @click="copySummaryLink()">
                🔗 링크 복사
            </button>
            <button class="btn btn-primary" @click="showSummaryPanel = false">
                확인
            </button>
        </div>
    </div>
</div>

<!-- Shop Issue Analysis Panel -->
<div class="shop-issue-panel-overlay"
     x-show="showShopIssuePanel"
     x-cloak
     @click.self="showShopIssuePanel = false"
     role="dialog"
     aria-modal="true"
     aria-labelledby="shop-issue-panel-title">

    <div class="shop-issue-panel" id="shop-issue-panel-content">
        <!-- Header -->
        <div class="shop-issue-panel-header">
            <h3 id="shop-issue-panel-title">Shop Issue 현황</h3>
            <div class="shop-issue-header-actions">
                <button class="btn-issue-import"
                        @click="$refs.shopIssueFileInput.click()"
                        title="Shop Issue CSV 가져오기">
                    📂 파일 가져오기
                </button>
                <input type="file"
                       x-ref="shopIssueFileInput"
                       accept=".csv,.xlsx,.xls"
                       @change="handleShopIssueFileUpload($event)"
                       style="display:none">
                <button class="shop-issue-close-btn"
                        @click="showShopIssuePanel = false"
                        aria-label="닫기">x</button>
            </div>
        </div>

        <!-- 요약 통계 -->
        <div class="shop-issue-summary-stats">
            <div class="shop-issue-stat-item total">
                <span class="shop-issue-stat-value" x-text="shopIssueStats.total"></span>
                <span class="shop-issue-stat-label">전체</span>
            </div>
            <div class="shop-issue-stat-item resolved">
                <span class="shop-issue-stat-value" x-text="shopIssueStats.resolved"></span>
                <span class="shop-issue-stat-label">반영</span>
            </div>
            <div class="shop-issue-stat-item unresolved">
                <span class="shop-issue-stat-value" x-text="shopIssueStats.unresolved"></span>
                <span class="shop-issue-stat-label">미반영</span>
            </div>
        </div>

        <!-- 유형별 진행 바 -->
        <div class="shop-issue-type-bars" x-show="Object.keys(shopIssueStats.byType).length > 0">
            <template x-for="(stats, type) in shopIssueStats.byType" :key="type">
                <div class="shop-issue-type-bar-item">
                    <span class="shop-issue-type-badge" :class="'type-' + type.toLowerCase().replace(/[^a-z0-9]/g, '')" x-text="type"></span>
                    <div class="shop-issue-progress-bar">
                        <div class="shop-issue-progress-fill" :style="'width:' + (stats.total > 0 ? (stats.resolved/stats.total*100) : 0) + '%'"></div>
                    </div>
                    <span class="shop-issue-type-count" x-text="stats.resolved + '/' + stats.total"></span>
                </div>
            </template>
        </div>

        <!-- 필터/정렬 -->
        <div class="shop-issue-filters">
            <select x-model="shopIssueFilter" class="shop-issue-filter-select">
                <option value="all">전체</option>
                <option value="unresolved">미반영만</option>
                <option value="resolved">반영만</option>
            </select>
            <select x-model="shopIssueSortBy" class="shop-issue-sort-select">
                <option value="type">유형별</option>
                <option value="location">위치별</option>
                <option value="id">번호순</option>
            </select>
        </div>

        <!-- 이슈 목록 -->
        <div class="shop-issue-list">
            <template x-if="shopIssues.length === 0">
                <div class="shop-issue-empty">
                    <p>등록된 Shop Issue가 없습니다.</p>
                    <p class="shop-issue-empty-hint">CSV 파일을 가져와서 이슈를 등록하세요.</p>
                </div>
            </template>
            <template x-for="issue in getFilteredShopIssues()" :key="issue.id">
                <div class="shop-issue-item" 
                     :class="{'unresolved': issue.status !== 'O', 'has-columns': issue.linkedColumns?.length > 0}"
                     @click="highlightIssueColumns(issue)">
                    <span class="shop-issue-id" x-text="issue.id"></span>
                    <div class="shop-issue-content">
                        <span class="shop-issue-title" x-text="issue.title || issue.description || '-'"></span>
                        <div class="shop-issue-meta">
                            <span class="shop-issue-location" x-text="issue.location || '-'"></span>
                            <span class="shop-issue-columns-badge" 
                                  x-show="issue.linkedColumns?.length > 0"
                                  x-text="'🏗️ ' + (issue.linkedColumns?.length || 0) + '개 기둥'"
                                  :title="issue.linkedColumns?.join(', ')"></span>
                        </div>
                    </div>
                    <span class="shop-issue-type-tag" x-text="issue.type || '-'"></span>
                    <span class="shop-issue-status"
                          :class="issue.status === 'O' ? 'resolved' : 'pending'"
                          x-text="issue.status === 'O' ? '반영' : '미반영'"></span>
                </div>
            </template>
        </div>

        <!-- Footer -->
        <div class="shop-issue-panel-footer">
            <span class="shop-issue-count-info" x-text="'총 ' + getFilteredShopIssues().length + '건'"></span>
            <button class="btn btn-primary" @click="showShopIssuePanel = false">닫기</button>
        </div>
    </div>
</div>

<!-- Mouse Drag Selection Overlay -->
<div class="mouse-drag-overlay"
     x-show="isDragging"
     x-cloak
     role="region"
     aria-label="마우스 드래그 선택 영역"
     aria-hidden="!isDragging">
    <div class="mouse-drag-rect"
         :style="`
             left: ${Math.min(dragStart?.x || 0, dragEnd?.x || 0)}px;
             top: ${Math.min(dragStart?.y || 0, dragEnd?.y || 0)}px;
             width: ${Math.abs((dragEnd?.x || 0) - (dragStart?.x || 0))}px;
             height: ${Math.abs((dragEnd?.y || 0) - (dragStart?.y || 0))}px;
         `"
         role="presentation">
    </div>
</div>

<!-- Mouse Selection Hint -->
<div class="mouse-select-hint"
     x-show="isDragging && dragCellCount > 0"
     x-cloak
     role="status"
     aria-live="polite"
     aria-atomic="true">
    <span aria-hidden="true">🖱️</span>
    <span x-text="dragCellCount + '개 셀 선택 중...'"></span>
</div>

<!-- WP-1: Touch Drag Selection Overlay -->
<div class="touch-drag-overlay"
     x-show="touchDragActive"
     x-cloak
     role="region"
     aria-label="터치 드래그 선택 영역"
     aria-hidden="!touchDragActive">
    <div class="touch-drag-rect"
         :style="`
             left: ${Math.min(touchDragStart.x, touchDragEnd.x)}px;
             top: ${Math.min(touchDragStart.y, touchDragEnd.y)}px;
             width: ${Math.abs(touchDragEnd.x - touchDragStart.x)}px;
             height: ${Math.abs(touchDragEnd.y - touchDragStart.y)}px;
         `"
         role="presentation">
    </div>
</div>

<!-- WP-1: Touch Selection Hint -->
<div class="touch-select-hint"
     x-show="touchDragActive && touchDragCellCount > 0"
     x-cloak
     role="status"
     aria-live="polite"
     aria-atomic="true">
    <span aria-hidden="true">📱</span>
    <span x-text="touchDragCellCount + '개 셀 선택 중...'"></span>
</div>

<!-- Mobile Bottom Navigation -->
<nav class="mobile-nav" x-cloak>
    <div class="mobile-nav-item" :class="{'active': mobileNavTab === 'grid'}" @click="mobileNavTab = 'grid'; sidebarOpen = false">
        <span class="nav-icon">📊</span>
        <span>그리드</span>
    </div>
    <div class="mobile-nav-item" :class="{'active': issuePanelOpen}" @click="toggleIssuePanel(); mobileNavTab = 'issues'">
        <span class="nav-icon">🚨</span>
        <span>이슈</span>
        <template x-if="openIssues.length > 0">
            <span class="nav-badge" x-text="openIssues.length > 9 ? '9+' : openIssues.length"></span>
        </template>
    </div>
    <div class="mobile-nav-item" :class="{'active': notificationPanelOpen}" @click="toggleNotificationPanel(); mobileNavTab = 'notifications'">
        <span class="nav-icon">🔔</span>
        <span>알림</span>
        <template x-if="unreadNotificationCount > 0">
            <span class="nav-badge" x-text="unreadNotificationCount > 9 ? '9+' : unreadNotificationCount"></span>
        </template>
    </div>
    <div class="mobile-nav-item" :class="{'active': sidebarOpen}" @click="sidebarOpen = !sidebarOpen; mobileNavTab = sidebarOpen ? 'menu' : 'grid'">
        <span class="nav-icon">☰</span>
        <span>메뉴</span>
    </div>
</nav>

<!-- Sidebar Backdrop (Mobile Only) -->
<div class="sidebar-backdrop" :class="{'open': sidebarOpen}" @click="sidebarOpen = false" x-cloak></div>

<!-- Toast Notification -->
<template x-if="toast.show">
    <div class="toast" :class="toast.type" x-show="toast.show" x-cloak>
        <span x-text="toast.message"></span>
    </div>
</template>

<script>
// ===== Security Utilities (Phase 10) =====

/**
 * HTML 특수문자 이스케이프 (XSS 방지)
 * @param {string} str - 이스케이프할 문자열
 * @returns {string} 안전한 문자열
 */
function escapeHtml(str) {
    if (!str || typeof str !== 'string') return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

/**
 * URL 안전성 검증
 * @param {string} url - 검증할 URL
 * @returns {boolean} 안전한 URL인지 여부
 */
function isSafeUrl(url) {
    if (!url || typeof url !== 'string') return false;
    try {
        const parsed = new URL(url, window.location.origin);
        // http:, https:, data:만 허용
        return ['http:', 'https:', 'data:'].includes(parsed.protocol);
    } catch {
        return false;
    }
}

/**
 * 입력 길이 제한
 * @param {string} input - 입력값
 * @param {number} maxLength - 최대 길이 (기본 500)
 * @returns {string} 제한된 문자열
 */
function limitInput(input, maxLength = 500) {
    if (!input || typeof input !== 'string') return '';
    return input.substring(0, maxLength);
}

// ===== Data Store =====
const P5Store = {
    STORAGE_KEY: 'p5_dashboard_data',
    STORAGE_KEY_COMPRESSED: 'p5_data_lz',
    MAX_STORAGE_SIZE: 4 * 1024 * 1024, // 4MB limit (safe margin)

    getDefaultData() {
        return {
            zones: [
                {
                    id: 'zone_a',
                    name: 'ZONE A',
                    displayName: 'FAB',
                    description: 'Utility Support',
                    range: { startColumn: 1, endColumn: 23, startRow: 0, endRow: 11 },
                    style: { primaryColor: '#238636', backgroundColor: 'rgba(35,134,54,0.1)', progressPercent: 0 },
                    contractor: '삼성E&A',
                    supervisor: '',
                    targetDate: '',
                    metadata: { createdAt: '2025-12-01', updatedAt: '2025-12-01', createdBy: 'system' }
                },
                {
                    id: 'zone_b',
                    name: 'ZONE B',
                    displayName: 'CUB',
                    description: 'Main Link',
                    range: { startColumn: 24, endColumn: 45, startRow: 0, endRow: 11 },
                    style: { primaryColor: '#1f6feb', backgroundColor: 'rgba(31,111,235,0.1)', progressPercent: 0 },
                    contractor: '삼성E&A',
                    supervisor: '',
                    targetDate: '',
                    metadata: { createdAt: '2025-12-01', updatedAt: '2025-12-01', createdBy: 'system' }
                },
                {
                    id: 'zone_c',
                    name: 'ZONE C',
                    displayName: 'COMPLEX',
                    description: 'Office/Amenity',
                    range: { startColumn: 46, endColumn: 69, startRow: 0, endRow: 11 },
                    style: { primaryColor: '#d29922', backgroundColor: 'rgba(210,153,34,0.1)', progressPercent: 0 },
                    contractor: '삼성E&A',
                    supervisor: '',
                    targetDate: '',
                    metadata: { createdAt: '2025-12-01', updatedAt: '2025-12-01', createdBy: 'system' }
                }
            ],
            columns: {},
            statusCodes: {
                pending: { label: '대기', color: '#484f58', shape: 'circle' },
                active: { label: '진행중', color: '#1f6feb', shape: 'circle' },
                installed: { label: '설치완료', color: '#238636', shape: 'circle' },
                hold_tc: { label: 'T/C Hold', color: '#da3633', shape: 'square' },
                hold_design: { label: '설계 변경', color: '#d29922', shape: 'circle' },
                hold_material: { label: '자재 대기', color: '#8957e5', shape: 'circle' }
            },
            // H-4 Fix: productionStages를 P5Store로 이동 (master_config.json과 동기화)
            productionStages: [
                { code: 'design_shop', label: 'SHOP도면', labelEn: 'SHOP Drawing', order: 0, color: '#8957e5' },
                { code: 'hmb_fab', label: 'HMB제작', labelEn: 'HMB Fabrication', order: 1, color: '#1f6feb' },
                { code: 'pre_assem', label: '면조립', labelEn: 'Pre-Assembly', order: 2, color: '#ab7df8' },
                { code: 'main_assem', label: '대조립', labelEn: 'Main Assembly', order: 3, color: '#d29922' },
                { code: 'hmb_psrc', label: 'HMB+PSRC', labelEn: 'HMB+PSRC Insert', order: 4, color: '#238636' },
                { code: 'form', label: 'FORM', labelEn: 'Formwork', order: 5, color: '#da3633' },
                { code: 'embed', label: '앰베드', labelEn: 'Embed', order: 6, color: '#f85149' }
            ]
        };
    },

    /**
     * Extract only modified columns (sparse storage)
     * Only saves columns where status != 'pending' or has issues/locks
     */
    getModifiedColumns(columns) {
        const modified = {};
        let count = 0;
        for (const [uid, col] of Object.entries(columns)) {
            // Save if: non-default status, locked, or has stages modified
            const isModified =
                (col.status && col.status.code !== 'pending') ||
                col.isLocked ||
                (col.stages && Object.values(col.stages).some(s => s.status !== 'pending'));

            if (isModified) {
                // Store minimal data only
                modified[uid] = {
                    s: col.status?.code || 'pending',  // status code
                    l: col.isLocked ? 1 : 0,           // locked flag
                    st: col.stages ? Object.fromEntries(
                        Object.entries(col.stages)
                            .filter(([_, v]) => v.status !== 'pending')
                            .map(([k, v]) => [k, v.status])
                    ) : undefined
                };
                // Remove empty stages
                if (modified[uid].st && Object.keys(modified[uid].st).length === 0) {
                    delete modified[uid].st;
                }
                count++;
            }
        }
        console.log(`[P5Store] Sparse storage: ${count} modified columns (of ${Object.keys(columns).length} total)`);
        return modified;
    },

    /**
     * Restore full column data from sparse storage
     */
    restoreColumns(sparseColumns, fullColumns) {
        if (!sparseColumns || Object.keys(sparseColumns).length === 0) {
            return fullColumns;
        }

        const restored = { ...fullColumns };
        for (const [uid, sparse] of Object.entries(sparseColumns)) {
            if (restored[uid]) {
                // Restore status
                if (sparse.s) {
                    restored[uid].status = { code: sparse.s };
                }
                // Restore lock
                if (sparse.l) {
                    restored[uid].isLocked = true;
                }
                // Restore stages
                if (sparse.st) {
                    restored[uid].stages = restored[uid].stages || {};
                    for (const [stage, status] of Object.entries(sparse.st)) {
                        restored[uid].stages[stage] = { status };
                    }
                }
            }
        }
        console.log(`[P5Store] Restored ${Object.keys(sparseColumns).length} modified columns`);
        return restored;
    },

    load() {
        try {
            // Try compressed format first
            const compressed = localStorage.getItem(this.STORAGE_KEY_COMPRESSED);
            if (compressed && typeof LZString !== 'undefined') {
                const decompressed = LZString.decompressFromUTF16(compressed);
                if (decompressed) {
                    const data = JSON.parse(decompressed);
                    console.log(`[P5Store] Loaded compressed data (${(compressed.length / 1024).toFixed(1)}KB)`);
                    return data;
                }
            }

            // Fallback to legacy format
            const saved = localStorage.getItem(this.STORAGE_KEY);
            if (saved) {
                console.log(`[P5Store] Loaded legacy data (${(saved.length / 1024).toFixed(1)}KB)`);
                return JSON.parse(saved);
            }
        } catch (e) {
            console.error('[P5Store] Failed to load data:', e);
        }
        return this.getDefaultData();
    },

    save(data) {
        try {
            // Prepare sparse data (only save modified columns)
            const sparseData = {
                zones: data.zones,
                modifiedColumns: this.getModifiedColumns(data.columns || {}),
                issues: data.issues,
                statusCodes: data.statusCodes,
                savedAt: new Date().toISOString()
            };

            const jsonString = JSON.stringify(sparseData);

            // Try compressed save first
            if (typeof LZString !== 'undefined') {
                const compressed = LZString.compressToUTF16(jsonString);
                const compressionRatio = ((1 - compressed.length / jsonString.length) * 100).toFixed(1);

                if (compressed.length < this.MAX_STORAGE_SIZE) {
                    localStorage.setItem(this.STORAGE_KEY_COMPRESSED, compressed);
                    // Clean up legacy key
                    localStorage.removeItem(this.STORAGE_KEY);
                    console.log(`[P5Store] Saved compressed (${(compressed.length / 1024).toFixed(1)}KB, ${compressionRatio}% reduction)`);
                    return true;
                } else {
                    console.warn(`[P5Store] Compressed data too large (${(compressed.length / 1024).toFixed(1)}KB)`);
                }
            }

            // Fallback: try uncompressed (might fail for large data)
            if (jsonString.length < this.MAX_STORAGE_SIZE) {
                localStorage.setItem(this.STORAGE_KEY, jsonString);
                console.log(`[P5Store] Saved uncompressed (${(jsonString.length / 1024).toFixed(1)}KB)`);
                return true;
            }

            console.warn('[P5Store] Data too large to save, skipping localStorage');
            return false;
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                console.warn('[P5Store] Storage quota exceeded, data not saved');
            } else {
                console.error('[P5Store] Failed to save data:', e);
            }
            return false;
        }
    },

    /**
     * Get storage usage info
     */
    getStorageInfo() {
        let used = 0;
        for (const key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                used += localStorage.getItem(key).length * 2; // UTF-16 = 2 bytes per char
            }
        }
        return {
            used: used,
            usedKB: (used / 1024).toFixed(1),
            usedMB: (used / 1024 / 1024).toFixed(2),
            limit: '5MB (typical)',
            p5DataSize: (localStorage.getItem(this.STORAGE_KEY_COMPRESSED)?.length ||
                         localStorage.getItem(this.STORAGE_KEY)?.length || 0) * 2
        };
    },
    
    // ★ 프로젝트 스냅샷 내보내기 (모든 설정 + 노드 + 상태 포함)
    exportSnapshot(app) {
        const snapshot = {
            projectInfo: {
                name: "P5 Dashboard Project",
                exportDate: new Date().toISOString(),
                version: "1.0.0"
            },
            configurations: {
                floors: app.floors,
                jeoljuConfig: app.jeoljuConfig,
                columnSegments: app.columnSegments,
                zones: app.zones,
                statusCodes: app.statusCodes,
                productionStages: app.productionStages
            },
            mgt_grid: app.gridConfig,
            data: {
                columns: app.columns,
                issues: app.issues,
                history: app.history
            }
        };
        
        const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `P5_Snapshot_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
    },

    // ★ 프로젝트 스냅샷 불러오기
    async importSnapshot(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const snapshot = JSON.parse(e.target.result);
                    resolve(snapshot);
                } catch (err) {
                    reject(err);
                }
            };
            reader.onerror = reject;
            reader.readAsText(file);
        });
    }
};

// ===== Alpine.js Application =====
function dashboard() {
    // ★ MGT Grid Config from column_data_generator.js (197,835 columns support)
    const MGT_CONFIG = (typeof COLUMN_CONFIG !== 'undefined') ? COLUMN_CONFIG : null;

    return {
        // Grid Config - MGT 규격 (327 cols × 55 rows) or fallback to legacy
        gridConfig: MGT_CONFIG
            ? { cols: MGT_CONFIG.columnRange.end - MGT_CONFIG.columnRange.start + 1, rows: MGT_CONFIG.rowLabels.length }
            : { cols: 69, rows: 11 },
        rowLabels: MGT_CONFIG
            ? MGT_CONFIG.rowLabels
            : ['A','B','C','D','E','F','G','H','I','J','K'],

        // Virtual Scrolling State
        virtualScroll: {
            enabled: true,
            scrollTop: 0,
            scrollLeft: 0,
            viewportWidth: 800,
            viewportHeight: 600,
            cellWidth: 28,    // 26px + 2px gap
            cellHeight: 28,   // 26px + 2px gap
            headerWidth: 37,  // 35px + 2px gap
            headerHeight: 27, // 25px + 2px gap
            bufferCells: 5,   // Extra cells to render outside viewport
            visibleColStart: 0,
            visibleColEnd: 30,
            visibleRowStart: 0,
            visibleRowEnd: 20,
            isScrolling: false,
            scrollTimeout: null,
            _resizeTimeout: null,  // WP-5: Resize debounce 타이머
            _scrollHideTimeout: null  // WP-5: Scroll indicator hide 타이머
        },
        
        // Data
        zones: [],
        columns: {},
        statusCodes: {},
        
        // UI State
        selectedCells: [],
        detailPanelOpen: false,
        currentColumn: null,
        bulkEditOpen: false,
        showAdminPanel: false,
        adminTab: 'zones',
        // WP-4: Report Panel State
        showReportPanel: false,
        reportTab: 'overview',
        reportData: null,
        showZoneEditor: false,
        editingZone: null,
        zoneForm: {
            id: '', name: '', displayName: '', description: '',
            startColumn: 1, endColumn: 10, startRow: 0, endRow: 11, color: '#238636',
            contractor: '', supervisor: '', targetDate: ''
        },
        showIssueEditor: false,
        issueFilter: 'all',

        // Phase 12-1: Context Intelligence State
        contextPanelOpen: false,
        contextInput: '',
        contextSuggestions: [],
        contextProcessing: false,
        highlightedColumns: [],

        // Phase 12-2: Context Storage State
        contextStore: [],              // 저장된 컨텍스트 목록
        contextSourceModal: {
            open: false,
            context: null              // 현재 보기 중인 컨텍스트
        },

        // Phase 12-3: Advanced NLP State
        useAiNlp: false,               // AI 강화 분석 사용 여부
        nlpPreviousColumns: [],        // 이전에 언급된 기둥 (컨텍스트 유지)

        // Phase 13: Summary Panel (실무자용 요약 뷰)
        showSummaryPanel: false,

        // Phase 16: Layout Optimization
        compactMode: false,    // 컴팩트 그리드 모드 (셀 너비 축소)
        invertRows: true,      // Y축 반전 (K→A, CAD 일치)

        // Shop Issue Module State
        shopIssues: [],
        shopIssueStats: {
            total: 0,
            resolved: 0,
            unresolved: 0,
            byType: {},
            byLocation: {}
        },
        showShopIssuePanel: false,
        shopIssueFilter: 'all',   // all|resolved|unresolved
        shopIssueSortBy: 'type',  // type|location|date

        // Phase 15: Excel 회의록 파서 통합
        issueColumnLinks: [],     // 이슈 ID ↔ 기둥 ID 매핑
        highlightedColumns: [],   // 현재 하이라이트된 기둥들

        // WP-5: Export Libraries Lazy Loading State
        _exportLibsLoading: false,
        _exportLibsLoaded: false,

        /**
         * WP-5: Dynamically load export libraries (SheetJS, jsPDF)
         * Saves ~150KB on initial page load
         */
        async loadExportLibs() {
            if (this._exportLibsLoaded) return true;
            if (this._exportLibsLoading) {
                // Wait for ongoing load to complete
                while (this._exportLibsLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return this._exportLibsLoaded;
            }

            this._exportLibsLoading = true;
            this.showToast('Export 라이브러리 로딩 중...', 'info');

            const loadScript = (src) => {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load: ${src}`));
                    document.head.appendChild(script);
                });
            };

            try {
                // Load SheetJS first
                await loadScript('https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js');

                // Load jsPDF and autotable sequentially (autotable depends on jsPDF)
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js');

                this._exportLibsLoaded = true;
                this._exportLibsLoading = false;
                console.log('[WP-5] Export libraries loaded successfully');
                return true;
            } catch (error) {
                console.error('[WP-5] Failed to load export libraries:', error);
                this._exportLibsLoading = false;
                this.showToast('Export 라이브러리 로드 실패', 'error');
                return false;
            }
        },

        // ★ 프로젝트 스냅샷 내보내기/불러오기 기능
        exportProjectSnapshot() {
            P5Store.exportSnapshot(this);
            this.showToast('Project Snapshot exported successfully', 'success');
        },

        async importProjectSnapshot(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const snapshot = await P5Store.importSnapshot(file);
                
                // 데이터 적용
                if (snapshot.configurations) {
                    this.floors = snapshot.configurations.floors || this.floors;
                    this.jeoljuConfig = snapshot.configurations.jeoljuConfig || this.jeoljuConfig;
                    this.columnSegments = snapshot.configurations.columnSegments || this.columnSegments;
                    this.zones = snapshot.configurations.zones || this.zones;
                    this.statusCodes = snapshot.configurations.statusCodes || this.statusCodes;
                    this.productionStages = snapshot.configurations.productionStages || this.productionStages;
                }

                if (snapshot.mgt_grid) {
                    this.gridConfig = snapshot.mgt_grid;
                }

                if (snapshot.data) {
                    this.columns = snapshot.data.columns || {};
                    this.issues = snapshot.data.issues || [];
                    this.history = snapshot.data.history || [];
                }

                this.saveToLocalStorage();
                this.showToast('Project Snapshot loaded and applied', 'success');
                
                // 페이지 새로고침하여 데이터 캐시 등 초기화 권장 (또는 init 재호출)
                setTimeout(() => window.location.reload(), 1500);
            } catch (err) {
                console.error('Snapshot import failed:', err);
                this.showToast('Failed to import snapshot: ' + err.message, 'error');
            }
        },

        issueForm: {
            type: 'tc', title: '', description: '', severity: 'medium',
            startColumn: 1, endColumn: 10, startRow: 'A', endRow: 'L',
            assignedTo: '', expectedResolution: '',
            showOverlay: true, overlayLabel: '', overlayColor: '#da3633',
            // Phase 7+: Extended Issue Schema
            rootCause: '',           // 근본 원인
            mitigationPlan: '',      // 완화 계획
            reportedBy: 'dashboard'  // 보고자
        },
        isDirty: false,
        
        // Drag Selection (Mouse)
        isDragging: false,
        dragStart: null,
        dragEnd: null,
        dragGridRect: null,
        dragCellCount: 0,

        // WP-1: Touch Drag Selection State
        touchDragActive: false,
        touchDragStart: { x: 0, y: 0 },
        touchDragEnd: { x: 0, y: 0 },
        touchDragCellCount: 0,
        touchDragGridRect: null,

        // Edit Forms
        editForm: {
            status: 'pending',
            isLocked: false,
            memberType: 'SRC Column',
            section: 'H-500x500'
        },
        bulkEditForm: {
            status: '',
            setLock: false
        },
        
        // Toast
        toast: { show: false, message: '', type: 'success' },

        // Import Preview State (for CSV/JSON import)
        showImportPreview: false,
        importPreview: {
            fileName: '',
            fileType: '',
            mode: 'update',
            headers: [],
            parsedData: [],
            rawData: null,
            columnMapping: { uid: '', status: '', isLocked: '' },
            stats: { total: 0, new: 0, update: 0, errors: 0 },
            errors: []
        },

        // Sync State
        syncEnabled: false,
        apiUrl: 'https://script.google.com/macros/s/AKfycbyzvzDbe6NQ0Ni_Fp7I0LLNlg66st7mnnLkxtqjxUTtZnA7KeGRqp2Gcb8c_rjgbm1eTg/exec',
        currentFloor: 'ALL', // 레거시 층 선택 (F1, F2, ALL)
        
        // Issue State
        issues: [],
        issueIndexMap: null, // Performance: Map<cellUID, Issue[]> for O(1) lookup
        _severityClassCache: null, // WP-5 Phase 2: Memoized severity classes
        issuePanelOpen: false,
        issueFilter: 'all',
        selectedIssue: null,
        newIssueModalOpen: false,
        newIssueForm: {
            type: 'tc',
            title: '',
            severity: 'medium',
            description: '',
            expectedResolution: ''
        },
        
        // Admin Panel State
        adminTab: 'zones',

        // MGT Import State
        mgtImportStatus: {
            loading: false,
            success: false,
            message: '',
            nodes: 0,
            elements: 0,
            cols: 0,
            rows: 0,
            excludedCols: [],
            parsedData: null
        },

        // Phase 6: Workflow Filter
        workflowFilter: null,  // null = show all, or stage code like 'hmb_fab'

        // Phase 6: Stage Configuration (H-4 Fix: 기본값, init()에서 P5Store 데이터로 덮어씀)
        stageConfigs: [
            { code: 'design_shop', label: 'SHOP도면', color: '#8957e5', order: 0 },
            { code: 'hmb_fab', label: 'HMB제작', color: '#1f6feb', order: 1 },
            { code: 'pre_assem', label: '면조립', color: '#ab7df8', order: 2 },
            { code: 'main_assem', label: '대조립', color: '#d29922', order: 3 },
            { code: 'hmb_psrc', label: 'HMB+PSRC', color: '#238636', order: 4 },
            { code: 'form', label: 'FORM', color: '#da3633', order: 5 },
            { code: 'embed', label: '앰베드', color: '#f85149', order: 6 }
        ],

        // Phase 5: AI Analysis State
        analysisJob: {
            status: 'idle',  // idle, pending, running, completed, failed
            jobId: null,
            startedAt: null,
            result: null
        },
        analysisPollingInterval: null,

        // Phase 7: 층-절주 구조
        // ★ 절주 = 수직 분절 (층 그룹), 열 구간 = 수평 분절 (컬럼 범위)
        floors: [],              // 11개 층 데이터 (API에서 로드)
        jeoljuConfig: [],        // 절주 = 층 그룹 (수직 분절, 1절주~4절주)
        columnSegments: [],      // 열 구간 = 컬럼 범위 (수평 분절, S1~S8)
        jeoljuList: [],          // 하위 호환: columnSegments 참조
        selectedFloor: 'F1',     // 현재 선택된 층 (F1~F10, RF 레거시 형식)
        selectedJeolju: null,    // 선택된 절주 필터 (null = 전체)
        elevationViewOpen: true, // 입면 뷰어 표시 여부
        floorSelectorOpen: false, // 층 선택기 드롭다운 열림 상태
        lastFloorLoad: null, // 마지막 층 데이터 로드 정보
        isLoading: false, // 데이터 로딩 중 상태
        loadingMessage: '', // 로딩 메시지
        grid: [], // 그리드 데이터 (rows × cols)

        // Phase 7: 층별 통계 (computed)
        get currentFloorLabel() {
            const floor = this.floors.find(f => f.floorId === this.selectedFloor);
            return floor ? floor.label : '1층';
        },

        // Phase 7: 절주별 진행률 (computed)
        get jeoljuProgress() {
            const progress = {};
            this.jeoljuList.forEach(j => {
                const cols = Object.values(this.columns).filter(c => {
                    const colNum = parseInt(c.location.column);
                    return colNum >= j.startColumn && colNum <= j.endColumn;
                });
                const total = cols.length || 1;
                const installed = cols.filter(c => c.status.code === 'installed').length;
                progress[j.jeoljuId] = Math.round((installed / total) * 100);
            });
            return progress;
        },

        // Phase 7: 실시간 알림 시스템
        activeNotifications: [],      // 현재 화면에 표시 중인 알림 (최대 3개)
        notificationHistory: [],      // 알림 히스토리 (최대 50개)
        notificationPanelOpen: false, // 히스토리 패널 열림 상태
        notificationIdCounter: 0,     // 알림 ID 생성용 카운터

        // Phase 7: 모바일 네비게이션
        mobileNavTab: 'grid',  // 'grid' | 'issues' | 'notifications' | 'menu'
        sidebarOpen: false,    // 모바일 사이드바 열림 상태

        // Mobile Bottom Navigation (Enhanced)
        mobileView: 'grid',
        isMobile: window.innerWidth < 768,

        // Phase 7: 스마트 검색
        searchQuery: '',           // 검색어
        searchDropdownOpen: false, // 검색 드롭다운 표시 여부
        searchResults: [],         // 검색 결과
        recentSearches: [],        // 최근 검색어 (최대 5개)
        activeFilters: [],         // 활성 필터 [{type, value, label}]
        _searchTimeout: null,      // WP-5: 검색 debounce 타이머

        // Phase 7: 대시보드 요약 패널
        summaryPanelOpen: false,   // 요약 패널 열림 상태
        todayChanges: [],          // 오늘 변경 내역

        // Phase 7: 히스토리 뷰어
        historyPanelOpen: false,   // 히스토리 패널 열림 상태
        historyFilter: 'all',      // 'all' | 'status' | 'stage' | 'issue'
        historyData: [],           // 전체 히스토리 데이터

        // Phase 7: 키보드 단축키 모달
        shortcutsModalOpen: false, // 단축키 도움말 모달 열림 상태

        // Phase 11: Slack Integration State
        slackSettings: {
            webhookUrl: '',              // 새로 입력할 Webhook URL
            webhookConfigured: false,    // 서버에 Webhook이 설정되어 있는지
            webhookUrlMasked: '',        // 마스킹된 현재 Webhook URL
            showWebhookUrl: false,       // URL 표시/숨기기 토글
            notifications: {
                criticalIssue: true,     // Critical 이슈 생성 시
                statusDelay: true,       // delay 상태 변경 시
                statusBlocked: true,     // blocked/hold 상태 변경 시
                bulkUpdate: true,        // 대량 업데이트 (10개 이상) 시
                dailySummary: false,     // 일일 요약 (트리거 필요)
                issueResolved: false     // 이슈 해결 시
            },
            saving: false,               // 저장 중 상태
            testing: false,              // 테스트 전송 중 상태
            message: '',                 // 상태 메시지
            messageType: ''              // 'success' | 'error'
        },

        // Phase 12: Email Integration State
        emailSettings: {
            recipients: [],              // 수신자 이메일 목록
            newRecipient: '',            // 새로 추가할 이메일
            notifications: {
                criticalIssue: true,     // Critical 이슈 생성 시
                statusDelay: true,       // delay 상태 변경 시
                statusBlocked: true,     // blocked/hold 상태 변경 시
                bulkUpdate: true,        // 대량 업데이트 (10개 이상) 시
                weeklySummary: false,    // 주간 요약 (트리거 필요)
                issueResolved: false     // 이슈 해결 시
            },
            saving: false,               // 저장 중 상태
            testing: false,              // 테스트 전송 중 상태
            message: '',                 // 상태 메시지
            messageType: ''              // 'success' | 'error'
        },

        // Phase 7: 필터링된 히스토리 (computed)
        get filteredHistory() {
            if (this.historyFilter === 'all') {
                return this.historyData;
            }
            return this.historyData.filter(item => item.type === this.historyFilter);
        },

        // Phase 7: 날짜별 그룹핑된 히스토리 (computed)
        get groupedHistory() {
            const groups = {};
            for (const item of this.filteredHistory) {
                const date = new Date(item.timestamp).toLocaleDateString('ko-KR');
                if (!groups[date]) {
                    groups[date] = {
                        date,
                        dateLabel: this.formatDateLabel(item.timestamp),
                        items: []
                    };
                }
                groups[date].items.push(item);
            }
            return Object.values(groups).sort((a, b) => 
                new Date(b.items[0]?.timestamp) - new Date(a.items[0]?.timestamp)
            );
        },

        // Phase 7: 읽지 않은 알림 개수 (computed)
        get unreadNotificationCount() {
            return this.notificationHistory.filter(n => !n.read).length;
        },

        // Phase 7: 검색 결과 개수 (computed)
        get searchResultCount() {
            return this.searchResults.length;
        },

        // Sync Status (computed-like via getter)
        get syncStatus() {
            if (typeof SyncModule !== 'undefined' && this.syncEnabled) {
                return SyncModule.getQueueStatus();
            }
            return { pending: 0, failed: 0, total: 0, isSyncing: false, lastSync: null };
        },
        
        // Computed
        get totalColumns() {
            return this.gridConfig.cols * this.gridConfig.rows;
        },
        
        // Issue Computed Properties
        get openIssues() {
            return this.issues.filter(i => i.status === 'open' || i.status === 'in_progress');
        },
        
        get filteredIssues() {
            if (this.issueFilter === 'all') return this.issues;
            if (this.issueFilter === 'open') return this.issues.filter(i => i.status === 'open' || i.status === 'in_progress');
            if (this.issueFilter === 'resolved') return this.issues.filter(i => i.status === 'resolved');
            return this.issues;
        },
        
        get activeIssueOverlays() {
            return this.openIssues.filter(i => i.overlay?.show !== false);
        },
        
        // WP-2: Issue Pin Helper Methods (Optimized with O(1) Map lookup)
        
        /**
         * Build issue index map for O(1) cell lookup
         * Call this when issues array changes
         */
        buildIssueIndex() {
            const map = new Map();
            
            for (const issue of this.openIssues) {
                if (!issue.startColumn || !issue.endColumn) continue;
                
                const startRow = this.rowLabels.indexOf(issue.startRow);
                const endRow = this.rowLabels.indexOf(issue.endRow);
                if (startRow < 0 || endRow < 0) continue;
                
                // Populate map with all affected cell UIDs
                for (let r = startRow; r <= endRow; r++) {
                    const rowLabel = this.rowLabels[r];
                    if (!rowLabel) continue;
                    
                    for (let c = issue.startColumn; c <= issue.endColumn; c++) {
                        const uid = `${rowLabel}-X${c}`;
                        if (!map.has(uid)) {
                            map.set(uid, []);
                        }
                        map.get(uid).push(issue);
                    }
                }
            }
            
            this.issueIndexMap = map;
            this.invalidateSeverityCache();  // WP-5 Phase 2: Clear memoization cache
            console.log(`[Performance] Issue index built: ${map.size} cells indexed`);
        },
        
        /**
         * Check if a cell has any open issues - O(1)
         */
        hasIssue(cell) {
            if (!cell || cell.isHeader) return false;
            if (!this.issueIndexMap) this.buildIssueIndex();
            const uid = `${cell.row}-X${cell.col}`;
            return this.issueIndexMap.has(uid);
        },
        
        /**
         * Check if cell is within issue's affected range (legacy fallback)
         */
        isCellInIssueRange(cell, issue) {
            if (!issue.startColumn || !issue.endColumn) return false;
            
            const colNum = cell.col;
            const rowIdx = this.rowLabels.indexOf(cell.row);
            const issueStartRow = this.rowLabels.indexOf(issue.startRow);
            const issueEndRow = this.rowLabels.indexOf(issue.endRow);
            
            return colNum >= issue.startColumn && 
                   colNum <= issue.endColumn &&
                   rowIdx >= issueStartRow && 
                   rowIdx <= issueEndRow;
        },
        
        /**
         * Get the first issue affecting a cell - O(1)
         */
        getIssueForCell(cell) {
            if (!cell || cell.isHeader) return null;
            if (!this.issueIndexMap) this.buildIssueIndex();
            const uid = `${cell.row}-X${cell.col}`;
            const issues = this.issueIndexMap.get(uid);
            return issues ? issues[0] : null;
        },
        
        /**
         * Get all issues affecting a cell - O(1)
         */
        getIssuesForCell(cell) {
            if (!cell || cell.isHeader) return [];
            if (!this.issueIndexMap) this.buildIssueIndex();
            const uid = `${cell.row}-X${cell.col}`;
            return this.issueIndexMap.get(uid) || [];
        },
        
        // WP-5 Phase 2: Static severity class mapping (avoid object creation per call)
        _SEVERITY_CLASSES: {
            'critical': 'issue-pin-critical',
            'high': 'issue-pin-high',
            'medium': 'issue-pin-medium',
            'low': 'issue-pin-low'
        },

        /**
         * Get CSS class based on issue severity
         * WP-5 Phase 2: Uses memoization cache for O(1) repeated lookups
         */
        getIssueSeverityClass(cell) {
            if (!cell || cell.isHeader) return '';

            const cacheKey = `${cell.row}-X${cell.col}`;

            // Check cache first
            if (this._severityClassCache && this._severityClassCache.has(cacheKey)) {
                return this._severityClassCache.get(cacheKey);
            }

            // Compute and cache
            const issue = this.getIssueForCell(cell);
            const className = issue
                ? (this._SEVERITY_CLASSES[issue.severity] || 'issue-pin-medium')
                : '';

            // Initialize cache if needed
            if (!this._severityClassCache) {
                this._severityClassCache = new Map();
            }
            this._severityClassCache.set(cacheKey, className);

            return className;
        },

        /**
         * WP-5 Phase 2: Invalidate severity class cache
         * Call this when issues change
         */
        invalidateSeverityCache() {
            this._severityClassCache = null;
        },
        
        /**
         * Get issue title for tooltip
         */
        getIssueTitle(cell) {
            const issues = this.getIssuesForCell(cell);
            if (issues.length === 0) return '';
            if (issues.length === 1) return issues[0].title;
            return `${issues.length}개 이슈: ${issues.map(i => i.title).join(', ')}`;
        },

        /**
         * WP-2: Open issue detail panel when clicking issue pin
         */
        openIssueDetail(cell) {
            const issues = this.getIssuesForCell(cell);
            if (issues.length === 0) return;

            // Open issue panel
            this.issuePanelOpen = true;

            // Set active issue to the first one (most recent or highest severity)
            const sortedIssues = issues.sort((a, b) => {
                const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
                return (severityOrder[a.severity] || 3) - (severityOrder[b.severity] || 3);
            });

            this.selectedIssue = sortedIssues[0];

            // Scroll to the issue in the panel (after DOM update)
            this.$nextTick(() => {
                const issueCard = document.querySelector(`[data-issue-id="${sortedIssues[0].id}"]`);
                if (issueCard) {
                    issueCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    issueCard.classList.add('active');
                }
            });

            // Show toast with issue count
            if (issues.length > 1) {
                this.showToast(`${issues.length}개 이슈 발견 - 가장 심각한 이슈 표시 중`, 'warning');
            }

            this.announce(`이슈 패널 열림: ${sortedIssues[0].title}`);
        },

        // Generate flat grid cells array for Alpine.js compatibility
        get gridCells() {
            const cells = [];
            
            // First row: corner + X-axis headers (1-69)
            cells.push({ key: 'corner', isHeader: true, label: '' });
            for (let c = 1; c <= this.gridConfig.cols; c++) {
                cells.push({ key: 'h-' + c, isHeader: true, label: c });
            }
            
            // Data rows
            for (let r = 0; r < this.gridConfig.rows; r++) {
                const rowLabel = this.rowLabels[r];
                // Y-axis header
                cells.push({ key: 'r-' + rowLabel, isHeader: true, label: rowLabel });
                // Data cells
                for (let c = 1; c <= this.gridConfig.cols; c++) {
                    cells.push({
                        key: rowLabel + '-X' + c,
                        isHeader: false,
                        row: rowLabel,
                        col: c
                    });
                }
            }
            
            return cells;
        },

        // === Virtual Scrolling ===

        // Get total grid dimensions in pixels
        get totalGridWidth() {
            const vs = this.virtualScroll;
            return vs.headerWidth + (this.gridConfig.cols * vs.cellWidth);
        },

        get totalGridHeight() {
            const vs = this.virtualScroll;
            return vs.headerHeight + (this.gridConfig.rows * vs.cellHeight);
        },

        // Calculate visible range based on scroll position
        updateVisibleRange() {
            const vs = this.virtualScroll;

            // Calculate visible column range
            const colStart = Math.max(0, Math.floor((vs.scrollLeft - vs.headerWidth) / vs.cellWidth) - vs.bufferCells);
            const colEnd = Math.min(this.gridConfig.cols, Math.ceil((vs.scrollLeft + vs.viewportWidth - vs.headerWidth) / vs.cellWidth) + vs.bufferCells);

            // Calculate visible row range
            const rowStart = Math.max(0, Math.floor((vs.scrollTop - vs.headerHeight) / vs.cellHeight) - vs.bufferCells);
            const rowEnd = Math.min(this.gridConfig.rows, Math.ceil((vs.scrollTop + vs.viewportHeight - vs.headerHeight) / vs.cellHeight) + vs.bufferCells);

            vs.visibleColStart = colStart;
            vs.visibleColEnd = colEnd;
            vs.visibleRowStart = rowStart;
            vs.visibleRowEnd = rowEnd;
        },

        // Generate only visible cells for rendering
        get visibleCells() {
            if (!this.virtualScroll.enabled) {
                return this.gridCells;
            }

            const vs = this.virtualScroll;
            const cells = [];

            // Always include corner cell
            cells.push({ key: 'corner', isHeader: true, label: '', isCorner: true });

            // Visible column headers
            for (let c = vs.visibleColStart + 1; c <= Math.min(vs.visibleColEnd + 1, this.gridConfig.cols); c++) {
                cells.push({
                    key: 'h-' + c,
                    isHeader: true,
                    label: c,
                    isColumnHeader: true,
                    colIndex: c
                });
            }

            // Visible data rows
            for (let r = vs.visibleRowStart; r < Math.min(vs.visibleRowEnd, this.gridConfig.rows); r++) {
                const rowLabel = this.rowLabels[r] || String.fromCharCode(65 + r);

                // Row header
                cells.push({
                    key: 'r-' + rowLabel,
                    isHeader: true,
                    label: rowLabel,
                    isRowHeader: true,
                    rowIndex: r
                });

                // Visible data cells in this row
                for (let c = vs.visibleColStart + 1; c <= Math.min(vs.visibleColEnd + 1, this.gridConfig.cols); c++) {
                    cells.push({
                        key: rowLabel + '-X' + c,
                        isHeader: false,
                        row: rowLabel,
                        col: c,
                        rowIndex: r,
                        colIndex: c
                    });
                }
            }

            return cells;
        },

        // Get visible columns count for grid CSS
        get visibleColCount() {
            const vs = this.virtualScroll;
            return Math.min(vs.visibleColEnd + 1, this.gridConfig.cols) - vs.visibleColStart;
        },

        // Get visible rows count for grid CSS
        get visibleRowCount() {
            const vs = this.virtualScroll;
            return Math.min(vs.visibleRowEnd, this.gridConfig.rows) - vs.visibleRowStart;
        },

        // Handle scroll event with throttling (WP-5 Phase 2: Optimized RAF)
        handleVirtualScroll(event) {
            const vs = this.virtualScroll;
            const container = event.target;

            // Batch read operations first (avoid layout thrashing)
            vs.scrollLeft = container.scrollLeft;
            vs.scrollTop = container.scrollTop;
            vs.isScrolling = true;

            // Cancel previous scroll hide timeout
            if (vs._scrollHideTimeout) {
                clearTimeout(vs._scrollHideTimeout);
                vs._scrollHideTimeout = null;
            }

            // Throttled update using RAF coalescing
            if (!vs.scrollTimeout) {
                vs.scrollTimeout = requestAnimationFrame(() => {
                    this.updateVisibleRange();
                    vs.scrollTimeout = null;
                });
            }

            // Debounced scroll indicator hide (separate from RAF)
            vs._scrollHideTimeout = setTimeout(() => {
                vs.isScrolling = false;
                vs._scrollHideTimeout = null;
            }, 500);
        },

        // Initialize virtual scrolling
        initVirtualScroll(container) {
            if (!container) return;

            const vs = this.virtualScroll;
            vs.viewportWidth = container.clientWidth;
            vs.viewportHeight = container.clientHeight;

            // Auto-enable for large grids (>1000 cells)
            const totalCells = this.gridConfig.cols * this.gridConfig.rows;
            vs.enabled = totalCells > 1000;

            this.updateVisibleRange();

            // Add resize observer with debounce (WP-5 Performance)
            const resizeObserver = new ResizeObserver(entries => {
                // Clear previous debounce timer
                if (vs._resizeTimeout) {
                    clearTimeout(vs._resizeTimeout);
                }

                // Debounce resize updates to avoid excessive recalculations
                vs._resizeTimeout = setTimeout(() => {
                    for (const entry of entries) {
                        vs.viewportWidth = entry.contentRect.width;
                        vs.viewportHeight = entry.contentRect.height;
                    }
                    this.updateVisibleRange();
                }, 100);
            });
            resizeObserver.observe(container);

            console.log(`[VirtualScroll] Initialized: ${totalCells} cells, enabled=${vs.enabled}`);
        },

        // Get cell position for absolute positioning (virtual mode)
        getCellStyle(cell) {
            if (!this.virtualScroll.enabled || cell.isHeader) return '';

            const vs = this.virtualScroll;
            const left = vs.headerWidth + ((cell.colIndex - 1) * vs.cellWidth);
            const top = vs.headerHeight + (cell.rowIndex * vs.cellHeight);

            return `position: absolute; left: ${left}px; top: ${top}px; width: ${vs.cellWidth - 2}px; height: ${vs.cellHeight - 2}px;`;
        },

        // Get scroll position info for indicator
        get scrollPositionInfo() {
            const vs = this.virtualScroll;
            const colPercent = Math.round((vs.scrollLeft / (this.totalGridWidth - vs.viewportWidth)) * 100) || 0;
            const rowPercent = Math.round((vs.scrollTop / (this.totalGridHeight - vs.viewportHeight)) * 100) || 0;
            return `Col ${vs.visibleColStart + 1}-${vs.visibleColEnd + 1} / ${this.gridConfig.cols} | Row ${vs.visibleRowStart + 1}-${vs.visibleRowEnd} / ${this.gridConfig.rows}`;
        },

        // === Phase 12-1: Context Intelligence (Smart Paste) ===

        /**
         * SmartPaste Parsing Engine
         * 정규식 기반으로 카톡/메일 텍스트에서 기둥 ID와 상태를 추출
         */
        smartPaste: {
            patterns: {
                // 기둥 ID 패턴: C-X1, CX1, C1, A-X15, ZONE-A-X1 등
                columnId: /([A-C])-?[Xx]?(\d{1,3})/gi,
                // 범위 패턴: X1~5, X1-5, X10~15, A-X1~X5, 1번~5번 등
                columnRange: /([A-C])-?[Xx]?(\d{1,3})\s*[~\-~－까지]\s*[Xx]?(\d{1,3})/gi,
                // 층수 패턴: 1층, 3F, RF, 10FL
                floor: /(RF|\d{1,2})\s*(층|[Ff][Ll]?|[Ff]loor)?/gi,
                // 상태 키워드
                statusKeywords: {
                    installed: ['완료', '끝', 'done', 'complete', '타설', '설치'],
                    hold_design: ['보류', 'hold', '중단', '대기', '설계변경'],
                    hold_material: ['자재', 'material', '입고지연'],
                    active: ['진행', 'active', '시작', 'start', '착수']
                },
                // 이슈 키워드
                issueKeywords: ['문제', 'issue', '지연', 'delay', '오류', '간섭', 'T/C', '안전']
            },

            parse(text) {
                const result = {
                    columns: [],
                    floor: null,
                    status: null,
                    hasIssue: false,
                    rawText: text,
                    confidence: 0
                };

                const addedIds = new Set(); // 중복 방지

                // 1-A. 범위 패턴 먼저 추출 (X1~5, X10-15 등)
                const rangeMatches = text.matchAll(this.patterns.columnRange);
                for (const match of rangeMatches) {
                    const zone = match[1].toUpperCase();
                    const startNum = parseInt(match[2], 10);
                    const endNum = parseInt(match[3], 10);

                    // 범위 확장 (startNum ~ endNum)
                    const [min, max] = startNum <= endNum ? [startNum, endNum] : [endNum, startNum];
                    for (let num = min; num <= max && num <= 330; num++) {
                        const id = `${zone}-X${num}`;
                        if (!addedIds.has(id) && num > 0) {
                            result.columns.push({ zone, num, id });
                            addedIds.add(id);
                        }
                    }
                }

                // 1-B. 개별 기둥 ID 추출 (범위에 포함되지 않은 것들)
                const columnMatches = text.matchAll(this.patterns.columnId);
                for (const match of columnMatches) {
                    const zone = match[1].toUpperCase();
                    const num = parseInt(match[2], 10);
                    const id = `${zone}-X${num}`;
                    if (num > 0 && num <= 330 && !addedIds.has(id)) {
                        result.columns.push({ zone, num, id });
                        addedIds.add(id);
                    }
                }

                // 2. 층수 추출
                const floorMatch = text.match(this.patterns.floor);
                if (floorMatch) {
                    result.floor = floorMatch[1].toUpperCase() === 'RF' ? 'RF' : parseInt(floorMatch[1], 10);
                }

                // 3. 상태 키워드 매칭
                for (const [status, keywords] of Object.entries(this.patterns.statusKeywords)) {
                    for (const keyword of keywords) {
                        if (text.toLowerCase().includes(keyword.toLowerCase())) {
                            result.status = status;
                            break;
                        }
                    }
                    if (result.status) break;
                }

                // 4. 이슈 키워드 체크
                result.hasIssue = this.patterns.issueKeywords.some(kw =>
                    text.toLowerCase().includes(kw.toLowerCase())
                );

                // 5. 신뢰도 계산
                if (result.columns.length > 0) result.confidence += 40;
                if (result.status) result.confidence += 30;
                if (result.floor) result.confidence += 20;
                if (text.length > 10) result.confidence += 10;

                return result;
            }
        },

        /**
         * Context Intelligence: 텍스트 분석 실행
         * Phase 12-3: AI NLP 모드 지원
         */
        analyzeContext() {
            if (!this.contextInput.trim()) {
                this.showToast('분석할 텍스트를 입력해주세요', 'warning');
                return;
            }

            this.contextProcessing = true;
            this.contextSuggestions = [];
            this.highlightedColumns = [];

            // Phase 12-3: AI NLP 모드 분기
            if (this.useAiNlp) {
                this.analyzeContextWithAI();
            } else {
                this.analyzeContextWithRegex();
            }
        },

        /**
         * Phase 12-1: 정규식 기반 파싱 (기본 모드)
         */
        analyzeContextWithRegex() {
            const parsed = this.smartPaste.parse(this.contextInput);

            setTimeout(() => {
                if (parsed.columns.length === 0) {
                    this.showToast('인식된 기둥 ID가 없습니다. 예: C-X1, A-X15', 'warning');
                    this.contextProcessing = false;
                    return;
                }

                const suggestion = {
                    id: Date.now(),
                    type: parsed.hasIssue ? 'issue_create' : 'status_change',
                    columns: parsed.columns,
                    floor: parsed.floor,
                    newStatus: parsed.status || 'installed',
                    hasIssue: parsed.hasIssue,
                    confidence: parsed.confidence,
                    sourceText: this.contextInput.substring(0, 200),
                    timestamp: new Date().toISOString()
                };

                this.contextSuggestions = [suggestion];
                this.highlightedColumns = parsed.columns.map(c => c.id);
                this.contextProcessing = false;
                this.showToast(`${parsed.columns.length}개 기둥 인식됨 (신뢰도: ${parsed.confidence}%)`, 'success');
            }, 300);
        },

        /**
         * Phase 12-3: AI NLP 기반 분석 (Gemini API)
         */
        async analyzeContextWithAI() {
            try {
                // API 엔드포인트 호출
                const apiUrl = this.sheetSync?.apiUrl;
                if (!apiUrl) {
                    // API 없으면 Regex fallback
                    this.showToast('API 연결 없음. 패턴 분석으로 전환합니다.', 'warning');
                    this.analyzeContextWithRegex();
                    return;
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'analyzeContextNLP',
                        text: this.contextInput,
                        context: {
                            previousColumns: this.nlpPreviousColumns
                        }
                    })
                });

                const result = await response.json();

                if (!result.success) {
                    // API 실패 시 Regex fallback
                    if (result.fallback) {
                        this.showToast('AI 분석 불가. 패턴 분석으로 전환합니다.', 'warning');
                        this.analyzeContextWithRegex();
                        return;
                    }
                    throw new Error(result.error || 'AI 분석 실패');
                }

                // AI 결과 처리
                const columns = result.columns || [];

                if (columns.length === 0 && result.ambiguousRefs?.length > 0) {
                    // 모호한 표현만 있는 경우
                    this.showToast(`모호한 표현 감지: ${result.ambiguousRefs.join(', ')}. 더 구체적으로 입력해주세요.`, 'warning');
                    this.contextProcessing = false;
                    return;
                }

                if (columns.length === 0) {
                    this.showToast('AI가 기둥 정보를 찾지 못했습니다.', 'warning');
                    this.contextProcessing = false;
                    return;
                }

                // AI 컨텍스트 기억 (다음 분석에 활용)
                this.nlpPreviousColumns = columns.map(c => c.id);

                // 제안 생성
                const suggestion = {
                    id: Date.now(),
                    type: result.intent === 'issue_create' ? 'issue_create' : 'status_change',
                    columns: columns,
                    floor: result.analysis?.floor,
                    newStatus: result.suggestedStatus || 'installed',
                    hasIssue: result.intent === 'issue_create',
                    confidence: result.statusConfidence || 70,
                    sourceText: this.contextInput.substring(0, 200),
                    timestamp: new Date().toISOString(),
                    aiSummary: result.summary,
                    ambiguousRefs: result.ambiguousRefs
                };

                this.contextSuggestions = [suggestion];
                this.highlightedColumns = columns.map(c => c.id);
                this.contextProcessing = false;

                // AI 요약 표시
                if (result.summary) {
                    this.showToast(`🤖 ${result.summary}`, 'success');
                } else {
                    this.showToast(`🤖 ${columns.length}개 기둥 인식됨 (AI 신뢰도: ${result.statusConfidence || 70}%)`, 'success');
                }

            } catch (error) {
                console.error('[NLP] Analysis error:', error);
                this.showToast('AI 분석 오류. 패턴 분석으로 전환합니다.', 'warning');
                this.analyzeContextWithRegex();
            }
        },

        /**
         * 제안 승인: 상태 변경 실행
         */
        approveContextSuggestion(suggestion) {
            const updatedColumns = [];

            // Phase 12-2: 컨텍스트를 저장소에 저장하고 ID 생성
            const contextId = this.saveContextToStore(suggestion);

            for (const col of suggestion.columns) {
                // 기둥 UID 찾기 (예: A-X1, B-X10, 3F-C-X1)
                const colId = col.id || `${col.zone}-X${col.num}`;
                const columnKeys = Object.keys(this.columns).filter(key =>
                    key === colId ||                                    // 정확히 일치
                    key.endsWith(`-${colId}`) ||                         // 층 prefix 포함 (예: 3F-A-X1)
                    key === `${col.zone}-X${col.num}`                    // Zone-X# 형식
                );

                for (const key of columnKeys) {
                    if (this.columns[key]) {
                        const oldStatus = this.columns[key].status;
                        this.columns[key].status = suggestion.newStatus;
                        this.columns[key].updatedAt = new Date().toISOString();

                        // 히스토리 추가 (출처 연결 - Phase 12-2 강화)
                        if (!this.columns[key].history) {
                            this.columns[key].history = [];
                        }
                        this.columns[key].history.push({
                            timestamp: new Date().toISOString(),
                            action: 'status_change',
                            from: oldStatus,
                            to: suggestion.newStatus,
                            reason: 'Context Intelligence',
                            sourceId: contextId,                    // 컨텍스트 ID 연결
                            sourceSnippet: suggestion.sourceText.substring(0, 100)
                        });

                        updatedColumns.push(key);
                    }
                }
            }

            // 저장
            this.saveToLocalStorage();

            // Phase 12-2: 글로벌 히스토리에도 추가 (View Source 버튼 연동)
            if (updatedColumns.length > 0) {
                const historyEntry = {
                    id: `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'status',
                    timestamp: new Date().toISOString(),
                    description: `${updatedColumns.length}개 기둥 상태 변경 → ${this.getStatusLabel(suggestion.newStatus)}`,
                    targetId: updatedColumns.join(', '),
                    affectedColumns: updatedColumns,
                    affectedCount: updatedColumns.length,
                    user: 'Context Intelligence',
                    sourceId: contextId,  // 컨텍스트 출처 연결
                    data: {
                        action: 'status_change',
                        newStatus: suggestion.newStatus,
                        source: 'Smart Paste'
                    }
                };
                this.historyData.unshift(historyEntry);

                // 최대 500개 유지
                if (this.historyData.length > 500) {
                    this.historyData = this.historyData.slice(0, 500);
                }

                // LocalStorage에 저장
                try {
                    localStorage.setItem('p5_history', JSON.stringify(this.historyData.slice(0, 100)));
                } catch (e) {
                    console.warn('[History] Failed to save to localStorage:', e);
                }
            }

            // 제안 제거
            this.contextSuggestions = this.contextSuggestions.filter(s => s.id !== suggestion.id);

            // 하이라이트 해제 (2초 후)
            setTimeout(() => {
                this.highlightedColumns = [];
            }, 2000);

            // 입력 초기화
            this.contextInput = '';

            this.showToast(`${updatedColumns.length}개 기둥 상태가 '${this.getStatusLabel(suggestion.newStatus)}'로 변경되었습니다`, 'success');
        },

        /**
         * 제안 거절
         */
        rejectContextSuggestion(suggestion) {
            this.contextSuggestions = this.contextSuggestions.filter(s => s.id !== suggestion.id);
            this.highlightedColumns = [];
            this.showToast('제안이 취소되었습니다', 'info');
        },

        // === Phase 12-2: Context Storage System ===

        /**
         * 컨텍스트를 저장소에 저장
         * @param {Object} suggestion - 승인된 제안 객체
         * @returns {string} 생성된 컨텍스트 ID
         */
        saveContextToStore(suggestion) {
            const contextId = `ctx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            const contextRecord = {
                id: contextId,
                timestamp: new Date().toISOString(),
                type: suggestion.type,
                rawText: suggestion.sourceText,
                parsedData: {
                    columns: suggestion.columns.map(c => c.id || c),
                    floor: suggestion.floor,
                    status: suggestion.newStatus,
                    confidence: suggestion.confidence
                },
                affectedColumns: suggestion.columns.map(c => c.id || c),
                appliedAction: suggestion.type === 'status_change'
                    ? `상태 변경: ${this.getStatusLabel(suggestion.newStatus)}`
                    : '이슈 생성',
                metadata: {
                    source: 'Smart Paste',
                    approvedAt: new Date().toISOString()
                }
            };

            // 저장소에 추가 (최대 100개 유지)
            this.contextStore.unshift(contextRecord);
            if (this.contextStore.length > 100) {
                this.contextStore = this.contextStore.slice(0, 100);
            }

            // LocalStorage에 저장
            this.saveContextStore();

            console.log('[Context Store] Saved:', contextId);
            return contextId;
        },

        /**
         * 컨텍스트 ID로 조회
         * @param {string} contextId - 컨텍스트 ID
         * @returns {Object|null} 컨텍스트 레코드
         */
        getContextById(contextId) {
            return this.contextStore.find(ctx => ctx.id === contextId) || null;
        },

        /**
         * 컨텍스트 소스 팝업 열기
         * @param {string} contextId - 컨텍스트 ID
         */
        openContextSource(contextId) {
            const context = this.getContextById(contextId);
            if (context) {
                this.contextSourceModal.context = context;
                this.contextSourceModal.open = true;
            } else {
                this.showToast('원본 컨텍스트를 찾을 수 없습니다', 'warning');
            }
        },

        /**
         * 컨텍스트 소스 팝업 닫기
         */
        closeContextSource() {
            this.contextSourceModal.open = false;
            this.contextSourceModal.context = null;
        },

        /**
         * 컨텍스트 저장소 LocalStorage 저장
         */
        saveContextStore() {
            try {
                localStorage.setItem('p5_context_store', JSON.stringify(this.contextStore));
            } catch (e) {
                console.warn('[Context Store] Save failed:', e);
            }
        },

        /**
         * 컨텍스트 저장소 LocalStorage 로드
         */
        loadContextStore() {
            try {
                const stored = localStorage.getItem('p5_context_store');
                if (stored) {
                    this.contextStore = JSON.parse(stored);
                    console.log('[Context Store] Loaded:', this.contextStore.length, 'records');
                }
            } catch (e) {
                console.warn('[Context Store] Load failed:', e);
                this.contextStore = [];
            }
        },

        /**
         * Phase 12-2: 히스토리 데이터 LocalStorage 로드
         */
        loadHistoryData() {
            try {
                const stored = localStorage.getItem('p5_history');
                if (stored) {
                    this.historyData = JSON.parse(stored);
                    console.log('[History] Loaded:', this.historyData.length, 'records');
                }
            } catch (e) {
                console.warn('[History] Load failed:', e);
                this.historyData = [];
            }
        },

        /**
         * 기둥이 하이라이트되어야 하는지 확인
         */
        isColumnHighlighted(columnId) {
            return this.highlightedColumns.some(id => columnId.includes(id));
        },

        /**
         * 상태 코드의 한글 레이블 반환
         */
        getStatusLabel(statusCode) {
            const labels = {
                pending: '대기',
                active: '진행중',
                installed: '설치완료',
                hold_design: '설계 변경',
                hold_material: '자재 대기',
                hold_tc: 'T/C Hold',
                hold_safety: '안전 점검'
            };
            return labels[statusCode] || statusCode;
        },

        // === Lifecycle ===
        init() {
            const data = P5Store.load();

            // WP-9-1: Initialize Global Error Handler with showToast integration
            if (typeof ErrorHandler !== 'undefined') {
                const self = this;
                ErrorHandler.init((message, type) => {
                    self.showToast(message, type);
                });
                console.log('[WP-9-1] ErrorHandler initialized with toast integration');
            }

            // Phase 12-2: Load Context Store from LocalStorage
            this.loadContextStore();

            // Phase 12-2: Load History Data from LocalStorage
            this.loadHistoryData();

            // ★ Floor Plan Fix: MGT_CONFIG zones 적용 (P5 복합동 실제 규격)
            // LocalStorage에 저장된 테스트 데이터(1-69열)가 아닌 
            // COLUMN_CONFIG(3-329열, 327 cols)을 적용
            if (typeof MGT_CONFIG !== 'undefined' && MGT_CONFIG && MGT_CONFIG.zones) {
                // MGT_CONFIG zones를 Alpine.js 형식으로 변환
                this.zones = MGT_CONFIG.zones.map(zone => {
                    const color = zone.id === 'zone_a' ? '#238636' :
                                  zone.id === 'zone_b' ? '#1f6feb' : '#d29922';
                    return {
                        id: zone.id,
                        name: zone.name,
                        displayName: zone.name,
                        description: '',
                        // Direct properties for backward compatibility
                        startColumn: zone.startCol,
                        endColumn: zone.endCol,
                        startRow: 0,
                        endRow: this.rowLabels.length - 1,
                        color: color,
                        // Nested range for P5Store format
                        range: {
                            startColumn: zone.startCol,
                            endColumn: zone.endCol,
                            startRow: 0,
                            endRow: this.rowLabels.length - 1
                        },
                        // Nested style for P5Store format
                        style: {
                            primaryColor: color,
                            backgroundColor: color + '1a',
                            progressPercent: 0
                        },
                        contractor: '', supervisor: '', targetDate: '',
                        metadata: { createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), createdBy: 'system' }
                    };
                });
                console.log('[FloorPlan Fix] Applied COLUMN_CONFIG zones:', this.zones.length, 'zones');
            } else {
                // Normalize zones from P5Store to ensure consistent structure
                this.zones = (data.zones || []).map(zone => {
                    const color = zone.color || zone.style?.primaryColor || '#238636';
                    return {
                        ...zone,
                        // Ensure direct properties exist
                        startColumn: zone.startColumn ?? zone.range?.startColumn ?? 1,
                        endColumn: zone.endColumn ?? zone.range?.endColumn ?? 10,
                        startRow: zone.startRow ?? zone.range?.startRow ?? 0,
                        endRow: zone.endRow ?? zone.range?.endRow ?? 11,
                        color: color,
                        // Ensure nested range exists
                        range: zone.range || {
                            startColumn: zone.startColumn ?? 1,
                            endColumn: zone.endColumn ?? 10,
                            startRow: zone.startRow ?? 0,
                            endRow: zone.endRow ?? 11
                        },
                        // Ensure nested style exists
                        style: zone.style || {
                            primaryColor: color,
                            backgroundColor: color + '1a',
                            progressPercent: 0
                        }
                    };
                });
            }
            
            this.columns = data.columns || {};
            this.statusCodes = data.statusCodes;

            // H-4 Fix: stageConfigs를 P5Store에서 로드 (master_config.json과 동기화)
            if (data.productionStages) {
                this.stageConfigs = data.productionStages.map(stage => ({
                    code: stage.code,
                    label: stage.label,
                    color: stage.color,
                    order: stage.order
                }));
            }

            // Phase 7: 층-절주 데이터 초기화
            this.initFloorJeoljuData();

            // Initialize columns if empty
            if (Object.keys(this.columns).length === 0) {
                this.initializeColumns();
            }

            // ★ PSRC 제작현황 데이터 로드 (production_status_import.js)
            this.loadProductionStatusData();

            // Initialize sample issues for demo
            this.initSampleIssues();

            // Phase 7: 글로벌 키보드 단축키 등록
            this.registerKeyboardShortcuts();

            // Mobile resize listener
            window.addEventListener('resize', () => {
                this.isMobile = window.innerWidth < 768;
            });

            // Log grid configuration
            const totalCells = this.gridConfig.cols * this.gridConfig.rows;
            console.log(`[Dashboard] Grid: ${this.gridConfig.cols}x${this.gridConfig.rows} = ${totalCells.toLocaleString()} cells`);
            console.log(`[Dashboard] Virtual Scrolling: ${this.virtualScroll.enabled ? 'ENABLED' : 'disabled'} (threshold: 1,000 cells)`);
            console.log(`[Dashboard] Columns loaded: ${Object.keys(this.columns).length.toLocaleString()}`);
            console.log(`[Dashboard] Issues: ${this.issues.length}`);

            if (totalCells > 1000) {
                console.log(`[Dashboard] ⚡ Large grid detected - Virtual Scrolling active for performance`);
            }
        },

        // Phase 7: 층-절주 데이터 초기화
        // ⚠️ 중요: "절주" = 수직 분절 (층 그룹), "열 구간" = 수평 분절 (컬럼 범위)
        initFloorJeoljuData() {
            // 기본 층 데이터 (11개 층) - 레거시 ID 형식 (F1, F2, ...)
            this.floors = [
                { floorId: 'base', label: '1층(기초)', order: 1, level: 0.3, hasVariation: false },
                { floorId: '2F', label: '2층', order: 2, level: 7.8, hasVariation: false },
                { floorId: '3F', label: '3층', order: 3, level: 14.3, hasVariation: false },
                { floorId: '4F', label: '4층', order: 4, level: 21.3, hasVariation: false },
                { floorId: '5F', label: '5층', order: 5, level: 28.3, hasVariation: true, variationNote: '부분 차이' },
                { floorId: 'RF', label: 'Roof', order: 6, level: 99.4, hasVariation: true, variationNote: '지붕층' }
            ];

            // ★ 절주 (수직 분절 - 층 그룹) - floor_jeolju_implementation_plan.md 기준
            // 절주 = 기둥 수직분절 계획에 따른 층 그룹 (8개 절주)
            this.jeoljuConfig = [
                { jeoljuId: '1절주', label: '1절주', floors: ['2F', '3F'], heightRange: '7.8m ~ 14.3m', length: 6.5, columnSize: 'PSRC/HMB', description: '1절주 (2~3F) 제작 현황' },
                { jeoljuId: '2절주', label: '2절주', floors: ['4F', '5F'], heightRange: '21.3m~', length: 7.0, columnSize: '1600x1600', description: '2절주 제작 현황' }
            ];

            // ★ 열 구간 (수평 분절 - 컬럼 범위) - 기존 jeoljuList를 명칭 변경
            // 그리드 뷰어에서 컬럼 범위별 필터링/하이라이트 용도
            // jeoljuId 포함: 하위 호환성 (템플릿에서 jeolju.jeoljuId 사용)
            this.columnSegments = [
                { segmentId: 'S1', jeoljuId: 'S1', label: '1구간', startColumn: 1, endColumn: 9, columnCount: 9, priority: 1 },
                { segmentId: 'S2', jeoljuId: 'S2', label: '2구간', startColumn: 10, endColumn: 18, columnCount: 9, priority: 2 },
                { segmentId: 'S3', jeoljuId: 'S3', label: '3구간', startColumn: 19, endColumn: 27, columnCount: 9, priority: 3 },
                { segmentId: 'S4', jeoljuId: 'S4', label: '4구간', startColumn: 28, endColumn: 36, columnCount: 9, priority: 4 },
                { segmentId: 'S5', jeoljuId: 'S5', label: '5구간', startColumn: 37, endColumn: 45, columnCount: 9, priority: 5 },
                { segmentId: 'S6', jeoljuId: 'S6', label: '6구간', startColumn: 46, endColumn: 54, columnCount: 9, priority: 6 },
                { segmentId: 'S7', jeoljuId: 'S7', label: '7구간', startColumn: 55, endColumn: 62, columnCount: 8, priority: 7 },
                { segmentId: 'S8', jeoljuId: 'S8', label: '8구간', startColumn: 63, endColumn: 69, columnCount: 7, priority: 8 }
            ];

            // 하위 호환성: jeoljuList를 columnSegments로 매핑 (기존 코드 호환)
            this.jeoljuList = this.columnSegments;

            console.log('[Phase 7] Floor-Jeolju data initialized:', this.floors.length, 'floors,', this.jeoljuConfig.length, 'jeolju(수직),', this.columnSegments.length, 'segments(수평)');
            
            // 층별 통계 초기화 (API 호출 전 기본값)
            this.floorStats = {};
            this.floors.forEach(f => {
                this.floorStats[f.floorId] = { progress: 0, columnCount: 0, issueCount: 0 };
            });
            
            // API에서 실제 통계 로드 (비동기)
            if (this.syncEnabled && this.apiUrl) {
                this.loadAllFloorStats();
            }
        },

        // Phase 9: 전체 층 통계 로드 (입면 뷰어용)
        async loadAllFloorStats() {
            try {
                const apiUrl = this.apiUrl || this.apiBase;
                if (!apiUrl) return;

                const response = await fetch(`${apiUrl}?action=getFloorStats`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const result = await response.json();
                if (result.success && result.floors) {
                    this.floorStats = result.floors;
                    console.log('[Phase 9] Floor stats loaded:', Object.keys(this.floorStats).length, 'floors');
                }
            } catch (error) {
                console.warn('[Phase 9] Floor stats load failed (using defaults):', error.message);
            }
        },

        // ★ PSRC 제작현황 데이터 로드 (production_status_import.js에서 가져온 데이터 적용)
        loadProductionStatusData() {
            // production_status_import.js가 로드되었는지 확인
            if (typeof PRODUCTION_STATUS_1JEOL === 'undefined' || typeof PRODUCTION_STATUS_2JEOL === 'undefined') {
                console.warn('[Production] production_status_import.js not loaded');
                return;
            }

            let updated = 0;
            
            // 헬퍼 함수: 데이터 세트 처리
            const processDataSet = (dataSet, floorId) => {
                for (const uid in dataSet) {
                    // UID가 이미 존재하면 stages 업데이트
                    if (this.columns[uid]) {
                        this.columns[uid].stages = { ...dataSet[uid] };
                        this.columns[uid].location.floorId = floorId; // 층 정보 업데이트
                        updated++;
                    } else {
                        // 새 기둥 생성 (UID 형식: "A-X36")
                        const [row, colPart] = uid.split('-');
                        const col = parseInt(colPart.replace('X', ''));
                        
                        // Zone 결정
                        let zoneId = 'zone_c';
                        if (col <= 25) zoneId = 'zone_a';
                        else if (col <= 47) zoneId = 'zone_b';

                        this.columns[uid] = {
                            uid,
                            location: {
                                row: this.rowLabels.indexOf(row),
                                column: col,
                                zoneId,
                                floorId: floorId, // 올바른 층 ID 할당 (F1 or F2)
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            status: {
                                code: 'active',
                                source: 'production_import',
                                isLocked: false,
                                updatedAt: new Date().toISOString()
                            },
                            stages: { ...dataSet[uid] }
                        };
                        updated++;
                    }
                }
            };

            // 1절주 (F1) 처리
            processDataSet(PRODUCTION_STATUS_1JEOL, 'F1');
            
            // 2절주 (F2) 처리
            processDataSet(PRODUCTION_STATUS_2JEOL, 'F2');

            console.log(`[Production] ${updated} columns loaded from production_status_import.js`);
            console.log(`[Production] 1절주(F1): ${Object.keys(PRODUCTION_STATUS_1JEOL).length}개, 2절주(F2): ${Object.keys(PRODUCTION_STATUS_2JEOL).length}개`);
            
            // 통계 계산
            if (typeof getProductionStats === 'function') {
                const stats = getProductionStats();
                console.log('[Production] Stats:', stats);
            }

            // 데이터 저장
            this.saveToLocalStorage();
        },

        // Phase 7: 층 선택
        selectFloor(floorId) {
            const previousFloor = this.selectedFloor;
            this.selectedFloor = floorId;
            this.floorSelectorOpen = false;
            console.log('[Phase 7] Floor selected:', floorId);

            // 층 변경 시 API에서 해당 층 데이터 로드
            if (previousFloor !== floorId) {
                this.loadFloorData(floorId);
            }
        },

        // Phase 7: 층별 데이터 로드 (실제 API 연결)
        async loadFloorData(floorId) {
            console.log('[Phase 7] Loading floor data:', floorId);
            this.showLoading(`${floorId} 층 데이터 로딩 중...`);

            try {
                // 로딩 알림
                this.addNotification({
                    id: 'floor-loading-' + Date.now(),
                    type: 'info',
                    title: '층 데이터 로딩',
                    message: `${floorId} 층 데이터를 불러오는 중...`,
                    timestamp: new Date().toISOString(),
                    autoDismiss: true,
                    dismissAfter: 2000
                });

                // API 호출 (getFloorData endpoint)
                const apiUrl = this.apiUrl || this.apiBase;
                if (!apiUrl) {
                    throw new Error('API URL not configured');
                }

                const response = await fetch(`${apiUrl}?action=getFloorData&floorId=${floorId}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[Phase 7] Floor data loaded:', {
                        floor: result.floor,
                        columnCount: result.columnCount,
                        issueCount: result.issueCount
                    });

                    // 1. 기둥 데이터 업데이트 (해당 층 데이터로 교체)
                    if (result.columns) {
                        // 기존 columns를 해당 층 데이터로 업데이트
                        this.columns = result.columns;
                        console.log(`[Phase 7] Columns updated: ${Object.keys(this.columns).length} columns`);
                    }

                    // 2. 절주별 통계 업데이트
                    if (result.stats?.byJeolju) {
                        this.jeoljuList = this.jeoljuList.map(j => {
                            const stats = result.stats.byJeolju[j.jeoljuId];
                            if (stats) {
                                return {
                                    ...j,
                                    issueCount: stats.hold || 0,
                                    total: stats.total || 0,
                                    pending: stats.pending || 0,
                                    active: stats.active || 0,
                                    installed: stats.installed || 0
                                };
                            }
                            return j;
                        });
                    }

                    // 3. 이슈 데이터 업데이트 (해당 층 관련 이슈만)
                    if (result.issues) {
                        this.issues = result.issues;
                        console.log(`[Phase 7] Issues updated: ${this.issues.length} issues`);
                    }

                    // 4. 그리드 데이터 재생성
                    this.updateGridData();

                    // 성공 알림
                    this.addNotification({
                        id: 'floor-loaded-' + Date.now(),
                        type: 'success',
                        title: '층 데이터 로드 완료',
                        message: `${result.floor?.label || floorId}: ${result.columnCount || 0}개 기둥, ${result.issueCount || 0}개 이슈`,
                        timestamp: new Date().toISOString(),
                        autoDismiss: true,
                        dismissAfter: 3000
                    });

                    // 마지막 로드 시간 기록
                    this.lastFloorLoad = {
                        floorId,
                        timestamp: result.timestamp,
                        columnCount: result.columnCount
                    };

                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.warn('[Phase 7] Floor data load error (using local data):', error.message);

                // 에러 알림 (심각하지 않음 - 로컬 데이터로 계속 작동)
                this.addNotification({
                    id: 'floor-error-' + Date.now(),
                    type: 'warning',
                    title: '층 데이터 로드 실패',
                    message: `${floorId}: ${error.message}. 로컬 데이터 사용 중.`,
                    timestamp: new Date().toISOString(),
                    autoDismiss: true,
                    dismissAfter: 5000
                });
            } finally {
                this.hideLoading();
            }
        },

        // Phase 7+: 그리드 데이터 업데이트 (columns → grid 변환)
        updateGridData() {
            // grid 데이터 재생성 (rows × cols 구조)
            const rowLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'];

            this.grid = rowLabels.map((rowLabel, rowIndex) => {
                const cells = [];
                for (let col = 1; col <= 69; col++) {
                    // UID 형식: "A-X1" 또는 "F01-A-X1"
                    const simpleUid = `${rowLabel}-X${col}`;
                    const floorUid = `${this.selectedFloor}-${rowLabel}-X${col}`;

                    // 두 가지 UID 형식 모두 확인
                    const column = this.columns[floorUid] || this.columns[simpleUid];

                    cells.push({
                        row: rowIndex,
                        col: col,
                        uid: column?.uid || simpleUid,
                        status: column?.status?.code || 'pending',
                        stages: column?.stages || {},
                        issueId: column?.issueId || null,
                        isLocked: column?.status?.isLocked || false
                    });
                }
                return { label: rowLabel, cells };
            });

            console.log('[Phase 7+] Grid data updated:', this.grid.length, 'rows');
        },

        // Phase 9: 입면 뷰어 셀 클래스 결정
        getElevationCellClass(floorId, jeoljuId) {
            const classes = [];
            
            // 현재 선택된 층/절주이면 selected
            if (this.selectedFloor === floorId && this.selectedJeolju === jeoljuId) {
                classes.push('selected');
            }
            
            // 진행률 기반 클래스
            const progress = this.getFloorJeoljuProgress(floorId, jeoljuId);
            if (progress >= 100) {
                classes.push('complete');
            } else if (progress > 0) {
                classes.push('in-progress');
            }
            
            // 이슈 여부 (해당 층-절주에 이슈가 있으면)
            const hasIssue = this.issues.some(issue => 
                issue.status === 'open' && 
                issue.affectedColumns?.some(uid => {
                    const jeolju = this.getJeoljuForColumn(parseInt(uid.split('-X')[1]) || 1);
                    return jeolju?.jeoljuId === jeoljuId;
                })
            );
            if (hasIssue) {
                classes.push('has-issue');
            }
            
            return classes.join(' ');
        },

        // Phase 9: 층-절주 동시 선택
        selectFloorAndJeolju(floorId, jeoljuId) {
            const previousFloor = this.selectedFloor; // 변경 전 층 저장
            
            // 토글 로직: 이미 선택된 셀이면 절주만 해제
            if (this.selectedFloor === floorId && this.selectedJeolju === jeoljuId) {
                this.selectedJeolju = null;
            } else {
                this.selectedFloor = floorId;
                this.selectedJeolju = jeoljuId;
            }
            
            // 층이 변경되었으면 데이터 로드
            if (previousFloor !== floorId) {
                this.loadFloorData(floorId);
            }
            
            const floorLabel = this.floors.find(f => f.floorId === floorId)?.label || floorId;
            const jeoljuLabel = this.jeoljuList.find(j => j.jeoljuId === jeoljuId)?.label || jeoljuId;
            this.showToast(`${floorLabel} / ${jeoljuLabel} 선택됨`, 'info');
        },

        // Phase 9: 층-절주 조합의 진행률 계산 (0-100)
        getFloorJeoljuProgress(floorId, jeoljuId) {
            // 현재 층이 선택된 층이면 실제 데이터 기반 계산
            if (this.selectedFloor === floorId && this.columns) {
                const jeolju = this.jeoljuList.find(j => j.jeoljuId === jeoljuId);
                if (!jeolju) return 0;
                
                let total = 0, installed = 0;
                
                Object.values(this.columns).forEach(col => {
                    const colNum = parseInt(col.location?.column) || 0;
                    if (colNum >= jeolju.startColumn && colNum <= jeolju.endColumn) {
                        total++;
                        if (col.status?.code === 'installed') {
                            installed++;
                        }
                    }
                });
                
                return total > 0 ? Math.round((installed / total) * 100) : 0;
            }
            
            // API에서 로드한 층별 통계 사용
            if (this.floorStats && this.floorStats[floorId]) {
                return this.floorStats[floorId].progress || 0;
            }
            
            // 통계 없으면 0 반환
            return 0;
        },

        // Phase 9: 절주 필터
        filterByJeolju(jeoljuId) {
            if (this.selectedJeolju === jeoljuId) {
                this.selectedJeolju = null; // 토글 해제
                this.showToast('절주 필터 해제', 'info');
            } else {
                this.selectedJeolju = jeoljuId;
                const jeolju = this.jeoljuList.find(j => j.jeoljuId === jeoljuId);
                this.showToast(`${jeolju?.label || jeoljuId} 필터 적용`, 'info');
            }
        },

        // Phase 9: 컬럼 번호로 절주 찾기
        getJeoljuForColumn(colNum) {
            return this.jeoljuList.find(j => colNum >= j.startColumn && colNum <= j.endColumn);
        },

        // Phase 7: 층 이동 (방향: -1 = 상위, +1 = 하위)
        navigateFloor(direction) {
            if (!this.floors || this.floors.length === 0) return;

            const currentIndex = this.floors.findIndex(f => f.floorId === this.selectedFloor);
            if (currentIndex === -1) return;

            const newIndex = Math.max(0, Math.min(this.floors.length - 1, currentIndex + direction));
            if (newIndex !== currentIndex) {
                this.selectFloor(this.floors[newIndex].floorId);
                this.showToast(`${this.floors[newIndex].label} 선택됨`, 'info');
            }
        },

        // Phase 7: 절주 필터 순환
        cycleJeoljuFilter() {
            if (!this.jeoljuList || this.jeoljuList.length === 0) return;

            if (!this.selectedJeolju) {
                // 필터 없음 → 첫 번째 절주
                this.selectedJeolju = this.jeoljuList[0].jeoljuId;
            } else {
                const currentIndex = this.jeoljuList.findIndex(j => j.jeoljuId === this.selectedJeolju);
                if (currentIndex === this.jeoljuList.length - 1) {
                    // 마지막 → 필터 해제
                    this.selectedJeolju = null;
                    this.showToast('절주 필터 해제', 'info');
                    return;
                } else {
                    // 다음 절주
                    this.selectedJeolju = this.jeoljuList[currentIndex + 1].jeoljuId;
                }
            }

            const jeolju = this.jeoljuList.find(j => j.jeoljuId === this.selectedJeolju);
            if (jeolju) {
                this.showToast(`${jeolju.label} 필터 적용`, 'info');
            }
        },

        // Phase 7: 해당 기둥이 선택된 절주에 속하는지 확인
        isInSelectedJeolju(columnNumber) {
            if (!this.selectedJeolju) return true;
            const jeolju = this.jeoljuList.find(j => j.jeoljuId === this.selectedJeolju);
            if (!jeolju) return true;
            return columnNumber >= jeolju.startColumn && columnNumber <= jeolju.endColumn;
        },

        // Phase 7: 절주별 이슈 수 계산
        getJeoljuIssueCount(jeoljuId) {
            if (!jeoljuId) return 0;
            const jeolju = this.jeoljuList.find(j => j.jeoljuId === jeoljuId);
            if (!jeolju) return 0;

            return this.issues.filter(issue => {
                if (issue.status === 'resolved') return false;
                // affectedColumns에서 절주 범위 내 기둥 확인
                const affected = issue.affectedColumns || [];
                return affected.some(uid => {
                    const match = uid.match(/X(\d+)/);
                    if (!match) return false;
                    const colNum = parseInt(match[1]);
                    return colNum >= jeolju.startColumn && colNum <= jeolju.endColumn;
                });
            }).length;
        },

        // Phase 7: 절주별 진행률 계산 (%)
        getJeoljuProgressPercent(jeoljuId) {
            if (!jeoljuId) return 0;
            const jeolju = this.jeoljuList.find(j => j.jeoljuId === jeoljuId);
            if (!jeolju) return 0;

            let total = 0;
            let completed = 0;

            Object.values(this.columns).forEach(col => {
                const colNum = col.location?.column;
                if (colNum >= jeolju.startColumn && colNum <= jeolju.endColumn) {
                    total++;
                    // installed 상태를 완료로 간주
                    const lastStage = col.stages?.embed || col.stages?.form;
                    if (lastStage === 'installed') {
                        completed++;
                    } else if (col.status?.code === 'installed') {
                        completed++;
                    }
                }
            });

            return total > 0 ? Math.round((completed / total) * 100) : 0;
        },

        // Phase 7: 선택된 절주 라벨 반환
        getSelectedJeoljuLabel() {
            if (!this.selectedJeolju) return '';
            const jeolju = this.jeoljuList.find(j => j.jeoljuId === this.selectedJeolju);
            return jeolju ? `${jeolju.label} (X${jeolju.startColumn}~X${jeolju.endColumn})` : '';
        },

        // Phase 7: 절주별 기둥 수 계산
        getJeoljuColumnCount(jeoljuId) {
            if (!jeoljuId) return 0;
            const jeolju = this.jeoljuList.find(j => j.jeoljuId === jeoljuId);
            if (!jeolju) return 0;

            let count = 0;
            Object.values(this.columns).forEach(col => {
                const colNum = col.location?.column;
                if (colNum >= jeolju.startColumn && colNum <= jeolju.endColumn) {
                    count++;
                }
            });
            return count;
        },

        initializeColumns() {
            for (let r = 0; r < this.gridConfig.rows; r++) {
                for (let c = 1; c <= this.gridConfig.cols; c++) {
                    const uid = `${this.rowLabels[r]}-X${c}`;
                    const zone = this.getZoneForColumn(c);

                    this.columns[uid] = {
                        uid,
                        location: {
                            row: this.rowLabels[r],
                            rowIndex: r,
                            column: c,
                            zoneId: zone?.id || null
                        },
                        status: {
                            code: 'pending',
                            source: 'system',
                            isLocked: false,
                            updatedAt: new Date().toISOString()
                        },
                        member: {
                            type: 'SRC Column',
                            section: 'H-500x500',
                            material: 'SM490'
                        },
                        // Phase 6: 6단계 공정 상태
                        stages: {
                            hmb_fab: 'pending',
                            pre_assem: 'pending',
                            main_assem: 'pending',
                            hmb_psrc: 'pending',
                            form: 'pending',
                            embed: 'pending'
                        }
                    };
                }
            }
        },
        
        // === Zone Helpers ===
        getZoneForColumn(col) {
            return this.zones.find(z => col >= z.range.startColumn && col <= z.range.endColumn);
        },
        
        getZoneName(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            return zone ? `${zone.name} (${zone.displayName})` : '-';
        },
        
        getZoneProgress(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            if (!zone) return 0;
            
            let total = 0, installed = 0;
            for (const uid in this.columns) {
                const col = this.columns[uid];
                if (col.location.zoneId === zoneId) {
                    total++;
                    if (col.status.code === 'installed') installed++;
                }
            }
            return total > 0 ? Math.round((installed / total) * 100) : 0;
        },
        
        // === Admin Panel Functions ===
        getZoneProgress(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            if (!zone) return 0;
            
            let total = 0, installed = 0;
            for (const uid in this.columns) {
                const col = this.columns[uid];
                if (col?.location?.zoneId === zoneId && col?.status) {
                    total++;
                    if (col.status.code === 'installed') installed++;
                }
            }
            return total > 0 ? Math.round((installed / total) * 100) : 0;
        },

        openZoneEditor(zone) {
            if (zone) {
                // 편집 모드
                this.editingZone = zone;
                this.zoneForm = {
                    id: zone.id,
                    name: zone.name,
                    displayName: zone.displayName,
                    description: zone.description || '',
                    startColumn: zone.range?.startColumn || zone.startColumn || 1,
                    endColumn: zone.range?.endColumn || zone.endColumn || 10,
                    startRow: zone.range?.startRow || 0,
                    endRow: zone.range?.endRow || 11,
                    color: zone.style?.primaryColor || zone.color || '#238636',
                    contractor: zone.contractor || '',
                    supervisor: zone.supervisor || '',
                    targetDate: zone.targetDate || ''
                };
            } else {
                // 새 Zone 추가 모드
                this.editingZone = null;
                this.zoneForm = {
                    id: '', name: '', displayName: '', description: '',
                    startColumn: 1, endColumn: 10, startRow: 0, endRow: 11,
                    color: '#238636', contractor: '', supervisor: '', targetDate: ''
                };
            }
            this.showZoneEditor = true;
        },

        saveZone() {
            // 유효성 검사
            if (!this.zoneForm.id || !this.zoneForm.name) {
                this.showToast('Zone ID와 이름을 입력해주세요', 'error');
                this.announceError('오류: Zone ID와 이름을 입력해주세요');
                return;
            }
            if (this.zoneForm.startColumn > this.zoneForm.endColumn) {
                this.showToast('시작 컬럼이 끝 컬럼보다 클 수 없습니다', 'error');
                this.announceError('오류: 시작 컬럼이 끝 컬럼보다 클 수 없습니다');
                return;
            }

            const now = new Date().toISOString().slice(0, 10);

            if (this.editingZone) {
                // 기존 Zone 수정
                const idx = this.zones.findIndex(z => z.id === this.editingZone.id);
                if (idx >= 0) {
                    this.zones[idx] = {
                        ...this.zones[idx],
                        name: this.zoneForm.name,
                        displayName: this.zoneForm.displayName,
                        description: this.zoneForm.description,
                        range: {
                            startColumn: this.zoneForm.startColumn,
                            endColumn: this.zoneForm.endColumn,
                            startRow: this.zoneForm.startRow || 0,
                            endRow: this.zoneForm.endRow || 11
                        },
                        style: {
                            ...this.zones[idx].style,
                            primaryColor: this.zoneForm.color,
                            backgroundColor: this.zoneForm.color + '20'
                        },
                        contractor: this.zoneForm.contractor,
                        supervisor: this.zoneForm.supervisor,
                        targetDate: this.zoneForm.targetDate,
                        metadata: {
                            ...this.zones[idx].metadata,
                            updatedAt: now
                        }
                    };
                    this.showToast('Zone이 수정되었습니다', 'success');
                }
            } else {
                // 새 Zone 추가
                const newZone = {
                    id: this.zoneForm.id,
                    name: this.zoneForm.name,
                    displayName: this.zoneForm.displayName,
                    description: this.zoneForm.description,
                    range: {
                        startColumn: this.zoneForm.startColumn,
                        endColumn: this.zoneForm.endColumn,
                        startRow: this.zoneForm.startRow || 0,
                        endRow: this.zoneForm.endRow || 11
                    },
                    style: {
                        primaryColor: this.zoneForm.color,
                        backgroundColor: this.zoneForm.color + '20',
                        progressPercent: 0
                    },
                    contractor: this.zoneForm.contractor,
                    supervisor: this.zoneForm.supervisor,
                    targetDate: this.zoneForm.targetDate,
                    metadata: {
                        createdAt: now,
                        updatedAt: now,
                        createdBy: 'admin'
                    }
                };
                this.zones.push(newZone);
                this.showToast('새 Zone이 추가되었습니다', 'success');
            }

            this.isDirty = true;
            this.showZoneEditor = false;
            this.saveToLocalStorage(); // 자동 저장
        },

        deleteZone(zoneId) {
            if (confirm('정말 이 Zone을 삭제하시겠습니까?')) {
                this.zones = this.zones.filter(z => z.id !== zoneId);
                this.showToast('Zone이 삭제되었습니다', 'success');
                this.isDirty = true;
                this.saveToLocalStorage(); // 자동 저장
            }
        },

        openNewIssueModal() {
            this.issueForm = { 
                type: 'tc', title: '', description: '', severity: 'medium', 
                startColumn: 1, endColumn: 10, startRow: 'A', endRow: 'L',
                assignedTo: '', expectedResolution: '',
                showOverlay: true, overlayLabel: '', overlayColor: '#da3633'
            };
            this.showIssueEditor = true;
        },

        get filteredIssues() {
            if (this.issueFilter === 'all') return this.issues;
            return this.issues.filter(i => i.status === this.issueFilter);
        },

        // === Shop Issue Module Functions ===

        /**
         * Shop Issue 필터링 및 정렬
         * @returns {Array} 필터링/정렬된 Shop Issue 목록
         */
        getFilteredShopIssues() {
            let filtered = [...this.shopIssues];

            // 필터 적용
            if (this.shopIssueFilter === 'unresolved') {
                filtered = filtered.filter(i => i.status !== 'O');
            } else if (this.shopIssueFilter === 'resolved') {
                filtered = filtered.filter(i => i.status === 'O');
            }

            // 정렬 적용
            if (this.shopIssueSortBy === 'type') {
                filtered.sort((a, b) => (a.type || '').localeCompare(b.type || ''));
            } else if (this.shopIssueSortBy === 'location') {
                filtered.sort((a, b) => (a.location || '').localeCompare(b.location || ''));
            } else if (this.shopIssueSortBy === 'id') {
                filtered.sort((a, b) => {
                    const numA = parseInt((a.id || '0').replace(/\D/g, '')) || 0;
                    const numB = parseInt((b.id || '0').replace(/\D/g, '')) || 0;
                    return numA - numB;
                });
            }

            return filtered;
        },

        /**
         * Shop Issue 파일 업로드 처리 (CSV + Excel 지원)
         * Phase 15: Excel 회의록 파서 통합
         * @param {Event} event - 파일 입력 이벤트
         */
        async handleShopIssueFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();

            try {
                let result;

                // Phase 15: Excel 파일 지원
                if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                    this.showToast('Excel 파일 분석 중...', 'info');
                    result = await this.parseMeetingMinutesExcel(file);
                } else if (fileName.endsWith('.csv')) {
                    const text = await file.text();
                    result = this.parseShopIssueCSV(text);
                } else {
                    this.showToast('지원하지 않는 파일 형식입니다 (CSV, XLSX 지원)', 'error');
                    return;
                }

                if (result.success) {
                    this.shopIssues = result.issues;
                    this.shopIssueStats = result.stats;
                    // 기둥 ID 연결 정보가 있으면 저장
                    if (result.columnLinks) {
                        this.issueColumnLinks = result.columnLinks;
                    }
                    const sourceType = fileName.endsWith('.xlsx') || fileName.endsWith('.xls') ? 'Excel' : 'CSV';
                    const sheetInfo = result.sheetsProcessed ? ` (${result.sheetsProcessed}개 시트)` : '';
                    this.showToast(`${sourceType}에서 이슈 ${result.issues.length}건 로드 완료${sheetInfo}`, 'success');
                } else {
                    this.showToast('파일 파싱 실패: ' + result.error, 'error');
                }
            } catch (err) {
                console.error('[ShopIssue] File upload error:', err);
                this.showToast('파일 읽기 실패: ' + err.message, 'error');
            }

            // 파일 입력 초기화 (동일 파일 재선택 허용)
            event.target.value = '';
        },

        /**
         * Shop Issue CSV 파싱
         * @param {string} csvData - CSV 문자열
         * @returns {Object} 파싱 결과 { success, issues, stats, error }
         */
        parseShopIssueCSV(csvData) {
            try {
                const lines = csvData.split(/\r?\n/).filter(line => line.trim());
                if (lines.length < 2) {
                    return { success: false, error: 'CSV 데이터가 비어있습니다', issues: [], stats: {} };
                }

                // 헤더 파싱 (첫 번째 행)
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

                // 필수 컬럼 인덱스 찾기 (유연한 매핑)
                const idxMap = {
                    id: headers.findIndex(h => h.includes('no') || h.includes('id') || h === '#'),
                    type: headers.findIndex(h => h.includes('type') || h.includes('유형') || h.includes('분류')),
                    title: headers.findIndex(h => h.includes('title') || h.includes('제목') || h.includes('내용') || h.includes('description')),
                    location: headers.findIndex(h => h.includes('location') || h.includes('위치') || h.includes('zone') || h.includes('구역')),
                    status: headers.findIndex(h => h.includes('status') || h.includes('상태') || h.includes('반영'))
                };

                const issues = [];
                const stats = {
                    total: 0,
                    resolved: 0,
                    unresolved: 0,
                    byType: {},
                    byLocation: {}
                };

                // 데이터 행 파싱
                for (let i = 1; i < lines.length; i++) {
                    const values = this.parseCSVLine(lines[i]);
                    if (values.length < 2) continue; // 빈 행 스킵

                    const issue = {
                        id: idxMap.id >= 0 ? values[idxMap.id]?.trim() : `SI-${i}`,
                        type: idxMap.type >= 0 ? values[idxMap.type]?.trim() : '',
                        title: idxMap.title >= 0 ? values[idxMap.title]?.trim() : values[1]?.trim() || '',
                        description: idxMap.title >= 0 ? values[idxMap.title]?.trim() : '',
                        location: idxMap.location >= 0 ? values[idxMap.location]?.trim() : '',
                        status: idxMap.status >= 0 ? values[idxMap.status]?.trim().toUpperCase() : ''
                    };

                    // ID가 없으면 자동 생성
                    if (!issue.id) issue.id = `SI-${i}`;

                    issues.push(issue);
                    stats.total++;

                    // 상태별 집계
                    if (issue.status === 'O') {
                        stats.resolved++;
                    } else {
                        stats.unresolved++;
                    }

                    // 유형별 집계
                    const type = issue.type || 'Unknown';
                    if (!stats.byType[type]) {
                        stats.byType[type] = { total: 0, resolved: 0 };
                    }
                    stats.byType[type].total++;
                    if (issue.status === 'O') {
                        stats.byType[type].resolved++;
                    }

                    // 위치별 집계
                    const location = issue.location || 'Unknown';
                    if (!stats.byLocation[location]) {
                        stats.byLocation[location] = { total: 0, resolved: 0 };
                    }
                    stats.byLocation[location].total++;
                    if (issue.status === 'O') {
                        stats.byLocation[location].resolved++;
                    }
                }

                console.log('[ShopIssue] Parsed:', stats);
                return { success: true, issues, stats };

            } catch (err) {
                console.error('[ShopIssue] Parse error:', err);
                return { success: false, error: err.message, issues: [], stats: {} };
            }
        },

        /**
         * CSV 라인 파싱 (따옴표 처리 포함)
         * @param {string} line - CSV 라인
         * @returns {Array} 파싱된 값 배열
         */
        parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);

            return result;
        },

        /**
         * Phase 15: Excel 회의록 파서
         * 다중 시트 순회하여 이슈 추출, 기둥 ID 자동 연결
         * @param {File} file - Excel 파일
         * @returns {Object} { success, issues, stats, columnLinks, sheetsProcessed, error }
         */
        async parseMeetingMinutesExcel(file) {
            try {
                // SheetJS 라이브러리 로드
                const loaded = await this.loadExportLibs();
                if (!loaded || typeof XLSX === 'undefined') {
                    return { success: false, error: 'Excel 라이브러리 로드 실패', issues: [], stats: {} };
                }

                // 파일 읽기
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array', cellDates: true });

                const issues = [];
                const columnLinks = [];
                const stats = {
                    total: 0,
                    resolved: 0,
                    unresolved: 0,
                    byType: {},
                    byLocation: {},
                    bySheet: {}
                };

                let issueIdCounter = 1;
                const sheetsProcessed = workbook.SheetNames.length;

                console.log(`[Phase15] Processing ${sheetsProcessed} sheets from Excel`);

                // 모든 시트 순회
                for (const sheetName of workbook.SheetNames) {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                        header: 1,
                        defval: '',
                        raw: false
                    });

                    if (jsonData.length < 2) continue;

                    // 헤더 행 찾기
                    let headerRowIdx = this.findMeetingIssueHeader(jsonData);
                    if (headerRowIdx < 0) headerRowIdx = 0;

                    const headers = jsonData[headerRowIdx];
                    const idxMap = this.mapMeetingExcelHeaders(headers);

                    // 데이터 행 파싱
                    for (let i = headerRowIdx + 1; i < jsonData.length; i++) {
                        const row = jsonData[i];
                        if (!row || row.length < 2) continue;

                        const issueData = this.extractMeetingIssue(row, idxMap, sheetName, issueIdCounter);
                        if (!issueData) continue;

                        // 기둥 ID 추출
                        const linkedColumns = this.extractColumnIdsFromIssue(issueData.title + ' ' + issueData.description);
                        if (linkedColumns.length > 0) {
                            issueData.linkedColumns = linkedColumns;
                            columnLinks.push({ issueId: issueData.id, columns: linkedColumns });
                        }

                        issues.push(issueData);
                        issueIdCounter++;
                        stats.total++;

                        // 통계 업데이트
                        const isResolved = issueData.status === 'O' || issueData.status === '완료';
                        if (isResolved) stats.resolved++;
                        else stats.unresolved++;

                        // 유형별/위치별/시트별 집계
                        const type = issueData.type || 'Unknown';
                        if (!stats.byType[type]) stats.byType[type] = { total: 0, resolved: 0 };
                        stats.byType[type].total++;
                        if (isResolved) stats.byType[type].resolved++;

                        const location = issueData.location || 'Unknown';
                        if (!stats.byLocation[location]) stats.byLocation[location] = { total: 0, resolved: 0 };
                        stats.byLocation[location].total++;
                        if (isResolved) stats.byLocation[location].resolved++;

                        if (!stats.bySheet[sheetName]) stats.bySheet[sheetName] = { total: 0, resolved: 0 };
                        stats.bySheet[sheetName].total++;
                        if (isResolved) stats.bySheet[sheetName].resolved++;
                    }
                }

                console.log(`[Phase15] Parsed ${issues.length} issues from ${sheetsProcessed} sheets, ${columnLinks.length} column links`);
                return { success: true, issues, stats, columnLinks, sheetsProcessed };

            } catch (err) {
                console.error('[Phase15] Excel parse error:', err);
                return { success: false, error: err.message, issues: [], stats: {} };
            }
        },

        /**
         * 회의록 이슈 테이블 헤더 찾기
         */
        findMeetingIssueHeader(jsonData) {
            const keywords = ['발송일자', '발송', '분류', '내용', '반영', '구분', '번호'];
            for (let i = 0; i < Math.min(jsonData.length, 50); i++) {
                const row = jsonData[i];
                if (!row) continue;
                const rowText = row.join(' ').toLowerCase();
                const matchCount = keywords.filter(kw => rowText.includes(kw.toLowerCase())).length;
                if (matchCount >= 3) return i;
            }
            return -1;
        },

        /**
         * Excel 헤더 컬럼 매핑
         */
        mapMeetingExcelHeaders(headers) {
            const h = headers.map(x => (x || '').toString().toLowerCase().trim());
            return {
                id: h.findIndex(x => x.includes('번호') || x.includes('no') || x.includes('id')),
                type: h.findIndex(x => x.includes('분류') || x.includes('유형') || x.includes('구분')),
                title: h.findIndex(x => x.includes('내용') || x.includes('제목') || x.includes('이슈')),
                location: h.findIndex(x => x.includes('위치') || x.includes('절주') || x.includes('zone')),
                status: h.findIndex(x => x.includes('반영') || x.includes('상태') || x.includes('완료')),
                date: h.findIndex(x => x.includes('일자') || x.includes('날짜') || x.includes('발송')),
                assignee: h.findIndex(x => x.includes('담당') || x.includes('처리') || x.includes('발송처'))
            };
        },

        /**
         * 행 데이터에서 이슈 추출
         */
        extractMeetingIssue(row, idxMap, sheetName, counter) {
            const titleIdx = idxMap.title >= 0 ? idxMap.title : 1;
            const title = (row[titleIdx] || '').toString().trim();
            if (!title || title.length < 3) return null;
            if (title.includes('내용') && title.length < 10) return null;

            return {
                id: idxMap.id >= 0 && row[idxMap.id] ? `${sheetName}-${row[idxMap.id]}` : `MI-${counter}`,
                type: idxMap.type >= 0 ? (row[idxMap.type] || '').toString().trim() : '',
                title: title.substring(0, 200),
                description: title,
                location: idxMap.location >= 0 ? (row[idxMap.location] || '').toString().trim() : '',
                status: idxMap.status >= 0 ? (row[idxMap.status] || '').toString().trim().toUpperCase() : '',
                date: idxMap.date >= 0 ? (row[idxMap.date] || '').toString().trim() : '',
                assignee: idxMap.assignee >= 0 ? (row[idxMap.assignee] || '').toString().trim() : '',
                sourceSheet: sheetName,
                linkedColumns: []
            };
        },

        /**
         * Phase 15: 이슈와 연결된 기둥 하이라이트
         * @param {Object} issue - 선택된 Shop Issue
         */
        highlightIssueColumns(issue) {
            if (!issue.linkedColumns || issue.linkedColumns.length === 0) {
                this.showToast('연결된 기둥이 없습니다', 'info');
                return;
            }

            // 기존 하이라이트 제거
            this.highlightedColumns = [];

            // 연결된 기둥들 하이라이트
            this.highlightedColumns = [...issue.linkedColumns];

            // Shop Issue 패널 닫고 그리드 보여주기
            this.showShopIssuePanel = false;

            // 토스트 알림
            this.showToast(`📍 ${issue.id}: ${issue.linkedColumns.length}개 기둥 하이라이트`, 'success');

            console.log('[Phase15] Highlighting columns for issue:', issue.id, issue.linkedColumns);
        },

        /**
         * Phase 15: 이슈 텍스트에서 기둥 ID 추출 (Smart Paste 정규식 재사용)
         * @param {string} text - 이슈 텍스트
         * @returns {Array<string>} 추출된 기둥 ID 배열
         */
        extractColumnIdsFromIssue(text) {
            if (!text) return [];

            const columnIds = [];

            // 범위 패턴: C-X1~5, A-X10~15
            const rangePattern = /([A-C])-?[Xx]?(\d{1,3})\s*[~\-~－까지]\s*[Xx]?(\d{1,3})/gi;
            let match;
            while ((match = rangePattern.exec(text)) !== null) {
                const zone = match[1].toUpperCase();
                const start = parseInt(match[2], 10);
                const end = parseInt(match[3], 10);
                for (let i = Math.min(start, end); i <= Math.max(start, end); i++) {
                    columnIds.push(`${zone}-X${i}`);
                }
            }

            // 단일 기둥 패턴: C-X15, A-X3
            const singlePattern = /([A-C])-?[Xx]?(\d{1,3})(?![~\-~－까지\d])/gi;
            while ((match = singlePattern.exec(text)) !== null) {
                const id = `${match[1].toUpperCase()}-X${match[2]}`;
                if (!columnIds.includes(id)) {
                    columnIds.push(id);
                }
            }

            return columnIds;
        },

        /**
         * Phase 15 Step 5: Shop Issues를 Google Sheets에 동기화
         * @param {Array} issues - 동기화할 이슈 목록 (기본: this.shopIssues)
         * @returns {Object} { success, synced, error }
         */
        async syncShopIssuesToGAS(issues = null) {
            const issuesToSync = issues || this.shopIssues;
            
            if (!issuesToSync || issuesToSync.length === 0) {
                this.showToast('동기화할 이슈가 없습니다', 'info');
                return { success: false, synced: 0, error: 'No issues to sync' };
            }

            const apiUrl = this.sheetSync?.apiUrl;
            if (!apiUrl) {
                this.showToast('API 연결이 설정되지 않았습니다', 'warning');
                return { success: false, synced: 0, error: 'API not configured' };
            }

            try {
                this.showToast('Shop Issues 동기화 중...', 'info');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'syncShopIssues',
                        issues: issuesToSync.map(issue => ({
                            id: issue.id,
                            type: issue.type || '',
                            title: issue.title || '',
                            description: issue.description || '',
                            location: issue.location || '',
                            status: issue.status || '',
                            linkedColumns: issue.linkedColumns || [],
                            sourceSheet: issue.sourceSheet || '',
                            sourceDate: issue.sourceDate || '',
                            timestamp: new Date().toISOString()
                        })),
                        stats: this.shopIssueStats
                    })
                });

                const result = await response.json();

                if (result.success) {
                    const synced = result.synced || issuesToSync.length;
                    this.showToast(`✅ ${synced}건 이슈 동기화 완료`, 'success');
                    console.log('[Phase15] Synced to GAS:', synced, 'issues');
                    
                    // LocalStorage에도 저장 (WP-7 Sparse Storage 활용)
                    this.saveShopIssuesToLocal();
                    
                    return { success: true, synced, error: null };
                } else {
                    throw new Error(result.error || 'Sync failed');
                }

            } catch (error) {
                console.error('[Phase15] GAS sync error:', error);
                this.showToast('GAS 동기화 실패: ' + error.message, 'error');
                
                // LocalStorage fallback
                this.saveShopIssuesToLocal();
                
                return { success: false, synced: 0, error: error.message };
            }
        },

        /**
         * Phase 15 Step 5: Google Sheets에서 Shop Issues 로드
         * @returns {Object} { success, issues, stats, error }
         */
        async loadShopIssuesFromGAS() {
            const apiUrl = this.sheetSync?.apiUrl;
            if (!apiUrl) {
                // LocalStorage에서 로드 시도
                return this.loadShopIssuesFromLocal();
            }

            try {
                this.showToast('Shop Issues 로딩 중...', 'info');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'loadShopIssues'
                    })
                });

                const result = await response.json();

                if (result.success && result.issues) {
                    this.shopIssues = result.issues;
                    this.shopIssueStats = result.stats || this.calculateShopIssueStats(result.issues);
                    
                    this.showToast(`✅ ${result.issues.length}건 이슈 로드됨 (GAS)`, 'success');
                    console.log('[Phase15] Loaded from GAS:', result.issues.length, 'issues');
                    
                    // LocalStorage 캐시 업데이트
                    this.saveShopIssuesToLocal();
                    
                    return { success: true, issues: result.issues, stats: this.shopIssueStats, error: null };
                } else {
                    throw new Error(result.error || 'Load failed');
                }

            } catch (error) {
                console.error('[Phase15] GAS load error:', error);
                // LocalStorage fallback
                return this.loadShopIssuesFromLocal();
            }
        },

        /**
         * Phase 15 Step 5: LocalStorage에 Shop Issues 저장 (WP-7 Sparse Storage 패턴)
         */
        saveShopIssuesToLocal() {
            try {
                const data = {
                    issues: this.shopIssues,
                    stats: this.shopIssueStats,
                    issueColumnLinks: this.issueColumnLinks || [],
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('p5_shop_issues', JSON.stringify(data));
                console.log('[Phase15] Saved to LocalStorage:', this.shopIssues.length, 'issues');
            } catch (error) {
                console.error('[Phase15] LocalStorage save error:', error);
            }
        },

        /**
         * Phase 15 Step 5: LocalStorage에서 Shop Issues 로드
         * @returns {Object} { success, issues, stats, error }
         */
        loadShopIssuesFromLocal() {
            try {
                const stored = localStorage.getItem('p5_shop_issues');
                if (!stored) {
                    return { success: true, issues: [], stats: {}, error: null };
                }

                const data = JSON.parse(stored);
                this.shopIssues = data.issues || [];
                this.shopIssueStats = data.stats || this.calculateShopIssueStats(data.issues);
                this.issueColumnLinks = data.issueColumnLinks || [];

                console.log('[Phase15] Loaded from LocalStorage:', this.shopIssues.length, 'issues');
                return { success: true, issues: this.shopIssues, stats: this.shopIssueStats, error: null };

            } catch (error) {
                console.error('[Phase15] LocalStorage load error:', error);
                return { success: false, issues: [], stats: {}, error: error.message };
            }
        },

        /**
         * Phase 15 Step 5: Shop Issue 통계 재계산
         * @param {Array} issues - 이슈 목록
         * @returns {Object} 통계 객체
         */
        calculateShopIssueStats(issues) {
            if (!issues || !Array.isArray(issues)) return { total: 0, resolved: 0, unresolved: 0, byType: {}, byLocation: {} };

            const stats = {
                total: issues.length,
                resolved: 0,
                unresolved: 0,
                byType: {},
                byLocation: {}
            };

            issues.forEach(issue => {
                if (issue.status === 'O') {
                    stats.resolved++;
                } else {
                    stats.unresolved++;
                }

                // 유형별 집계
                const type = issue.type || 'Unknown';
                if (!stats.byType[type]) {
                    stats.byType[type] = { total: 0, resolved: 0 };
                }
                stats.byType[type].total++;
                if (issue.status === 'O') stats.byType[type].resolved++;

                // 위치별 집계
                const location = issue.location || 'Unknown';
                if (!stats.byLocation[location]) {
                    stats.byLocation[location] = { total: 0, resolved: 0 };
                }
                stats.byLocation[location].total++;
                if (issue.status === 'O') stats.byLocation[location].resolved++;
            });

            return stats;
        },

        /**
         * Phase 15 Step 5: 자동 동기화 (Hybrid 모드)
         * LocalStorage에 즉시 저장 + 백그라운드 GAS 동기화
         */
        async autoSyncShopIssues() {
            // 즉시 LocalStorage 저장
            this.saveShopIssuesToLocal();

            // 백그라운드 GAS 동기화 (실패해도 무시)
            if (this.sheetSync?.apiUrl) {
                this.syncShopIssuesToGAS().catch(err => {
                    console.warn('[Phase15] Background GAS sync failed:', err);
                });
            }
        },

        saveIssue() {
            if (!this.issueForm.title) {
                this.showToast('이슈 제목을 입력해주세요', 'error');
                this.announceError('오류: 이슈 제목을 입력해주세요');
                return;
            }

            // 영향받는 기둥 계산
            const affectedColumns = [];
            const startRowIdx = this.rowLabels.indexOf(this.issueForm.startRow);
            const endRowIdx = this.rowLabels.indexOf(this.issueForm.endRow);
            for (let r = startRowIdx; r <= endRowIdx; r++) {
                for (let c = this.issueForm.startColumn; c <= this.issueForm.endColumn; c++) {
                    affectedColumns.push(`${this.rowLabels[r]}-X${c}`);
                }
            }

            const timestamp = new Date().toISOString();
            const newIssue = {
                id: `ISS-${Date.now()}`,
                type: this.issueForm.type,
                title: this.issueForm.title,
                description: this.issueForm.description,
                severity: this.issueForm.severity,
                status: 'open',
                affectedColumns: affectedColumns,
                affectedArea: {
                    range: {
                        startColumn: this.issueForm.startColumn,
                        endColumn: this.issueForm.endColumn,
                        startRow: this.rowLabels.indexOf(this.issueForm.startRow),
                        endRow: this.rowLabels.indexOf(this.issueForm.endRow)
                    }
                },
                assignedTo: this.issueForm.assignedTo || null,
                expectedResolution: this.issueForm.expectedResolution || null,
                actualResolution: null,  // Phase 7+: 실제 해결일 (해결 시 설정)
                overlay: this.issueForm.showOverlay ? {
                    show: true,
                    label: this.issueForm.overlayLabel || `⛔ ${this.issueForm.title}`,
                    borderColor: this.issueForm.overlayColor
                } : { show: false },
                // Phase 7+: Extended Issue Schema
                detail: {
                    rootCause: this.issueForm.rootCause || null,
                    mitigationPlan: this.issueForm.mitigationPlan || null
                },
                reportedBy: this.issueForm.reportedBy || 'dashboard',
                reportedAt: timestamp,
                createdAt: timestamp,
                updatedAt: timestamp,
                comments: []  // 코멘트 배열 초기화
            };

            this.issues.push(newIssue);
            this.showToast(`이슈 "${newIssue.title}"이 등록되었습니다`, 'success');
            this.isDirty = true;
            this.showIssueEditor = false;
            this.saveToLocalStorage(); // 자동 저장
        },

        resolveIssue(issueId) {
            const issue = this.issues.find(i => i.id === issueId);
            if (issue && confirm(`"${issue.title}" 이슈를 해결 처리하시겠습니까?`)) {
                const timestamp = new Date().toISOString();
                issue.status = 'resolved';
                issue.resolvedAt = timestamp;
                issue.actualResolution = timestamp;  // Phase 7+: 실제 해결일
                issue.updatedAt = timestamp;         // Phase 7+: 수정 시간
                this.showToast('이슈가 해결되었습니다', 'success');
                this.isDirty = true;
                this.saveToLocalStorage(); // 자동 저장
            }
        },

        clearAllData() {
            if (confirm('⚠️ 모든 데이터가 삭제됩니다. 계속하시겠습니까?')) {
                localStorage.removeItem(P5Store.STORAGE_KEY);
                location.reload();
            }
        },
        
        // === Column Helpers ===
        getColumnStatus(row, col) {
            const uid = `${row}-X${col}`;
            return this.columns[uid]?.status?.code || 'pending';
        },

        isLocked(row, col) {
            const uid = `${row}-X${col}`;
            return this.columns[uid]?.status?.isLocked || false;
        },

        // === Phase 6: Stage Helpers ===
        getStageStatus(row, col, stageCode) {
            const uid = `${row}-X${col}`;
            const column = this.columns[uid];
            if (!column?.stages) return 'pending';
            return column.stages[stageCode] || 'pending';
        },

        getStageTooltip(row, col) {
            const uid = `${row}-X${col}`;
            const column = this.columns[uid];
            if (!column?.stages) return uid;

            const stageLabels = {
                hmb_fab: 'HMB제작',
                pre_assem: '면조립',
                main_assem: '대조립',
                hmb_psrc: 'HMB+PSRC',
                form: 'FORM',
                embed: '앰베드'
            };

            const parts = [uid];
            let installed = 0;
            for (const [code, label] of Object.entries(stageLabels)) {
                const status = column.stages[code] || 'pending';
                if (status === 'installed') installed++;
            }
            parts.push(`${installed}/6 완료`);
            return parts.join(' | ');
        },

        getOverallProgress(row, col) {
            const uid = `${row}-X${col}`;
            const column = this.columns[uid];
            if (!column?.stages) return 0;

            const stageCodes = ['hmb_fab', 'pre_assem', 'main_assem', 'hmb_psrc', 'form', 'embed'];
            let installed = 0;
            for (const code of stageCodes) {
                if (column.stages[code] === 'installed') installed++;
            }
            return Math.round((installed / 6) * 100);
        },

        // 전체 프로젝트의 특정 공정 단계 진행률 계산
        getStageProgress(stageCode) {
            let total = 0;
            let installed = 0;

            for (const uid in this.columns) {
                const column = this.columns[uid];
                if (column?.stages) {
                    total++;
                    if (column.stages[stageCode] === 'installed') {
                        installed++;
                    }
                }
            }

            return total > 0 ? Math.round((installed / total) * 100) : 0;
        },

        // 전체 프로젝트 진행률 (모든 공정 단계의 평균)
        getTotalProgress() {
            const stageCodes = ['hmb_fab', 'pre_assem', 'main_assem', 'hmb_psrc', 'form', 'embed'];
            let totalInstalled = 0;
            let totalCount = 0;

            for (const uid in this.columns) {
                const column = this.columns[uid];
                if (column?.stages) {
                    for (const code of stageCodes) {
                        totalCount++;
                        if (column.stages[code] === 'installed') {
                            totalInstalled++;
                        }
                    }
                }
            }

            return totalCount > 0 ? Math.round((totalInstalled / totalCount) * 100) : 0;
        },

        // === WP-4: Report Panel Functions ===
        openReportPanel() {
            this.showReportPanel = true;
            this.reportTab = 'overview';
        },

        getStatusDonutData() {
            const statusCounts = {};
            const statusColors = {
                'not_started': '#6e7681',
                'in_progress': '#3b82f6',
                'complete': '#238636',
                'delayed': '#f85149',
                'installed': '#22c55e'
            };

            for (const uid in this.columns) {
                const col = this.columns[uid];
                const status = col?.status?.code || 'not_started';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            }

            const total = Object.values(statusCounts).reduce((a, b) => a + b, 0);
            if (total === 0) return [];

            const segments = [];
            let currentAngle = 0;
            const cx = 75, cy = 75, outerR = 60, innerR = 40;

            for (const [status, count] of Object.entries(statusCounts)) {
                if (count === 0) continue;
                const percentage = count / total;
                const angle = percentage * 360;
                const startAngle = currentAngle;
                const endAngle = currentAngle + angle;
                const startRad = (startAngle - 90) * Math.PI / 180;
                const endRad = (endAngle - 90) * Math.PI / 180;
                const x1 = cx + outerR * Math.cos(startRad);
                const y1 = cy + outerR * Math.sin(startRad);
                const x2 = cx + outerR * Math.cos(endRad);
                const y2 = cy + outerR * Math.sin(endRad);
                const x3 = cx + innerR * Math.cos(endRad);
                const y3 = cy + innerR * Math.sin(endRad);
                const x4 = cx + innerR * Math.cos(startRad);
                const y4 = cy + innerR * Math.sin(startRad);
                const largeArc = angle > 180 ? 1 : 0;
                const path = `M ${x1} ${y1} A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerR} ${innerR} 0 ${largeArc} 0 ${x4} ${y4} Z`;
                segments.push({ path, color: statusColors[status] || '#888', status, count, percentage: Math.round(percentage * 100) });
                currentAngle = endAngle;
            }
            return segments;
        },

        getStatusDonutSVG() {
            const segments = this.getStatusDonutData();
            const progress = this.getTotalProgress();
            let svg = segments.map(s => `<path class="donut-segment" d="${s.path}" fill="${s.color}"/>`).join('');
            svg += `<text x="75" y="72" text-anchor="middle" class="donut-center-text">${progress}%</text>`;
            svg += `<text x="75" y="88" text-anchor="middle" class="donut-center-label">완료율</text>`;
            return svg;
        },

        getIssueSeverityDonutData() {
            const severityCounts = { critical: 0, high: 0, medium: 0, low: 0 };
            const severityColors = { critical: '#f85149', high: '#f97316', medium: '#d29922', low: '#238636' };

            for (const issue of this.issues) {
                if (issue.severity && severityCounts.hasOwnProperty(issue.severity)) {
                    severityCounts[issue.severity]++;
                }
            }

            const total = Object.values(severityCounts).reduce((a, b) => a + b, 0);
            if (total === 0) return [];

            const segments = [];
            let currentAngle = 0;
            const cx = 75, cy = 75, outerR = 60, innerR = 40;

            for (const [severity, count] of Object.entries(severityCounts)) {
                if (count === 0) continue;
                const percentage = count / total;
                const angle = percentage * 360;
                const startAngle = currentAngle;
                const endAngle = currentAngle + angle;
                const startRad = (startAngle - 90) * Math.PI / 180;
                const endRad = (endAngle - 90) * Math.PI / 180;
                const x1 = cx + outerR * Math.cos(startRad);
                const y1 = cy + outerR * Math.sin(startRad);
                const x2 = cx + outerR * Math.cos(endRad);
                const y2 = cy + outerR * Math.sin(endRad);
                const x3 = cx + innerR * Math.cos(endRad);
                const y3 = cy + innerR * Math.sin(endRad);
                const x4 = cx + innerR * Math.cos(startRad);
                const y4 = cy + innerR * Math.sin(startRad);
                const largeArc = angle > 180 ? 1 : 0;
                const path = `M ${x1} ${y1} A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerR} ${innerR} 0 ${largeArc} 0 ${x4} ${y4} Z`;
                segments.push({ path, color: severityColors[severity], severity, count, percentage: Math.round(percentage * 100) });
                currentAngle = endAngle;
            }
            return segments;
        },

        getIssueSeverityDonutSVG() {
            const segments = this.getIssueSeverityDonutData();
            const openCount = this.openIssues.length;
            let svg = segments.map(s => `<path class="donut-segment" d="${s.path}" fill="${s.color}"/>`).join('');
            svg += `<text x="75" y="72" text-anchor="middle" class="donut-center-text">${openCount}</text>`;
            svg += `<text x="75" y="88" text-anchor="middle" class="donut-center-label">미해결</text>`;
            return svg;
        },

        getTrendData() {
            const days = 14;
            const trend = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            for (let i = days - 1; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                const label = `${date.getMonth() + 1}/${date.getDate()}`;

                let changes = 0, completions = 0, issues = 0;

                // Count history events for this day
                if (this.history && Array.isArray(this.history)) {
                    for (const event of this.history) {
                        const eventDate = new Date(event.timestamp);
                        eventDate.setHours(0, 0, 0, 0);
                        if (eventDate.getTime() === date.getTime()) {
                            changes++;
                            if (event.type === 'status_change' && (event.title?.includes('완료') || event.title?.includes('complete'))) {
                                completions++;
                            }
                            if (event.type === 'issue_create') {
                                issues++;
                            }
                        }
                    }
                }

                trend.push({ date: dateStr, label, changes, completions, issues });
            }

            return trend;
        },

        getTrendLinePath(isArea = true) {
            const data = this.getTrendData();
            if (data.length === 0) return '';

            const maxChanges = Math.max(...data.map(d => d.changes), 1);
            const chartWidth = 540;
            const chartHeight = 120;
            const baseY = 140;
            const minY = 20;

            const points = data.map((d, i) => {
                const x = 40 + (i * (chartWidth / (data.length - 1 || 1)));
                const y = baseY - ((d.changes / maxChanges) * chartHeight);
                return { x, y: Math.max(y, minY) };
            });

            if (points.length === 0) return '';

            let path = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L ${points[i].x} ${points[i].y}`;
            }

            if (isArea) {
                // Close the area path
                path += ` L ${points[points.length - 1].x} ${baseY} L ${points[0].x} ${baseY} Z`;
            }

            return path;
        },

        getZoneColumnCount(zone) {
            let count = 0;
            const zoneId = zone?.id || zone;

            for (const uid in this.columns) {
                const col = this.columns[uid];
                if (col?.location?.zoneId === zoneId) {
                    count++;
                }
            }
            return count;
        },

        getZoneStatusCount(zone, statusCode) {
            let count = 0;
            const zoneId = zone?.id || zone;

            for (const uid in this.columns) {
                const col = this.columns[uid];
                if (col?.location?.zoneId === zoneId && col?.status?.code === statusCode) {
                    count++;
                }
            }
            return count;
        },

        exportReportToCSV() {
            // Generate report data
            const reportData = {
                generatedAt: new Date().toISOString(),
                overallProgress: this.getTotalProgress(),
                totalColumns: Object.keys(this.columns).length,
                completedColumns: Object.values(this.columns).filter(c => c.status?.code === 'complete').length,
                inProgressColumns: Object.values(this.columns).filter(c => c.status?.code === 'in_progress').length,
                notStartedColumns: Object.values(this.columns).filter(c => c.status?.code === 'not_started').length,
                openIssues: this.openIssues.length,
                criticalIssues: this.issues.filter(i => i.severity === 'critical' && i.status === 'open').length
            };

            // Generate zone progress data
            const zoneData = this.zones.map(zone => ({
                name: zone.name,
                total: this.getZoneColumnCount(zone),
                complete: this.getZoneStatusCount(zone, 'complete'),
                inProgress: this.getZoneStatusCount(zone, 'in_progress'),
                notStarted: this.getZoneStatusCount(zone, 'not_started'),
                progress: this.getZoneProgress(zone) + '%'
            }));

            // Generate stage progress data
            const stageData = this.stageConfigs.map(stage => ({
                stage: stage.label,
                progress: this.getStageProgress(stage.code) + '%'
            }));

            // Build CSV content
            let csv = 'P5 복합동 진행 현황 보고서\n';
            csv += `생성일: ${new Date().toLocaleDateString('ko-KR')}\n\n`;

            csv += '=== 전체 요약 ===\n';
            csv += `전체 진행률,${reportData.overallProgress}%\n`;
            csv += `총 기둥 수,${reportData.totalColumns}\n`;
            csv += `완료,${reportData.completedColumns}\n`;
            csv += `진행중,${reportData.inProgressColumns}\n`;
            csv += `미착수,${reportData.notStartedColumns}\n`;
            csv += `미해결 이슈,${reportData.openIssues}\n`;
            csv += `Critical 이슈,${reportData.criticalIssues}\n\n`;

            csv += '=== Zone별 현황 ===\n';
            csv += 'Zone,전체,완료,진행중,미착수,진행률\n';
            for (const z of zoneData) {
                csv += `${z.name},${z.total},${z.complete},${z.inProgress},${z.notStarted},${z.progress}\n`;
            }
            csv += '\n';

            csv += '=== 공정별 진행률 ===\n';
            csv += '공정,진행률\n';
            for (const s of stageData) {
                csv += `${s.stage},${s.progress}\n`;
            }

            // Download CSV file
            const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `P5_Report_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();

            this.showToast('보고서가 다운로드되었습니다', 'success');
        },

        // === Phase 6: Workflow Filter Functions ===
        toggleWorkflowFilter(stageCode) {
            if (this.workflowFilter === stageCode) {
                this.workflowFilter = null;  // Toggle off
            } else {
                this.workflowFilter = stageCode;  // Set filter
            }
        },

        clearWorkflowFilter() {
            this.workflowFilter = null;
        },

        getStageCount(stageCode) {
            let count = 0;
            for (const uid in this.columns) {
                const column = this.columns[uid];
                if (column?.stages) {
                    const status = column.stages[stageCode] || 'pending';
                    // Count columns that are currently at this stage (active or installed)
                    if (status === 'active' || status === 'installed') {
                        count++;
                    }
                }
            }
            return count;
        },

        getStageLabel(stageCode) {
            const stage = this.stageConfigs.find(s => s.code === stageCode);
            return stage ? stage.label : stageCode;
        },

        // Check if a cell should be visible based on workflow filter
        isCellFilteredByWorkflow(row, col) {
            if (!this.workflowFilter) return false;  // No filter = all visible

            const uid = `${row}-X${col}`;
            const column = this.columns[uid];
            if (!column?.stages) return true;  // No stages = filtered out

            const stageStatus = column.stages[this.workflowFilter] || 'pending';
            // Show only columns where this stage is active or installed
            return !(stageStatus === 'active' || stageStatus === 'installed');
        },

        // === Phase 7: 스마트 검색 & 필터 ===

        /**
         * WP-5: Debounced 검색 실행
         * 키 입력마다 바로 실행하지 않고 300ms 대기 후 실행
         * 성능 최적화: 입력 중 불필요한 검색 방지
         */
        performSearchDebounced() {
            // 이전 타이머 취소
            if (this._searchTimeout) {
                clearTimeout(this._searchTimeout);
            }

            // 빈 검색어는 즉시 처리
            if (!this.searchQuery.trim()) {
                this.searchResults = [];
                this.searchDropdownOpen = false;
                return;
            }

            // 300ms 후 검색 실행
            this._searchTimeout = setTimeout(() => {
                this.performSearch();
            }, 300);
        },

        /**
         * 검색 실행
         * 기둥 UID, Zone, 상태 등을 검색
         */
        performSearch() {
            const query = this.searchQuery.trim().toLowerCase();
            
            if (!query) {
                this.searchResults = [];
                this.searchDropdownOpen = false;
                return;
            }

            const results = [];
            
            // 1. 기둥 UID 검색 (예: "C-X30", "X30", "30")
            const uidPattern = query.replace(/[^a-z0-9\-]/gi, '');
            for (const uid in this.columns) {
                if (uid.toLowerCase().includes(uidPattern)) {
                    const column = this.columns[uid];
                    results.push({
                        id: uid,
                        type: 'column',
                        uid,
                        icon: '📍',
                        text: uid,
                        hint: this.statusCodes[column.status.code]?.label || column.status.code
                    });
                }
                if (results.length >= 10) break;  // 최대 10개
            }

            // 2. Zone 검색
            for (const zone of this.zones) {
                if (zone.name.toLowerCase().includes(query) || 
                    zone.id.toLowerCase().includes(query)) {
                    results.push({
                        id: zone.id,
                        type: 'zone',
                        zoneId: zone.id,
                        icon: '🏗️',
                        text: zone.name,
                        hint: `Zone ID: ${zone.id}`
                    });
                }
            }

            // 3. 상태 검색
            for (const [code, status] of Object.entries(this.statusCodes)) {
                if (status.label.toLowerCase().includes(query) || 
                    code.toLowerCase().includes(query)) {
                    results.push({
                        id: code,
                        type: 'status',
                        statusCode: code,
                        icon: '🔵',
                        text: status.label,
                        hint: `상태 코드: ${code}`
                    });
                }
            }

            // 4. 이슈 검색
            for (const issue of this.issues) {
                if (issue.title?.toLowerCase().includes(query) ||
                    issue.id?.toLowerCase().includes(query)) {
                    results.push({
                        id: issue.id || 'issue-'+Math.random(),
                        type: 'issue',
                        issueId: issue.id,
                        icon: '🚨',
                        text: issue.title || issue.id,
                        hint: issue.status
                    });
                }
            }

            this.searchResults = results.slice(0, 15);  // 최대 15개
            this.searchDropdownOpen = results.length > 0;
        },

        /**
         * 검색어를 최근 검색에 추가
         */
        addToRecentSearches(query) {
            if (!query.trim()) return;
            
            // 중복 제거 후 맨 앞에 추가
            this.recentSearches = this.recentSearches.filter(s => s !== query);
            this.recentSearches.unshift(query);
            
            // 최대 5개 유지
            if (this.recentSearches.length > 5) {
                this.recentSearches = this.recentSearches.slice(0, 5);
            }

            // LocalStorage에 저장
            try {
                localStorage.setItem('p5_recent_searches', JSON.stringify(this.recentSearches));
            } catch (e) {
                // 저장 실패 무시
            }
        },

        /**
         * 검색 결과 선택
         */
        selectSearchResult(result) {
            this.addToRecentSearches(this.searchQuery);
            this.searchDropdownOpen = false;

            switch (result.type) {
                case 'column':
                    // 해당 기둥 선택 및 스크롤
                    this.selectedCells = [result.uid];
                    this.scrollToColumn(result.uid);
                    this.showToast(`${result.uid} 기둥으로 이동`, 'success');
                    break;

                case 'zone':
                    // Zone 필터 활성화
                    this.addFilter('zone', result.zoneId, result.text);
                    break;

                case 'status':
                    // 상태 필터 활성화
                    this.addFilter('status', result.statusCode, result.text);
                    break;

                case 'issue':
                    // 이슈 패널 열고 해당 이슈 선택
                    this.selectedIssue = this.issues.find(i => i.id === result.issueId);
                    this.issuePanelOpen = true;
                    break;
            }

            this.searchQuery = '';
        },

        /**
         * 기둥으로 스크롤
         */
        scrollToColumn(uid) {
            // UID 파싱 (예: "C-X30" -> row=C, col=30)
            const match = uid.match(/([A-L])-X(\d+)/);
            if (!match) return;

            const rowLetter = match[1];
            const col = parseInt(match[2]);
            const rowIndex = rowLetter.charCodeAt(0) - 65;  // A=0, B=1, ...

            // 해당 셀 요소 찾기
            const cell = document.querySelector(`[data-row="${rowLetter}"][data-col="${col}"]`);
            if (cell) {
                cell.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            }
        },

        /**
         * 필터 추가
         */
        addFilter(type, value, label) {
            // 중복 필터 방지
            const exists = this.activeFilters.find(f => f.type === type && f.value === value);
            if (exists) {
                this.showToast('이미 적용된 필터입니다', 'info');
                return;
            }

            this.activeFilters.push({ type, value, label });
            this.applyFilters();
            this.showToast(`${label} 필터 적용됨`, 'success');
            this.announce('필터 적용됨');
        },

        /**
         * 필터 제거
         */
        removeFilter(index) {
            const removed = this.activeFilters.splice(index, 1)[0];
            this.applyFilters();
            this.showToast(`${removed.label} 필터 해제됨`, 'info');
            this.announce('필터 해제됨');
        },

        /**
         * 필터 적용
         * TODO: 실제 필터링 로직 구현
         */
        applyFilters() {
            console.log('[Search] Applying filters:', this.activeFilters);
            // 필터링 로직은 기존 columns 렌더링과 통합 필요
        },

        /**
         * 모든 필터 초기화
         */
        clearAllFilters() {
            this.activeFilters = [];
            this.applyFilters();
            this.showToast('모든 필터가 해제되었습니다', 'info');
        },

        /**
         * 검색 입력 초기화
         */
        clearSearch() {
            this.searchQuery = '';
            this.searchResults = [];
            this.searchDropdownOpen = false;
        },

        /**
         * 검색 입력창 키보드 이벤트
         */
        handleSearchKeydown(event) {
            if (event.key === 'Enter' && this.searchResults.length > 0) {
                this.selectSearchResult(this.searchResults[0]);
            } else if (event.key === 'Escape') {
                this.clearSearch();
            }
        },

        // === Phase 7: 빠른 상태 변경 (Quick Actions) ===

        /**
         * 선택된 기둥들의 상태를 일괄 변경
         */
        quickChangeStatus(statusCode) {
            if (this.selectedCells.length === 0) return;

            const statusLabel = this.statusCodes[statusCode]?.label || statusCode;
            const count = this.selectedCells.length;

            // 확인 메시지 (5개 이상일 때만)
            if (count >= 5 && !confirm(`${count}개 기둥의 상태를 "${statusLabel}"(으)로 변경하시겠습니까?`)) {
                return;
            }

            // 상태 변경 적용
            for (const uid of this.selectedCells) {
                if (this.columns[uid]) {
                    this.columns[uid].status = {
                        code: statusCode,
                        updatedAt: new Date().toISOString()
                    };
                }
            }

            this.showNotification(
                '✅ 상태 변경 완료',
                `${count}개 기둥 → ${statusLabel}`,
                'success'
            );

            // 선택 유지 (연속 작업 가능)
            console.log(`[QuickAction] Status changed to ${statusCode} for ${count} columns`);
        },

        /**
         * 선택된 기둥들의 공정 상태를 일괄 변경
         */
        quickChangeStage(stageCode, stageStatus = 'active') {
            if (this.selectedCells.length === 0) return;

            const stageLabel = this.getStageLabel(stageCode);
            const count = this.selectedCells.length;

            for (const uid of this.selectedCells) {
                if (this.columns[uid]) {
                    if (!this.columns[uid].stages) {
                        this.columns[uid].stages = {};
                    }
                    this.columns[uid].stages[stageCode] = stageStatus;
                }
            }

            this.showNotification(
                '🔧 공정 변경 완료',
                `${count}개 기둥 → ${stageLabel} (${stageStatus})`,
                'success'
            );

            console.log(`[QuickAction] Stage ${stageCode} set to ${stageStatus} for ${count} columns`);
        },

        /**
         * 현재 활성 공정을 완료 처리
         */
        quickMarkStageComplete() {
            if (this.selectedCells.length === 0) return;

            const count = this.selectedCells.length;
            let completedStages = {};

            for (const uid of this.selectedCells) {
                const column = this.columns[uid];
                if (!column?.stages) continue;

                // 현재 active인 공정을 installed로 변경
                for (const [stageCode, status] of Object.entries(column.stages)) {
                    if (status === 'active') {
                        column.stages[stageCode] = 'installed';
                        completedStages[stageCode] = (completedStages[stageCode] || 0) + 1;
                    }
                }
            }

            const stageNames = Object.keys(completedStages)
                .map(code => this.getStageLabel(code))
                .join(', ');

            if (Object.keys(completedStages).length > 0) {
                this.showNotification(
                    '✅ 공정 완료 처리',
                    `${count}개 기둥의 ${stageNames} 완료`,
                    'success'
                );
            } else {
                this.showToast('완료할 활성 공정이 없습니다', 'info');
            }
        },

        /**
         * 선택된 기둥으로 이슈 등록 모달 열기
         */
        openNewIssueModalWithSelected() {
            if (this.selectedCells.length === 0) return;

            // 이슈 폼 초기화 및 영향 기둥 설정
            this.newIssueForm = {
                type: 'tc',
                title: '',
                severity: 'medium',
                description: '',
                expectedResolution: '',
                affectedColumns: [...this.selectedCells]
            };

            this.newIssueModalOpen = true;
            this.showToast(`${this.selectedCells.length}개 기둥이 이슈에 추가됩니다`, 'info');
        },

        /**
         * 키보드 단축키 처리
         */
        handleGlobalKeydown(event) {
            // 입력 필드 내에서는 무시
            if (['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) return;

            // 선택된 기둥이 있을 때만 동작
            if (this.selectedCells.length === 0) return;

            switch (event.key.toLowerCase()) {
                case 'escape':
                    this.clearSelection();
                    break;
                case 's':
                    // TODO: 상태 변경 메뉴 토글
                    break;
                case 'p':
                    // TODO: 공정 변경 메뉴 토글
                    break;
                case 'i':
                    event.preventDefault();
                    this.openNewIssueModalWithSelected();
                    break;
            }
        },

        // === Phase 7: 히스토리 뷰어 함수 ===

        /**
         * 히스토리 아이콘 반환
         */
        getHistoryIcon(type) {
            const icons = {
                status: '🔄',
                stage: '🔧',
                issue: '🚨',
                create: '➕'
            };
            return icons[type] || '📋';
        },

        /**
         * 히스토리 시간 포맷
         */
        formatHistoryTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        },

        /**
         * 날짜 라벨 포맷 (오늘, 어제, 날짜)
         */
        formatDateLabel(timestamp) {
            const date = new Date(timestamp);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) {
                return '오늘';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return '어제';
            } else {
                return date.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
            }
        },

        /**
         * 히스토리 항목 클릭 처리
         */
        onHistoryItemClick(item) {
            // 해당 기둥으로 이동
            if (item.targetId && this.columns[item.targetId]) {
                this.selectedCells = [item.targetId];
                this.scrollToColumn(item.targetId);
                this.historyPanelOpen = false;
                this.showToast(`${item.targetId}로 이동`, 'info');
            } else if (item.type === 'issue' && item.issueId) {
                // 이슈 상세 열기
                this.selectedIssue = this.issues.find(i => i.id === item.issueId);
                if (this.selectedIssue) {
                    this.issuePanelOpen = true;
                    this.historyPanelOpen = false;
                }
            }
        },

        /**
         * 상태 변경을 히스토리에 기록
         */
        recordHistory(type, targetId, description, data = {}) {
            const entry = {
                id: Date.now(),
                type,
                targetId,
                description,
                timestamp: new Date().toISOString(),
                user: 'Current User',  // TODO: 실제 사용자 연동
                data
            };

            this.historyData.unshift(entry);

            // 최대 500개 유지
            if (this.historyData.length > 500) {
                this.historyData = this.historyData.slice(0, 500);
            }

            // 로컬 저장
            try {
                localStorage.setItem('p5_history', JSON.stringify(this.historyData.slice(0, 100)));
            } catch (e) {
                // 저장 실패 무시
            }
        },

        // === Phase 7: Floor Data Loading (Legacy wrapper) ===
        loadFloorDataLegacy() {
            // 레거시 currentFloor 값을 새 selectedFloor 형식으로 변환
            const floorMapping = {
                'F1': 'F01',
                'F2': 'F02',
                'ALL': null  // 전체는 필터 없음
            };

            const floorId = floorMapping[this.currentFloor] || this.selectedFloor || 'F01';
            const floorName = this.currentFloor === 'F1' ? '1층' :
                              this.currentFloor === 'F2' ? '2층' : '전체';
            console.log(`[Floor Legacy] Loading data for: ${floorName} (${floorId})`);

            // 층 변경 시 선택 초기화
            this.selectedCells = [];

            // Phase 7+ async loadFloorData 호출
            if (floorId && this.syncEnabled && this.apiUrl) {
                this.loadFloorData(floorId);
            } else {
                this.showToast(`${floorName} 데이터 (로컬)`, 'info');
            }
        },

        // === Phase 7: 대시보드 요약 패널 함수 ===

        /**
         * 전체 진행률 계산
         */
        getTotalProgress() {
            const totalColumns = Object.keys(this.columns).length;
            if (totalColumns === 0) return 0;
            
            const completed = this.getCompletedColumnsCount();
            return Math.round((completed / totalColumns) * 100);
        },

        /**
         * 완료된 기둥 수 계산
         */
        getCompletedColumnsCount() {
            let count = 0;
            for (const uid in this.columns) {
                const column = this.columns[uid];
                // 마지막 공정(앰베드)이 완료된 경우를 완료로 간주
                if (column.stages?.embed === 'installed') {
                    count++;
                }
            }
            return count;
        },

        /**
         * 이슈 심각도 이모지
         */
        getSeverityEmoji(severity) {
            const emojis = {
                high: '🔴',
                medium: '🟡',
                low: '🟢'
            };
            return emojis[severity] || '⚪';
        },

        /**
         * Zone별 진행률 계산
         */
        getZoneProgress(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            if (!zone || !zone.columns?.length) return 0;

            let completed = 0;
            for (const uid of zone.columns) {
                const column = this.columns[uid];
                if (column?.stages?.embed === 'installed') {
                    completed++;
                }
            }
            return Math.round((completed / zone.columns.length) * 100);
        },

        /**
         * Zone 색상 반환
         */
        getZoneColor(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            return zone?.color || '#1f6feb';
        },

        // === Phase 13: Summary Panel Helper Functions ===

        /**
         * Zone별 완료 기둥 수
         */
        getZoneCompletedCount(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            if (!zone || !zone.columns?.length) return 0;

            let completed = 0;
            for (const uid of zone.columns) {
                const column = this.columns[uid];
                if (column?.stages?.embed === 'installed') {
                    completed++;
                }
            }
            return completed;
        },

        /**
         * Zone별 전체 기둥 수
         */
        getZoneTotalCount(zoneId) {
            const zone = this.zones.find(z => z.id === zoneId);
            return zone?.columns?.length || 0;
        },

        /**
         * 진행중(active) 기둥 수
         */
        getActiveColumnsCount() {
            return Object.values(this.columns).filter(col =>
                col.status?.code === 'active' || col.status?.code === 'in_progress'
            ).length;
        },

        /**
         * 완료(installed) 기둥 수
         */
        getCompletedColumnsCount() {
            return Object.values(this.columns).filter(col =>
                col.stages?.embed === 'installed'
            ).length;
        },

        /**
         * Summary Panel을 이미지로 저장
         */
        async saveSummaryAsImage() {
            try {
                this.showToast('이미지 생성 중...', 'info');

                // html2canvas 동적 로드
                if (typeof html2canvas === 'undefined') {
                    await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
                }

                const panel = document.getElementById('summary-panel-content');
                if (!panel) {
                    this.showToast('패널을 찾을 수 없습니다', 'error');
                    return;
                }

                const canvas = await html2canvas(panel, {
                    backgroundColor: '#161b22',
                    scale: 2,
                    useCORS: true
                });

                // 다운로드
                const link = document.createElement('a');
                const dateStr = new Date().toISOString().slice(0, 10);
                link.download = `P5_현황_${dateStr}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();

                this.showToast('이미지가 저장되었습니다', 'success');
            } catch (error) {
                console.error('[Summary] Image save error:', error);
                this.showToast('이미지 저장 실패: ' + error.message, 'error');
            }
        },

        /**
         * 현재 현황 링크 복사
         */
        async copySummaryLink() {
            try {
                const url = new URL(window.location.href);
                url.searchParams.set('view', 'summary');
                url.searchParams.set('date', new Date().toISOString().slice(0, 10));

                await navigator.clipboard.writeText(url.toString());
                this.showToast('링크가 복사되었습니다', 'success');
            } catch (error) {
                console.error('[Summary] Copy link error:', error);
                this.showToast('링크 복사 실패', 'error');
            }
        },

        /**
         * 스크립트 동적 로드 유틸리티
         */
        loadScript(src) {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Failed to load: ${src}`));
                document.head.appendChild(script);
            });
        },

        /**
         * 오늘 변경 내역 업데이트 (히스토리에서 추출)
         */
        updateTodayChanges() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            this.todayChanges = this.notificationHistory
                .filter(n => new Date(n.timestamp) >= today)
                .slice(0, 10)
                .map((n, idx) => ({
                    id: n.id || idx,
                    time: this.formatNotificationTime(n.timestamp),
                    description: `${n.title}: ${n.message}`
                }));
        },

        // === Phase 7: 실시간 알림 시스템 ===
        
        /**
         * 알림 표시 (Toast)
         * @param {string} title - 알림 제목
         * @param {string} message - 알림 메시지
         * @param {string} type - 'success' | 'info' | 'warning' | 'error' | 'critical'
         * @param {Object} options - { duration, action, data }
         */
        showNotification(title, message, type = 'info', options = {}) {
            const id = ++this.notificationIdCounter;
            const notification = {
                id,
                title,
                message,
                type,
                timestamp: new Date(),
                read: false,
                closing: false,
                action: options.action || null,
                data: options.data || null
            };

            // 활성 알림에 추가 (최대 3개 유지)
            this.activeNotifications.unshift(notification);
            if (this.activeNotifications.length > 3) {
                this.activeNotifications.pop();
            }

            // 히스토리에 추가 (최대 50개 유지)
            this.notificationHistory.unshift({ ...notification });
            if (this.notificationHistory.length > 50) {
                this.notificationHistory.pop();
            }

            // 긴급 알림 시 소리 및 진동
            if (type === 'critical' || type === 'error') {
                this.playNotificationSound(type);
            }

            // 자동 닫기 (기본 5초, critical은 10초)
            const duration = options.duration || (type === 'critical' ? 10000 : 5000);
            setTimeout(() => {
                this.dismissNotification(id);
            }, duration);

            console.log(`[Notification] ${type.toUpperCase()}: ${title}`);
            return id;
        },

        /**
         * 간편 알림 (기존 showToast 대체)
         */
        showToast(message, type = 'info') {
            const titles = {
                success: '✅ 완료',
                info: 'ℹ️ 안내',
                warning: '⚠️ 주의',
                error: '❌ 오류',
                critical: '🚨 긴급'
            };
            return this.showNotification(titles[type] || titles.info, message, type);
        },

        /**
         * Screen reader announcement (polite)
         */
        announce(message) {
            const el = document.getElementById('sr-announcements');
            if (el) {
                el.textContent = '';
                setTimeout(() => { el.textContent = message; }, 100);
            }
        },

        /**
         * Screen reader error announcement (assertive)
         */
        announceError(message) {
            const el = document.getElementById('sr-errors');
            if (el) {
                el.textContent = '';
                setTimeout(() => { el.textContent = message; }, 100);
            }
        },

        /**
         * 알림 닫기 (애니메이션 포함)
         */
        dismissNotification(id) {
            const notification = this.activeNotifications.find(n => n.id === id);
            if (notification) {
                notification.closing = true;
                setTimeout(() => {
                    this.activeNotifications = this.activeNotifications.filter(n => n.id !== id);
                }, 300);
            }
        },

        /**
         * 알림 클릭 핸들러
         */
        handleNotificationClick(notification) {
            // 알림을 읽음 처리
            const historyItem = this.notificationHistory.find(n => n.id === notification.id);
            if (historyItem) {
                historyItem.read = true;
            }

            // 액션이 있으면 실행
            if (notification.action && typeof notification.action === 'function') {
                notification.action(notification.data);
            }

            // 알림 닫기
            this.dismissNotification(notification.id);
        },

        /**
         * 히스토리 아이템 클릭 핸들러
         */
        handleHistoryItemClick(notification) {
            notification.read = true;

            // 관련 이슈로 이동 등의 액션
            if (notification.data?.issueId) {
                this.selectedIssue = this.issues.find(i => i.id === notification.data.issueId);
                this.issuePanelOpen = true;
                this.notificationPanelOpen = false;
            }
        },

        /**
         * 알림 히스토리 패널 토글
         */
        toggleNotificationPanel() {
            this.notificationPanelOpen = !this.notificationPanelOpen;
            
            // 패널을 열 때 이슈 패널은 닫기
            if (this.notificationPanelOpen) {
                this.issuePanelOpen = false;
            }
        },

        /**
         * 모든 알림 읽음 처리
         */
        markAllNotificationsRead() {
            this.notificationHistory.forEach(n => n.read = true);
            this.showToast('모든 알림을 읽음 처리했습니다', 'success');
        },

        /**
         * 알림 히스토리 전체 삭제
         */
        clearNotificationHistory() {
            if (confirm('모든 알림 히스토리를 삭제하시겠습니까?')) {
                this.notificationHistory = [];
                this.showToast('알림 히스토리가 삭제되었습니다', 'info');
            }
        },

        /**
         * 알림 아이콘 반환
         */
        getNotificationIcon(type) {
            const icons = {
                success: '✅',
                info: 'ℹ️',
                warning: '⚠️',
                error: '❌',
                critical: '🚨'
            };
            return icons[type] || icons.info;
        },

        /**
         * 알림 시간 포맷 (한국어)
         */
        formatNotificationTime(timestamp) {
            const now = new Date();
            const diff = now - new Date(timestamp);
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (seconds < 60) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            if (days < 7) return `${days}일 전`;
            
            // 일주일 이상 지난 경우 날짜 표시
            const date = new Date(timestamp);
            return `${date.getMonth() + 1}월 ${date.getDate()}일`;
        },

        /**
         * 알림 사운드 재생 (웹 API 사용)
         */
        playNotificationSound(type) {
            try {
                // 브라우저 진동 API (모바일)
                if ('vibrate' in navigator) {
                    if (type === 'critical') {
                        navigator.vibrate([200, 100, 200, 100, 200]);
                    } else {
                        navigator.vibrate(200);
                    }
                }

                // 시스템 알림음 (가능한 경우)
                if ('Notification' in window && Notification.permission === 'granted') {
                    // 시스템 알림을 통한 소리 (선택사항)
                }
            } catch (e) {
                // 오류 무시 (사운드는 선택 기능)
            }
        },

        // === Phase 9: History Panel Methods ===

        /**
         * 이력 아이콘 반환
         */
        getHistoryIcon(type) {
            const icons = {
                status: '🔄',
                issue: '🚨',
                lock: '🔒',
                import: '📥',
                stage: '📊'
            };
            return icons[type] || '📋';
        },

        /**
         * 이력 시간 포맷 (한국어)
         */
        formatHistoryTime(timestamp) {
            const now = new Date();
            const diff = now - new Date(timestamp);
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (seconds < 60) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            
            // 하루 이상 지난 경우 시간 표시
            const date = new Date(timestamp);
            return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        },

        /**
         * 날짜 라벨 포맷 (오늘, 어제, 날짜)
         */
        formatDateLabel(timestamp) {
            const date = new Date(timestamp);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) {
                return '오늘';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return '어제';
            } else {
                return `${date.getMonth() + 1}월 ${date.getDate()}일`;
            }
        },

        /**
         * 이력 상세 열기
         */
        openHistoryDetail(item) {
            // 해당 항목 관련 기둥으로 이동
            if (item.affectedColumns && item.affectedColumns.length > 0) {
                this.selectedCells = [...item.affectedColumns];
                const firstCol = item.affectedColumns[0];
                this.openDetail(null, firstCol);
            }
            this.showToast(`"${item.title}" 항목 선택됨`, 'info');
        },

        /**
         * 더 많은 이력 로드
         */
        loadMoreHistory() {
            // TODO: 백엔드 API 연동 시 페이지네이션 구현
            this.showToast('추가 이력 로드 중...', 'info');
        },

        /**
         * 이력 CSV 내보내기
         */
        exportHistory() {
            const headers = ['ID', 'Type', 'Title', 'User', 'Timestamp', 'Affected Count'];
            const rows = this.filteredHistory.map(item => [
                item.id,
                item.type,
                item.title,
                item.user || 'System',
                item.timestamp,
                item.affectedCount || 1
            ]);
            
            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `p5_history_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            this.showToast('이력 CSV 다운로드 완료', 'success');
        },

        /**
         * 이력 항목 추가 (내부 유틸리티)
         */
        addHistoryItem(type, title, affectedColumns = [], user = 'dashboard') {
            const historyId = `HIST-${Date.now()}`;
            const item = {
                id: historyId,
                type: type,
                title: title,
                user: user,
                timestamp: new Date().toISOString(),
                affectedColumns: affectedColumns,
                affectedCount: affectedColumns.length || 1
            };
            
            // 히스토리 앞에 추가 (최신순)
            this.historyData.unshift(item);
            
            // 최대 100개 유지
            if (this.historyData.length > 100) {
                this.historyData = this.historyData.slice(0, 100);
            }
            
            // 오늘 변경 내역에도 추가
            const today = new Date().toDateString();
            if (new Date(item.timestamp).toDateString() === today) {
                this.todayChanges.unshift(item);
                if (this.todayChanges.length > 20) {
                    this.todayChanges = this.todayChanges.slice(0, 20);
                }
            }
            
            return item;
        },

        /**
         * 더 많은 이력 있는지 확인
         */
        get hasMoreHistory() {
            // TODO: 백엔드 연동 시 실제 페이지네이션 상태 반환
            return false;
        },

        // === Selection ===
        isSelected(row, col) {
            const uid = `${row}-X${col}`;
            return this.selectedCells.includes(uid);
        },
        
        handleCellClick(event, row, col) {
            const uid = `${row}-X${col}`;
            
            if (event.shiftKey && this.selectedCells.length > 0) {
                // Shift+Click: Range select
                const lastSelected = this.selectedCells[this.selectedCells.length - 1];
                const [lastRow, lastColStr] = lastSelected.split('-X');
                const lastCol = parseInt(lastColStr);
                const currentCol = col;
                
                const startCol = Math.min(lastCol, currentCol);
                const endCol = Math.max(lastCol, currentCol);
                const startRowIdx = Math.min(this.rowLabels.indexOf(lastRow), this.rowLabels.indexOf(row));
                const endRowIdx = Math.max(this.rowLabels.indexOf(lastRow), this.rowLabels.indexOf(row));
                
                for (let r = startRowIdx; r <= endRowIdx; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        const cellUid = `${this.rowLabels[r]}-X${c}`;
                        if (!this.selectedCells.includes(cellUid)) {
                            this.selectedCells.push(cellUid);
                        }
                    }
                }
            } else if (event.ctrlKey || event.metaKey) {
                // Ctrl+Click: Toggle single
                const idx = this.selectedCells.indexOf(uid);
                if (idx === -1) {
                    this.selectedCells.push(uid);
                } else {
                    this.selectedCells.splice(idx, 1);
                }
            } else {
                // Normal click: Single select
                this.selectedCells = [uid];
            }
        },
        
        clearSelection() {
            this.selectedCells = [];
            this.bulkEditOpen = false;
        },

        bulkChangeStatus(newStatus) {
            const count = this.selectedCells.length;
            if (count === 0) return;

            const statusLabel = this.statusCodes[newStatus]?.label || newStatus;
            const updatedUids = [];

            // 1. 로컬 상태 업데이트 (Optimistic UI)
            this.selectedCells.forEach(uid => {
                if (this.columns[uid]) {
                    this.columns[uid].status = {
                        ...this.columns[uid].status,
                        code: newStatus,
                        updatedAt: new Date().toISOString(),
                        source: 'admin'
                    };
                    updatedUids.push(uid);
                }
            });

            // 2. Sync Queue에 추가 (Sheet 연동 - Bulk)
            if (this.syncEnabled && typeof SyncModule !== 'undefined' && updatedUids.length > 0) {
                SyncModule.queueChange('bulkUpdateColumns', {
                    updates: updatedUids.map(uid => ({
                        uid: uid,
                        status: newStatus
                    })),
                    user: 'dashboard'
                });
            }

            this.showToast(`${count}개 기둥이 "${statusLabel}"으로 변경되었습니다`, 'success');
            this.isDirty = true;
            this.clearSelection();
        },
        
        selectByStatus(status) {
            this.selectedCells = [];
            for (const uid in this.columns) {
                if (this.columns[uid].status.code === status) {
                    this.selectedCells.push(uid);
                }
            }
            this.showToast(`Selected ${this.selectedCells.length} ${status} columns`);
        },
        
        selectByZone(zoneId) {
            this.selectedCells = [];
            for (const uid in this.columns) {
                if (this.columns[uid].location.zoneId === zoneId) {
                    this.selectedCells.push(uid);
                }
            }
            this.showToast(`Selected ${this.selectedCells.length} columns in zone`);
        },
        
        // === Drag Selection (Mouse) ===
        startDragSelect(event) {
            // Prevent drag if clicking on stage-grid or its children
            if (event.target.classList.contains('stage-grid') ||
                event.target.classList.contains('stage-cell') ||
                event.target.classList.contains('dot')) return;

            const gridScrollView = this.$refs.gridScrollView;
            if (gridScrollView) {
                this.dragGridRect = gridScrollView.getBoundingClientRect();
                this.isDragging = true;
                this.dragStart = { x: event.clientX, y: event.clientY };
                this.dragEnd = { x: event.clientX, y: event.clientY };
                this.dragCellCount = 0;
            }
        },

        updateDragSelect(event) {
            if (!this.isDragging) return;

            this.dragEnd = { x: event.clientX, y: event.clientY };

            // Calculate selected cell count (approximation based on drag rect size)
            const cellWidth = this.virtualScroll.enabled ? this.virtualScroll.cellWidth : 28;
            const cellHeight = this.virtualScroll.enabled ? this.virtualScroll.cellHeight : 30;

            const width = Math.abs(this.dragEnd.x - this.dragStart.x);
            const height = Math.abs(this.dragEnd.y - this.dragStart.y);

            const colCount = Math.max(1, Math.floor(width / cellWidth));
            const rowCount = Math.max(1, Math.floor(height / cellHeight));
            this.dragCellCount = colCount * rowCount;
        },

        endDragSelect() {
            if (!this.isDragging) return;

            // Calculate which cells are in the drag rectangle
            const selectedCells = this.getCellsInDragRect();

            if (selectedCells.length > 0) {
                // Add to selection (merge with existing)
                this.selectedCells = [...new Set([...this.selectedCells, ...selectedCells])];
                this.showToast(`${selectedCells.length}개 선택됨`, 'success');
            }

            // Reset state
            this.isDragging = false;
            this.dragStart = null;
            this.dragEnd = null;
            this.dragCellCount = 0;
            this.dragGridRect = null;
        },

        getCellsInDragRect() {
            if (!this.dragGridRect || !this.dragStart || !this.dragEnd) return [];

            const cells = [];
            const gridScrollView = this.$refs.gridScrollView;
            if (!gridScrollView) return [];

            const scrollLeft = gridScrollView.scrollLeft;
            const scrollTop = gridScrollView.scrollTop;
            const gridRect = this.dragGridRect;

            // Convert screen coordinates to grid coordinates
            const startX = Math.min(this.dragStart.x, this.dragEnd.x) - gridRect.left + scrollLeft;
            const startY = Math.min(this.dragStart.y, this.dragEnd.y) - gridRect.top + scrollTop;
            const endX = Math.max(this.dragStart.x, this.dragEnd.x) - gridRect.left + scrollLeft;
            const endY = Math.max(this.dragStart.y, this.dragEnd.y) - gridRect.top + scrollTop;

            // Cell dimensions (including gap)
            const cellWidth = this.virtualScroll.enabled ? this.virtualScroll.cellWidth : 28;
            const cellHeight = this.virtualScroll.enabled ? this.virtualScroll.cellHeight : 30;

            // Account for header row
            const headerHeight = cellHeight;

            // Calculate row/col range
            const startCol = Math.max(1, Math.floor(startX / cellWidth));
            const endCol = Math.min(this.gridConfig.cols, Math.ceil(endX / cellWidth));
            const startRow = Math.max(0, Math.floor((startY - headerHeight) / cellHeight));
            const endRow = Math.min(this.gridConfig.rows - 1, Math.ceil((endY - headerHeight) / cellHeight));

            // Generate UIDs for selected cells
            for (let r = startRow; r <= endRow; r++) {
                const rowLabel = this.rowLabels[r];
                if (!rowLabel) continue;

                for (let c = startCol; c <= endCol; c++) {
                    const uid = `${rowLabel}-X${c}`;
                    if (this.columns[uid]) {
                        cells.push(uid);
                    }
                }
            }

            return cells;
        },

        isInDragRect(row, col) {
            // Check if a cell is in the current drag rectangle
            if (!this.isDragging || !this.dragStart || !this.dragEnd) return false;

            const cells = this.getCellsInDragRect();
            const uid = `${row}-X${col}`;
            return cells.includes(uid);
        },

        // === WP-1: Touch Drag Selection ===
        startTouchDragSelect(event) {
            // Ignore multi-touch (pinch zoom)
            if (event.touches.length > 1) return;

            // Prevent if touching stage-grid elements
            const target = event.target;
            if (target.classList.contains('stage-grid') ||
                target.classList.contains('stage-cell') ||
                target.classList.contains('dot')) return;

            const touch = event.touches[0];
            const gridScrollView = this.$refs.gridScrollView;

            if (gridScrollView) {
                this.touchDragGridRect = gridScrollView.getBoundingClientRect();
                this.touchDragActive = true;
                this.touchDragStart = { x: touch.clientX, y: touch.clientY };
                this.touchDragEnd = { x: touch.clientX, y: touch.clientY };
                this.touchDragCellCount = 0;

                // Haptic feedback (if available)
                if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                }
            }
        },

        updateTouchDragSelect(event) {
            // Cancel pending RAF if multi-touch or inactive
            if (!this.touchDragActive || event.touches.length > 1) {
                if (this._touchDragRAFId) {
                    cancelAnimationFrame(this._touchDragRAFId);
                    this._touchDragRAFId = null;
                }
                this._touchDragRAFPending = false;
                return;
            }

            // Performance: Throttle with requestAnimationFrame
            if (this._touchDragRAFPending) return;
            this._touchDragRAFPending = true;

            // Store RAF ID for cleanup
            this._touchDragRAFId = requestAnimationFrame(() => {
                this._touchDragRAFPending = false;
                this._touchDragRAFId = null;
                if (!this.touchDragActive) return;

                const touch = event.touches[0];
                if (!touch) return;

                this.touchDragEnd = { x: touch.clientX, y: touch.clientY };

                // Calculate selected cell count (approximation based on drag rect size)
                const cellWidth = this.virtualScroll.enabled ? this.virtualScroll.cellWidth : 28;
                const cellHeight = this.virtualScroll.enabled ? this.virtualScroll.cellHeight : 30;

                const width = Math.abs(this.touchDragEnd.x - this.touchDragStart.x);
                const height = Math.abs(this.touchDragEnd.y - this.touchDragStart.y);

                const colCount = Math.max(1, Math.floor(width / cellWidth));
                const rowCount = Math.max(1, Math.floor(height / cellHeight));
                this.touchDragCellCount = colCount * rowCount;
            });
        },

        endTouchDragSelect(event) {
            if (!this.touchDragActive) return;

            // Cleanup any pending RAF to prevent memory leak
            if (this._touchDragRAFId) {
                cancelAnimationFrame(this._touchDragRAFId);
                this._touchDragRAFId = null;
            }
            this._touchDragRAFPending = false;

            // Calculate which cells are in the drag rectangle
            const selectedCells = this.getCellsInTouchDragRect();

            if (selectedCells.length > 0) {
                // Add to selection (or replace if not holding shift equivalent)
                this.selectedCells = [...new Set([...this.selectedCells, ...selectedCells])];
                this.showToast(`${selectedCells.length}개 셀 선택됨`, 'success');

                // Haptic feedback for selection complete
                if ('vibrate' in navigator) {
                    navigator.vibrate([20, 50, 20]);
                }
            }

            // Reset state
            this.touchDragActive = false;
            this.touchDragStart = { x: 0, y: 0 };
            this.touchDragEnd = { x: 0, y: 0 };
            this.touchDragCellCount = 0;
            this.touchDragGridRect = null;
        },

        getCellsInTouchDragRect() {
            if (!this.touchDragGridRect) return [];

            const cells = [];
            const gridScrollView = this.$refs.gridScrollView;
            if (!gridScrollView) return [];

            const scrollLeft = gridScrollView.scrollLeft;
            const scrollTop = gridScrollView.scrollTop;
            const gridRect = this.touchDragGridRect;

            // Convert screen coordinates to grid coordinates
            const startX = Math.min(this.touchDragStart.x, this.touchDragEnd.x) - gridRect.left + scrollLeft;
            const startY = Math.min(this.touchDragStart.y, this.touchDragEnd.y) - gridRect.top + scrollTop;
            const endX = Math.max(this.touchDragStart.x, this.touchDragEnd.x) - gridRect.left + scrollLeft;
            const endY = Math.max(this.touchDragStart.y, this.touchDragEnd.y) - gridRect.top + scrollTop;

            // Cell dimensions (including gap)
            const cellWidth = this.virtualScroll.enabled ? this.virtualScroll.cellWidth : 28;
            const cellHeight = this.virtualScroll.enabled ? this.virtualScroll.cellHeight : 30;

            // Account for header row
            const headerHeight = cellHeight;

            // Calculate row/col range
            const startCol = Math.max(1, Math.floor(startX / cellWidth));
            const endCol = Math.min(this.gridConfig.cols, Math.ceil(endX / cellWidth));
            const startRow = Math.max(0, Math.floor((startY - headerHeight) / cellHeight));
            const endRow = Math.min(this.gridConfig.rows - 1, Math.ceil((endY - headerHeight) / cellHeight));

            // Generate UIDs for selected cells
            for (let r = startRow; r <= endRow; r++) {
                const rowLabel = this.rowLabels[r];
                if (!rowLabel) continue;

                for (let c = startCol; c <= endCol; c++) {
                    const uid = `${rowLabel}-X${c}`;
                    if (this.columns[uid]) {
                        cells.push(uid);
                    }
                }
            }

            return cells;
        },

        // === Detail Panel ===
        openDetail(row, col) {
            const uid = `${row}-X${col}`;
            this.currentColumn = this.columns[uid];
            
            // Populate edit form
            this.editForm.status = this.currentColumn.status.code;
            this.editForm.isLocked = this.currentColumn.status.isLocked || false;
            this.editForm.memberType = this.currentColumn.member?.type || 'SRC Column';
            this.editForm.section = this.currentColumn.member?.section || 'H-500x500';
            
            this.isDirty = false;
            this.detailPanelOpen = true;
        },
        
        markDirty() {
            this.isDirty = true;
        },
        
        cancelEdit() {
            this.detailPanelOpen = false;
            this.isDirty = false;
        },
        
        saveColumn() {
            if (!this.currentColumn) return;

            const uid = this.currentColumn.uid;
            const changes = {
                status: this.editForm.status,
                isLocked: this.editForm.isLocked,
                memberType: this.editForm.memberType,
                section: this.editForm.section
            };

            // 1. 로컬 상태 업데이트 (Optimistic UI)
            this.columns[uid].status.code = changes.status;
            this.columns[uid].status.isLocked = changes.isLocked;
            this.columns[uid].status.source = 'admin';
            this.columns[uid].status.updatedAt = new Date().toISOString();
            this.columns[uid].member.type = changes.memberType;
            this.columns[uid].member.section = changes.section;

            // 2. Sync Queue에 추가 (Sheet 연동)
            if (this.syncEnabled && typeof SyncModule !== 'undefined') {
                SyncModule.queueChange('updateColumn', {
                    uid: uid,
                    data: changes,
                    user: 'dashboard'
                });
            }

            this.isDirty = false;
            this.showToast(`Saved: ${uid}`, 'success');
            this.announce('저장 완료');
        },

        // === Bulk Edit ===
        openBulkEdit() {
            this.bulkEditForm.status = '';
            this.bulkEditForm.setLock = false;
            this.bulkEditOpen = true;
        },
        
        closeBulkEdit() {
            this.bulkEditOpen = false;
        },

        getSelectedLockCount() {
            return this.selectedCells.filter(uid =>
                this.columns[uid]?.status?.isLocked
            ).length;
        },

        bulkLockSelected(lockState) {
            const updates = [];

            // 1. 로컬 상태 업데이트 (Optimistic UI)
            for (const uid of this.selectedCells) {
                if (this.columns[uid]) {
                    this.columns[uid].status.isLocked = lockState;
                    updates.push({ uid, isLocked: lockState });
                }
            }

            // 2. Sync Queue에 추가 (Sheet 연동)
            if (this.syncEnabled && typeof SyncModule !== 'undefined' && updates.length > 0) {
                SyncModule.queueChange('bulkUpdateColumns', {
                    updates: updates,
                    user: 'dashboard'
                });
            }

            const action = lockState ? 'Locked' : 'Unlocked';
            this.showToast(`🔒 ${action} ${updates.length} columns`, 'success');
            this.saveToLocalStorage();
        },

        applyBulkEdit() {
            const updates = [];

            // 1. 로컬 상태 업데이트 (Optimistic UI)
            for (const uid of this.selectedCells) {
                const updateData = {};
                if (this.bulkEditForm.status) {
                    this.columns[uid].status.code = this.bulkEditForm.status;
                    this.columns[uid].status.source = 'admin';
                    this.columns[uid].status.updatedAt = new Date().toISOString();
                    updateData.status = this.bulkEditForm.status;
                }
                if (this.bulkEditForm.setLock) {
                    this.columns[uid].status.isLocked = true;
                    updateData.isLocked = true;
                }
                if (Object.keys(updateData).length > 0) {
                    updates.push({ uid, ...updateData });
                }
            }

            // 2. Sync Queue에 추가 (Sheet 연동 - Bulk)
            if (this.syncEnabled && typeof SyncModule !== 'undefined' && updates.length > 0) {
                SyncModule.queueChange('bulkUpdateColumns', {
                    updates: updates,
                    user: 'dashboard'
                });
            }

            this.showToast(`Updated ${updates.length} columns`, 'success');
            this.closeBulkEdit();
            this.clearSelection();
        },
        
        // === Storage ===
        saveToLocalStorage() {
            const data = {
                zones: this.zones,
                columns: this.columns,
                issues: this.issues,
                statusCodes: this.statusCodes,
                savedAt: new Date().toISOString()
            };
            
            if (P5Store.save(data)) {
                this.showToast('Saved to LocalStorage', 'success');
            } else {
                this.showToast('Failed to save', 'error');
            }
        },
        
        exportData() {
            const data = {
                zones: this.zones,
                columns: this.columns,
                statusCodes: this.statusCodes,
                exportedAt: new Date().toISOString()
            };
            P5Store.export(data);
            this.showToast('Exported to JSON file', 'success');
        },
        
        // === Toast ===
        showToast(message, type = 'success') {
            this.toast = { show: true, message, type };
            setTimeout(() => { this.toast.show = false; }, 3000);
        },
        
        // === Sync Operations ===
        
        /**
         * Configure API sync
         * @param {string} url - Apps Script Web App URL
         */
        configureSync(url) {
            if (!url || typeof SyncModule === 'undefined') {
                console.warn('SyncModule not available or URL not provided');
                return;
            }
            
            this.apiUrl = url;
            this.syncEnabled = true;
            
            SyncModule.configure({
                apiUrl: url,
                onSyncComplete: (results) => {
                    this.showToast(`Synced: ${results.success}, Conflicts: ${results.conflicts}`, 
                                   results.conflicts > 0 ? 'error' : 'success');
                },
                onConflict: (item, result) => {
                    console.warn('Sync conflict:', item.payload.uid, result);
                },
                onSyncError: (item, error) => {
                    console.error('Sync error:', item.payload.uid, error);
                }
            });
            
            // Start auto-sync
            SyncModule.startAutoSync();
            this.showToast('Sync enabled', 'success');
        },

        /**
         * Show loading overlay with message
         */
        showLoading(message = '로딩 중...') {
            this.loadingMessage = message;
            this.isLoading = true;
        },

        /**
         * Hide loading overlay
         */
        hideLoading() {
            this.isLoading = false;
            this.loadingMessage = '';
        },

        /**
         * Force sync now
         */
        async syncNow() {
            if (!this.syncEnabled) {
                this.showToast('Sync not configured', 'error');
                return;
            }

            try {
                this.showLoading('데이터 동기화 중...');
                const result = await SyncModule.syncNow();

                if (result.success) {
                    this.showToast(`Sync complete: ${result.success || 0} items`, 'success');
                    this.announce('동기화 완료');
                } else {
                    this.showToast('Sync failed', 'error');
                    this.announceError('오류: 동기화 실패');
                }
            } finally {
                this.hideLoading();
            }
        },

        // === Phase 5: AI Analysis Methods ===

        /**
         * Trigger AI email analysis
         */
        async triggerAnalysis() {
            if (!this.syncEnabled) {
                this.showToast('Sync not configured. Enable sync first.', 'error');
                return;
            }

            try {
                this.showLoading('AI 분석 시작 중...');
                this.analysisJob.status = 'pending';

                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'triggerAnalysis',
                        user: 'dashboard'
                    })
                });

                const result = await response.json();

                if (result.success) {
                    this.analysisJob.status = 'running';
                    this.analysisJob.jobId = result.jobId;
                    this.analysisJob.startedAt = Date.now();
                    this.showToast(`Analysis job started: ${result.jobId}`, 'success');

                    // Start polling for status
                    this.startAnalysisPolling();
                } else {
                    this.analysisJob.status = 'idle';
                    this.showToast(result.error || 'Failed to start analysis', 'error');
                }
            } catch (e) {
                this.analysisJob.status = 'idle';
                this.showToast('Analysis request failed: ' + e.message, 'error');
            } finally {
                this.hideLoading();
            }
        },

        /**
         * Start polling for analysis job status
         */
        startAnalysisPolling() {
            // Clear any existing polling
            if (this.analysisPollingInterval) {
                clearInterval(this.analysisPollingInterval);
            }

            // Poll every 5 seconds
            this.analysisPollingInterval = setInterval(async () => {
                await this.checkAnalysisStatus();
            }, 5000);
        },

        /**
         * Check analysis job status
         */
        async checkAnalysisStatus() {
            if (!this.syncEnabled) return;

            try {
                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'getAnalysisStatus'
                    })
                });

                const result = await response.json();

                if (result.success && result.job) {
                    const job = result.job;

                    if (job.status === 'completed') {
                        this.analysisJob.status = 'completed';
                        this.analysisJob.result = job.result;
                        this.showToast(`Analysis complete! ${job.result?.processed || 0} emails processed.`, 'success');
                        this.stopAnalysisPolling();

                        // Refresh data to show new issues
                        await this.loadFromServer();
                    } else if (job.status === 'failed') {
                        this.analysisJob.status = 'failed';
                        this.showToast('Analysis failed: ' + (job.error || 'Unknown error'), 'error');
                        this.stopAnalysisPolling();
                    }
                    // If still running, continue polling
                } else if (!result.job) {
                    // No active job, stop polling
                    this.analysisJob.status = 'idle';
                    this.stopAnalysisPolling();
                }
            } catch (e) {
                console.error('Failed to check analysis status:', e);
            }
        },

        /**
         * Stop analysis status polling
         */
        stopAnalysisPolling() {
            if (this.analysisPollingInterval) {
                clearInterval(this.analysisPollingInterval);
                this.analysisPollingInterval = null;
            }
        },

        /**
         * Save column change and queue for sync
         */
        saveColumnWithSync(uid, changes) {
            // Update local state
            if (this.columns[uid]) {
                Object.assign(this.columns[uid].status, changes);
                this.columns[uid].status.updatedAt = new Date().toISOString();
                this.columns[uid].status.source = 'admin';
            }
            
            // Save to localStorage
            this.saveToLocalStorage();
            
            // Queue for sync if enabled
            if (this.syncEnabled && typeof SyncModule !== 'undefined') {
                SyncModule.queueChange('updateColumn', {
                    uid,
                    data: changes,
                    user: 'dashboard'
                });
            }
        },
        
        /**
         * Bulk save with sync
         */
        bulkSaveWithSync(uids, changes) {
            // Update local state
            for (const uid of uids) {
                if (this.columns[uid]) {
                    Object.assign(this.columns[uid].status, changes);
                    this.columns[uid].status.updatedAt = new Date().toISOString();
                    this.columns[uid].status.source = 'admin';
                }
            }
            
            // Save to localStorage
            this.saveToLocalStorage();
            
            // Queue for sync if enabled
            if (this.syncEnabled && typeof SyncModule !== 'undefined') {
                SyncModule.queueChange('bulkUpdate', {
                    uids,
                    data: changes,
                    user: 'dashboard'
                });
            }
        },
        
        // === Issue Management ===
        
        /**
         * Initialize sample issues (for demo)
         */
        initSampleIssues() {
            this.issues = [
                // === MAGENTA: HOLD ISSUES ===
                {
                    id: 'HOLD-1-04',
                    type: 'hold_design', // HOLD
                    title: '1절_HOLD-4 (3~12열 HOLD)',
                    affectedColumns: [], // Range 3-12 handled by overlay
                    zoneId: 'zone_c',
                    severity: 'critical',
                    description: '3~12열 전체 본안 HOLD (1절_HOLD-4)',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '⛔ 1절_HOLD-4\n3~12열 HOLD',
                        range: { startColumn: 3, endColumn: 12, startRow: 0, endRow: 10 }
                    }
                },
                {
                    id: 'HOLD-1-02',
                    type: 'hold_design',
                    title: '1절_HOLD-2 (Canopy/AFC)',
                    affectedColumns: [],
                    zoneId: 'zone_a',
                    severity: 'medium', // Note says 'ignore instruction' but originally HOLD
                    description: 'AFC 2.0_Ref3 HOLD 구간 / CANOPY 변경 예정 (현장회의: HOLD 무시 지시)',
                    expectedResolution: '2026-01-06',
                    status: 'in_progress',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-06T00:00:00',
                    overlay: {
                        show: true,
                        label: '⚠️ 1절_HOLD-2\nCanopy Change',
                        range: { startColumn: 64, endColumn: 69, startRow: 0, endRow: 10 }
                    }
                },
                {
                    id: 'HOLD-1-01',
                    type: 'hold_tc',
                    title: '1절_HOLD-1 (T/C 간섭)',
                    affectedColumns: [],
                    zoneId: 'zone_a',
                    severity: 'high',
                    description: 'AFC 2.0_Ref3 HOLD 구간 / 타워크레인 간섭으로 인한 수조 벽체 이동 건',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '⛔ 1절_HOLD-1\nT/C Interference',
                        range: { startColumn: 50, endColumn: 55, startRow: 8, endRow: 10 }
                    }
                },

                // === YELLOW: MODIFICATION PLANNED ===
                {
                    id: 'MOD-1-01',
                    type: 'design',
                    title: '1절_수정예정-1 (PTW)',
                    affectedColumns: [],
                    zoneId: 'zone_c',
                    severity: 'high',
                    description: 'PTW 인걸 철근 및 철골 변경 / 수조 영역 변경',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-1\nPTW/Tank',
                        range: { startColumn: 12, endColumn: 18, startRow: 0, endRow: 4 }
                    }
                },
                {
                    id: 'MOD-1-02',
                    type: 'design',
                    title: '1절_수정예정-2 (PTW/TC)',
                    affectedColumns: [],
                    zoneId: 'zone_b',
                    severity: 'high',
                    description: 'PTW 수평철근 추가 / 타워크레인 간섭으로 인한 수조 벽체 이동',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-2\nWall Move',
                        range: { startColumn: 23, endColumn: 30, startRow: 0, endRow: 4 }
                    }
                },
                {
                    id: 'MOD-1-03',
                    type: 'design',
                    title: '1절_수정예정-3 (PTW 철물)',
                    affectedColumns: [],
                    zoneId: 'zone_b',
                    severity: 'medium',
                    description: 'PTW 연결 철물 변경 / 수조 높이 변경 예정',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-3\nHardware/Height',
                        range: { startColumn: 35, endColumn: 45, startRow: 0, endRow: 4 }
                    }
                },
                {
                    id: 'MOD-1-04',
                    type: 'design',
                    title: '1절_수정예정-4 (C4 Base)',
                    affectedColumns: [],
                    zoneId: 'zone_a',
                    severity: 'medium',
                    description: 'C4 기둥 BASE 변경 예정',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-4\nC4 Base',
                        range: { startColumn: 58, endColumn: 60, startRow: 0, endRow: 3 }
                    }
                },
                {
                    id: 'MOD-1-05',
                    type: 'design',
                    title: '1절_수정예정-5 (HMB Angle)',
                    affectedColumns: [],
                    zoneId: 'zone_a',
                    severity: 'low',
                    description: 'HMB 하부앵글 SIZE 변경 예정 / EPC 변경',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-5\nHMB Angle',
                        range: { startColumn: 65, endColumn: 69, startRow: 0, endRow: 5 }
                    }
                },
                {
                    id: 'MOD-1-06',
                    type: 'design',
                    title: '1절_수정예정-6 (Form/Clip)',
                    affectedColumns: [],
                    zoneId: 'zone_a',
                    severity: 'low',
                    description: '외곽부 수영장 이음부 CLIP ANGLE 배치 변경 / 외곽 이음부 공장 Form 변경',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-6\nForm/Clip',
                        range: { startColumn: 50, endColumn: 60, startRow: 8, endRow: 10 }
                    }
                },
                {
                    id: 'MOD-1-07',
                    type: 'design',
                    title: '1절_수정예정-7 (PSRC/HMB/Elev)',
                    affectedColumns: [],
                    zoneId: 'zone_b',
                    severity: 'high',
                    description: 'PSRC, HMB 수정 / ELEV. 신설 예정',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-7\nElevator New',
                        range: { startColumn: 30, endColumn: 40, startRow: 8, endRow: 10 }
                    }
                },
                {
                    id: 'MOD-1-08',
                    type: 'design',
                    title: '1절_수정예정-8 (Stud/BIM)',
                    affectedColumns: [],
                    zoneId: 'zone_c',
                    severity: 'medium',
                    description: 'EMBEDDED_STUD 간섭 수정 / BIM 자체 체크',
                    expectedResolution: 'TBD',
                    status: 'open',
                    reportedBy: 'shop_drawing',
                    reportedAt: '2026-01-08T09:00:00',
                    overlay: {
                        show: true,
                        label: '🔧 1절_수정-8\nStud Check',
                        range: { startColumn: 5, endColumn: 15, startRow: 8, endRow: 10 }
                    }
                }
            ];
        },

        // === Phase 7: 키보드 단축키 시스템 ===

        /**
         * 글로벌 키보드 단축키 등록
         */
        registerKeyboardShortcuts() {
            // DOM에서 Alpine 컴포넌트 참조를 가져오는 헬퍼 함수
            const getAlpineData = () => {
                const el = document.querySelector('[x-data]');
                return el && el._x_dataStack ? el._x_dataStack[0] : null;
            };

            document.addEventListener('keydown', (e) => {
                const self = getAlpineData();
                if (!self) return;

                // 입력 필드에서는 단축키 무시
                const isInputFocused = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement?.tagName);
                if (isInputFocused && e.key !== 'Escape') return;

                // Escape: 모달/패널 닫기
                if (e.key === 'Escape') {
                    self.handleEscapeKey();
                    return;
                }

                // ? 또는 /: 단축키 도움말
                if ((e.key === '?' && e.shiftKey) || e.key === '/') {
                    if (!isInputFocused) {
                        e.preventDefault();
                        self.shortcutsModalOpen = !self.shortcutsModalOpen;
                    }
                    return;
                }

                // 나머지 단축키는 입력 필드에서 무시
                if (isInputFocused) return;

                // S: 상태 변경 (기둥 선택 시)
                if (e.key === 's' || e.key === 'S') {
                    if (self.selectedCells.length > 0) {
                        e.preventDefault();
                        self.openBulkStatusModal();
                    }
                    return;
                }

                // P: 공정 변경 (기둥 선택 시)
                if (e.key === 'p' || e.key === 'P') {
                    if (self.selectedCells.length > 0) {
                        e.preventDefault();
                        self.openBulkStageModal();
                    }
                    return;
                }

                // I: 이슈 등록 (기둥 선택 시)
                if (e.key === 'i' || e.key === 'I') {
                    if (self.selectedCells.length > 0) {
                        e.preventDefault();
                        self.openNewIssueModal();
                    }
                    return;
                }

                // L: Lock 토글 (기둥 선택 시)
                if (e.key === 'l' || e.key === 'L') {
                    if (self.selectedCells.length > 0) {
                        e.preventDefault();
                        // 현재 잠금 상태에 따라 토글
                        const lockedCount = self.getSelectedLockCount();
                        const shouldLock = lockedCount < self.selectedCells.length;
                        self.bulkLockSelected(shouldLock);
                    }
                    return;
                }

                // A: 전체 선택
                if ((e.key === 'a' || e.key === 'A') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    self.selectAllColumns();
                    return;
                }

                // D: 선택 해제
                if (e.key === 'd' || e.key === 'D') {
                    e.preventDefault();
                    self.clearSelection();
                    return;
                }

                // N: 알림 패널 토글
                if (e.key === 'n' || e.key === 'N') {
                    e.preventDefault();
                    self.notificationPanelOpen = !self.notificationPanelOpen;
                    return;
                }

                // H: 히스토리 패널 토글
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    self.historyPanelOpen = !self.historyPanelOpen;
                    return;
                }

                // G: 요약 패널 토글
                if (e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                    self.summaryPanelOpen = !self.summaryPanelOpen;
                    return;
                }

                // E: 이슈 패널 토글
                if (e.key === 'e' || e.key === 'E') {
                    e.preventDefault();
                    self.issuePanelOpen = !self.issuePanelOpen;
                    return;
                }

                // 1-6: 공정별 필터
                if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                    e.preventDefault();
                    const stageIndex = parseInt(e.key) - 1;
                    if (self.stageConfigs[stageIndex]) {
                        const stageCode = self.stageConfigs[stageIndex].code;
                        self.workflowFilter = self.workflowFilter === stageCode ? null : stageCode;
                    }
                    return;
                }

                // 0: 필터 초기화
                if (e.key === '0') {
                    e.preventDefault();
                    self.workflowFilter = null;
                    self.activeFilters = [];
                    return;
                }

                // R: 새로고침 (Sync)
                if (e.key === 'r' || e.key === 'R') {
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        if (typeof SyncModule !== 'undefined' && self.syncEnabled) {
                            SyncModule.fullSync();
                            self.showToast('동기화 시작...', 'info');
                        }
                    }
                    return;
                }

                // Phase 7: 층 이동 단축키
                // Page Up: 상위 층으로 이동
                if (e.key === 'PageUp') {
                    e.preventDefault();
                    self.navigateFloor(-1);
                    return;
                }

                // Page Down: 하위 층으로 이동
                if (e.key === 'PageDown') {
                    e.preventDefault();
                    self.navigateFloor(1);
                    return;
                }

                // F: 층 선택기 토글
                if (e.key === 'f' || e.key === 'F') {
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        self.floorSelectorOpen = !self.floorSelectorOpen;
                    }
                    return;
                }

                // J: 절주 필터 순환
                if (e.key === 'j' || e.key === 'J') {
                    e.preventDefault();
                    self.cycleJeoljuFilter();
                    return;
                }
            });
        },

        /**
         * Escape 키 처리 (우선순위에 따라 모달/패널 닫기)
         */
        handleEscapeKey() {
            // 우선순위: 모달 > 디테일 패널 > 사이드 패널 > 선택 해제
            if (this.shortcutsModalOpen) {
                this.shortcutsModalOpen = false;
                return;
            }
            if (this.newIssueModalOpen) {
                this.newIssueModalOpen = false;
                return;
            }
            if (this.bulkEditOpen) {
                this.bulkEditOpen = false;
                return;
            }
            if (this.detailPanelOpen) {
                this.detailPanelOpen = false;
                return;
            }
            if (this.summaryPanelOpen) {
                this.summaryPanelOpen = false;
                return;
            }
            if (this.notificationPanelOpen) {
                this.notificationPanelOpen = false;
                return;
            }
            if (this.historyPanelOpen) {
                this.historyPanelOpen = false;
                return;
            }
            if (this.issuePanelOpen) {
                this.issuePanelOpen = false;
                return;
            }
            // 마지막: 선택 해제
            if (this.selectedCells.length > 0) {
                this.clearSelection();
            }
        },

        /**
         * 전체 기둥 선택
         */
        selectAllColumns() {
            this.selectedCells = Object.keys(this.columns);
            this.showToast(`${this.selectedCells.length}개 기둥 선택됨`, 'info');
            this.announce(this.selectedCells.length + '개 항목 선택됨');
        },

        /**
         * 상태 변경 모달 열기 (Quick Action)
         */
        openBulkStatusModal() {
            this.bulkEditForm.status = '';
            this.bulkEditOpen = true;
        },

        /**
         * 공정 변경 모달 열기 (Quick Action)
         */
        openBulkStageModal() {
            // TODO: 공정 변경 모달 구현
            this.showToast('공정 변경 기능 준비 중', 'info');
        },

        /**
         * Open new issue modal
         */
        openNewIssueModal() {
            this.newIssueForm = {
                type: 'tc',
                title: '',
                severity: 'medium',
                description: '',
                expectedResolution: ''
            };
            this.newIssueModalOpen = true;
        },
        
        /**
         * Create new issue
         */
        createIssue() {
            if (!this.newIssueForm.title || this.selectedCells.length === 0) {
                this.showToast('Title and affected columns required', 'error');
                return;
            }
            
            const issueId = `ISS-${new Date().getFullYear()}-${String(this.issues.length + 1).padStart(4, '0')}`;
            const timestamp = new Date().toISOString();
            
            // Calculate overlay range from selected cells
            let minCol = Infinity, maxCol = 0, minRow = Infinity, maxRow = 0;
            for (const uid of this.selectedCells) {
                const [row, colStr] = uid.split('-X');
                const col = parseInt(colStr);
                const rowIdx = this.rowLabels.indexOf(row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
                minRow = Math.min(minRow, rowIdx);
                maxRow = Math.max(maxRow, rowIdx);
            }
            
            const newIssue = {
                id: issueId,
                type: this.newIssueForm.type,
                title: this.newIssueForm.title,
                affectedColumns: [...this.selectedCells],
                zoneId: this.getZoneForColumn(minCol)?.id || 'zone_a',
                severity: this.newIssueForm.severity,
                description: this.newIssueForm.description,
                expectedResolution: this.newIssueForm.expectedResolution,
                status: 'open',
                reportedBy: 'dashboard',
                reportedAt: timestamp,
                overlay: {
                    show: true,
                    label: this.getIssueTypeIcon(this.newIssueForm.type) + ' ' + this.newIssueForm.title.substring(0, 15),
                    range: { startColumn: minCol, endColumn: maxCol, startRow: minRow, endRow: maxRow }
                }
            };
            
            this.issues.push(newIssue);

            // Update affected columns status
            const holdStatus = this.newIssueForm.type === 'tc' ? 'hold_tc' :
                               this.newIssueForm.type === 'design' ? 'hold_design' : 'hold_material';

            for (const uid of this.selectedCells) {
                if (this.columns[uid]) {
                    this.columns[uid].status.code = holdStatus;
                    this.columns[uid].status.updatedAt = timestamp;
                    this.columns[uid].status.source = 'issue';
                    this.columns[uid].issueId = issueId;
                }
            }

            // Sync Queue에 추가 (Sheet 연동 - Issue 생성)
            if (this.syncEnabled && typeof SyncModule !== 'undefined') {
                SyncModule.queueChange('createIssue', {
                    issueData: newIssue,
                    user: 'dashboard'
                });
                // 연관 기둥 상태도 일괄 업데이트
                SyncModule.queueChange('bulkUpdateColumns', {
                    updates: this.selectedCells.map(uid => ({
                        uid: uid,
                        status: holdStatus,
                        issueId: issueId
                    })),
                    user: 'dashboard'
                });
            }

            this.saveToLocalStorage();
            this.newIssueModalOpen = false;
            this.clearSelection();
            this.showToast(`Issue ${issueId} created`, 'success');
        },
        
        /**
         * Get issue type icon
         */
        getIssueTypeIcon(type) {
            const icons = { tc: '⛔', design: '⚠️', material: '📦', safety: '🛑' };
            return icons[type] || '⚠️';
        },
        
        /**
         * Select an issue
         */
        selectIssue(issue) {
            this.selectedIssue = issue;
            
            // Highlight affected columns
            this.clearSelection();
            this.selectedCells = [...(issue.affectedColumns || [])];
        },
        
        /**
         * Resolve an issue
         */
        resolveIssue(issueId, restoreStatus = 'active') {
            const issue = this.issues.find(i => i.id === issueId);
            if (!issue) return;

            const timestamp = new Date().toISOString();
            issue.status = 'resolved';
            issue.actualResolution = timestamp;
            issue.overlay.show = false;

            // Restore affected columns
            const affectedUids = issue.affectedColumns || [];
            for (const uid of affectedUids) {
                if (this.columns[uid]) {
                    this.columns[uid].status.code = restoreStatus;
                    this.columns[uid].status.updatedAt = timestamp;
                    this.columns[uid].status.source = 'admin';
                    this.columns[uid].issueId = null;
                }
            }

            // Sync Queue에 추가 (Sheet 연동 - Issue 해결)
            if (this.syncEnabled && typeof SyncModule !== 'undefined') {
                SyncModule.queueChange('resolveIssue', {
                    issueId: issueId,
                    resolution: timestamp,
                    user: 'dashboard'
                });
                // 연관 기둥 상태도 일괄 업데이트
                if (affectedUids.length > 0) {
                    SyncModule.queueChange('bulkUpdateColumns', {
                        updates: affectedUids.map(uid => ({
                            uid: uid,
                            status: restoreStatus,
                            issueId: null
                        })),
                        user: 'dashboard'
                    });
                }
            }

            this.saveToLocalStorage();
            this.showToast(`Issue ${issueId} resolved`, 'success');
        },
        
        /**
         * Calculate overlay position and size
         */
        getOverlayStyle(issue) {
            if (!issue.overlay?.range) return 'display: none;';
            
            const range = issue.overlay.range;
            const cellSize = 28;  // Grid cell size (26px + 2px gap)
            const headerOffset = 65;  // Header row offset
            const rowHeaderWidth = 37;  // Row label width
            const gridPadding = 30;  // Grid container padding
            const sidebarWidth = 260;  // Sidebar width
            
            const left = sidebarWidth + gridPadding + rowHeaderWidth + (range.startColumn - 1) * cellSize;
            const top = 55 + 30 + headerOffset + gridPadding + range.startRow * cellSize;  // header + zone bar + grid header
            const width = (range.endColumn - range.startColumn + 1) * cellSize;
            const height = (range.endRow - range.startRow + 1) * cellSize;
            
            return `left: ${left}px; top: ${top}px; width: ${width}px; height: ${height}px;`;
        },
        
        /**
         * Toggle issue panel
         */
        toggleIssuePanel() {
            this.issuePanelOpen = !this.issuePanelOpen;
        },
        
        // === Admin Panel Methods ===
        
        /**
         * Update zone color
         */
        updateZoneColor(zoneId, color) {
            const zone = this.zones.find(z => z.id === zoneId);
            if (zone) {
                zone.style.primaryColor = color;
                zone.style.backgroundColor = color + '1a';  // Add transparency
                this.saveToLocalStorage();
                this.showToast(`Zone color updated`, 'success');
            }
        },
        
        /**
         * Edit zone (placeholder - in production would open modal)
         */
        editZone(zone) {
            const newName = prompt('Display Name:', zone.displayName);
            if (newName && newName !== zone.displayName) {
                zone.displayName = newName;
                this.saveToLocalStorage();
                this.showToast(`Zone updated`, 'success');
            }
        },
        
        /**
         * Add new zone
         */
        addNewZone() {
            const lastZone = this.zones[this.zones.length - 1];
            const newZone = {
                id: 'zone_' + String.fromCharCode(65 + this.zones.length).toLowerCase(),
                name: 'ZONE ' + String.fromCharCode(65 + this.zones.length),
                displayName: 'New Zone',
                description: 'Description',
                range: {
                    startColumn: (lastZone?.range?.endColumn || 0) + 1,
                    endColumn: Math.min((lastZone?.range?.endColumn || 0) + 10, 69),
                    startRow: 0,
                    endRow: 11
                },
                style: {
                    primaryColor: '#' + Math.floor(Math.random()*16777215).toString(16),
                    backgroundColor: 'rgba(100,100,100,0.1)',
                    progressPercent: 0
                }
            };
            this.zones.push(newZone);
            this.saveToLocalStorage();
            this.showToast('New zone added', 'success');
        },
        
        /**
         * Update status label
         */
        updateStatusLabel(code, label) {
            if (this.statusCodes[code]) {
                this.statusCodes[code].label = label;
            }
        },
        
        /**
         * Update status color
         */
        updateStatusColor(code, color) {
            if (this.statusCodes[code]) {
                this.statusCodes[code].color = color;
            }
        },
        
        /**
         * Reset status codes to default
         */
        resetStatusCodes() {
            const defaults = P5Store.getDefaultData().statusCodes;
            this.statusCodes = { ...defaults };
            this.saveToLocalStorage();
            this.showToast('Status codes reset', 'success');
        },
        
        /**
         * Save all settings
         */
        saveSettings() {
            this.saveToLocalStorage();
            this.showToast('Settings saved', 'success');
        },

        // ===== Phase 11: Slack Integration Methods =====

        /**
         * Load Slack settings from API
         */
        async loadSlackSettings() {
            if (!this.apiUrl) {
                this.slackSettings.message = 'API URL이 설정되지 않았습니다.';
                this.slackSettings.messageType = 'error';
                return;
            }

            try {
                const response = await fetch(`${this.apiUrl}?action=getSlackSettings`);
                const data = await response.json();

                if (data.success) {
                    this.slackSettings.webhookConfigured = data.webhookConfigured;
                    this.slackSettings.webhookUrlMasked = data.webhookUrlMasked || '';
                    if (data.settings) {
                        this.slackSettings.notifications = {
                            ...this.slackSettings.notifications,
                            ...data.settings
                        };
                    }
                    // Clear any new input - show masked URL instead
                    this.slackSettings.webhookUrl = '';
                    this.slackSettings.message = '';
                } else {
                    console.warn('[Slack] Failed to load settings:', data.error);
                }
            } catch (error) {
                console.error('[Slack] Error loading settings:', error);
                this.slackSettings.message = '설정을 불러오는 데 실패했습니다.';
                this.slackSettings.messageType = 'error';
            }
        },

        /**
         * Save Slack settings to API
         */
        async saveSlackSettings() {
            if (!this.apiUrl) {
                this.slackSettings.message = 'API URL이 설정되지 않았습니다.';
                this.slackSettings.messageType = 'error';
                return;
            }

            this.slackSettings.saving = true;
            this.slackSettings.message = '';

            try {
                const payload = {
                    action: 'saveSlackSettings',
                    settings: this.slackSettings.notifications
                };

                // Only include webhookUrl if user entered a new one
                if (this.slackSettings.webhookUrl) {
                    payload.webhookUrl = this.slackSettings.webhookUrl;
                }

                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success) {
                    this.slackSettings.message = 'Slack 설정이 저장되었습니다.';
                    this.slackSettings.messageType = 'success';
                    // Reload settings to get updated masked URL
                    await this.loadSlackSettings();
                    this.showToast('Slack 설정 저장 완료', 'success');
                } else {
                    this.slackSettings.message = data.error || '설정 저장에 실패했습니다.';
                    this.slackSettings.messageType = 'error';
                }
            } catch (error) {
                console.error('[Slack] Error saving settings:', error);
                this.slackSettings.message = '저장 중 오류가 발생했습니다: ' + error.message;
                this.slackSettings.messageType = 'error';
            } finally {
                this.slackSettings.saving = false;
            }
        },

        /**
         * Send Slack test notification
         */
        async testSlackNotification() {
            if (!this.apiUrl) {
                this.slackSettings.message = 'API URL이 설정되지 않았습니다.';
                this.slackSettings.messageType = 'error';
                return;
            }

            // Must have webhook configured or entered
            if (!this.slackSettings.webhookConfigured && !this.slackSettings.webhookUrl) {
                this.slackSettings.message = 'Webhook URL을 먼저 저장해주세요.';
                this.slackSettings.messageType = 'error';
                return;
            }

            this.slackSettings.testing = true;
            this.slackSettings.message = '';

            try {
                // If user entered new URL, save it first
                if (this.slackSettings.webhookUrl) {
                    await this.saveSlackSettings();
                }

                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'testSlackNotification' })
                });

                const data = await response.json();

                if (data.success) {
                    this.slackSettings.message = '테스트 알림이 전송되었습니다. Slack 채널을 확인해주세요.';
                    this.slackSettings.messageType = 'success';
                    this.showToast('Slack 테스트 알림 전송 완료', 'success');
                } else {
                    this.slackSettings.message = data.error || '테스트 알림 전송에 실패했습니다.';
                    this.slackSettings.messageType = 'error';
                }
            } catch (error) {
                console.error('[Slack] Error sending test notification:', error);
                this.slackSettings.message = '테스트 중 오류가 발생했습니다: ' + error.message;
                this.slackSettings.messageType = 'error';
            } finally {
                this.slackSettings.testing = false;
            }
        },

        /**
         * Clear Slack webhook URL
         */
        async clearSlackWebhook() {
            if (!confirm('Slack Webhook URL을 삭제하시겠습니까?\n삭제 후에는 알림이 전송되지 않습니다.')) {
                return;
            }

            this.slackSettings.saving = true;

            try {
                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'saveSlackSettings',
                        webhookUrl: ''  // Empty string to delete
                    })
                });

                const data = await response.json();

                if (data.success) {
                    this.slackSettings.webhookUrl = '';
                    this.slackSettings.webhookConfigured = false;
                    this.slackSettings.webhookUrlMasked = '';
                    this.slackSettings.message = 'Webhook URL이 삭제되었습니다.';
                    this.slackSettings.messageType = 'success';
                    this.showToast('Slack Webhook 삭제 완료', 'success');
                } else {
                    this.slackSettings.message = data.error || 'Webhook 삭제에 실패했습니다.';
                    this.slackSettings.messageType = 'error';
                }
            } catch (error) {
                console.error('[Slack] Error clearing webhook:', error);
                this.slackSettings.message = '삭제 중 오류가 발생했습니다.';
                this.slackSettings.messageType = 'error';
            } finally {
                this.slackSettings.saving = false;
            }
        },

        // ===== Phase 12: Email Integration Methods =====

        /**
         * Load email settings from server
         */
        async loadEmailSettings() {
            if (!this.apiUrl) {
                this.emailSettings.message = 'API URL이 설정되지 않았습니다.';
                this.emailSettings.messageType = 'error';
                return;
            }

            try {
                const response = await fetch(`${this.apiUrl}?action=getEmailSettings`);
                const data = await response.json();

                if (data.success) {
                    this.emailSettings.recipients = data.recipients || [];
                    if (data.settings) {
                        this.emailSettings.notifications = {
                            ...this.emailSettings.notifications,
                            ...data.settings
                        };
                    }
                    this.emailSettings.message = '';
                } else {
                    console.warn('[Email] Failed to load settings:', data.error);
                }
            } catch (error) {
                console.error('[Email] Error loading settings:', error);
                this.emailSettings.message = '설정을 불러오는 데 실패했습니다.';
                this.emailSettings.messageType = 'error';
            }
        },

        /**
         * Add email recipient
         */
        addEmailRecipient() {
            const email = this.emailSettings.newRecipient.trim().toLowerCase();

            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                this.emailSettings.message = '올바른 이메일 형식이 아닙니다.';
                this.emailSettings.messageType = 'error';
                return;
            }

            // Check for duplicates
            if (this.emailSettings.recipients.includes(email)) {
                this.emailSettings.message = '이미 등록된 이메일입니다.';
                this.emailSettings.messageType = 'error';
                return;
            }

            this.emailSettings.recipients.push(email);
            this.emailSettings.newRecipient = '';
            this.emailSettings.message = `${email} 추가됨 (저장 버튼을 눌러주세요)`;
            this.emailSettings.messageType = 'success';
        },

        /**
         * Remove email recipient by index
         */
        removeEmailRecipient(index) {
            const removed = this.emailSettings.recipients.splice(index, 1);
            this.emailSettings.message = `${removed[0]} 제거됨 (저장 버튼을 눌러주세요)`;
            this.emailSettings.messageType = 'success';
        },

        /**
         * Clear all email recipients
         */
        async clearAllEmailRecipients() {
            if (!confirm('모든 이메일 수신자를 삭제하시겠습니까?\n삭제 후에는 이메일 알림이 전송되지 않습니다.')) {
                return;
            }

            this.emailSettings.recipients = [];
            this.emailSettings.message = '모든 수신자가 제거되었습니다. 저장 버튼을 눌러주세요.';
            this.emailSettings.messageType = 'success';
        },

        /**
         * Save email settings to server
         */
        async saveEmailSettings() {
            if (!this.apiUrl) {
                this.emailSettings.message = 'API URL이 설정되지 않았습니다.';
                this.emailSettings.messageType = 'error';
                return;
            }

            this.emailSettings.saving = true;
            this.emailSettings.message = '';

            try {
                const payload = {
                    action: 'saveEmailSettings',
                    recipients: this.emailSettings.recipients,
                    settings: this.emailSettings.notifications
                };

                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success) {
                    this.emailSettings.message = `이메일 설정이 저장되었습니다. (${data.recipientCount}명)`;
                    this.emailSettings.messageType = 'success';
                    this.showToast('이메일 설정 저장 완료', 'success');
                } else {
                    this.emailSettings.message = data.error || '설정 저장에 실패했습니다.';
                    this.emailSettings.messageType = 'error';
                }
            } catch (error) {
                console.error('[Email] Error saving settings:', error);
                this.emailSettings.message = '저장 중 오류가 발생했습니다: ' + error.message;
                this.emailSettings.messageType = 'error';
            } finally {
                this.emailSettings.saving = false;
            }
        },

        /**
         * Send email test notification
         */
        async testEmailNotification() {
            if (!this.apiUrl) {
                this.emailSettings.message = 'API URL이 설정되지 않았습니다.';
                this.emailSettings.messageType = 'error';
                return;
            }

            if (this.emailSettings.recipients.length === 0) {
                this.emailSettings.message = '먼저 수신자를 추가하고 저장해주세요.';
                this.emailSettings.messageType = 'error';
                return;
            }

            this.emailSettings.testing = true;
            this.emailSettings.message = '';

            try {
                // First save current settings
                await this.saveEmailSettings();

                const response = await fetch(this.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'testEmailNotification' })
                });

                const data = await response.json();

                if (data.success) {
                    this.emailSettings.message = `테스트 이메일이 전송되었습니다. (${data.sentCount}명에게 발송)`;
                    this.emailSettings.messageType = 'success';
                    this.showToast('테스트 이메일 전송 완료', 'success');
                } else {
                    this.emailSettings.message = data.error || '테스트 이메일 전송에 실패했습니다.';
                    this.emailSettings.messageType = 'error';
                }
            } catch (error) {
                console.error('[Email] Error sending test notification:', error);
                this.emailSettings.message = '테스트 중 오류가 발생했습니다: ' + error.message;
                this.emailSettings.messageType = 'error';
            } finally {
                this.emailSettings.testing = false;
            }
        },

        /**
         * Export to CSV
         */
        exportToCSV() {
            const headers = ['UID', 'Zone', 'Row', 'Column', 'Status', 'IsLocked', 'UpdatedAt'];
            const rows = Object.values(this.columns).map(col => [
                col.uid,
                col.zone?.name || '',
                col.location?.row || '',
                col.location?.column || '',
                col.status?.code || 'pending',
                col.status?.isLocked || false,
                col.status?.updatedAt || ''
            ]);
            
            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `p5_columns_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            this.showToast('Exported to CSV', 'success');
        },
        
        /**
         * Export to Excel with SheetJS
         * WP-5: Now uses lazy-loaded libraries
         * @param {Object} options - Export options
         * @param {string} options.scope - 'all' | 'filtered' | 'selected' | 'floor' | 'zone'
         * @param {string} options.floorId - Floor ID for floor-specific export
         * @param {string} options.zoneId - Zone ID for zone-specific export
         */
        async exportToExcel(options = { scope: 'all' }) {
            // WP-5: Load export libraries on demand
            const loaded = await this.loadExportLibs();
            if (!loaded || typeof XLSX === 'undefined') {
                this.showToast('Excel 라이브러리 로드 실패. 페이지를 새로고침 후 다시 시도해주세요.', 'error');
                return;
            }

            try {
                // Show loading state
                this.isLoading = true;
                this.loadingMessage = 'Excel 파일 생성 중...';

                // Generate filename with timestamp
                const now = new Date();
                const timestamp = now.toISOString().replace(/[-:]/g, '').slice(0, 15);
                const filename = `P5_Dashboard_Export_${timestamp}.xlsx`;

                // Create workbook
                const wb = XLSX.utils.book_new();

                // Get data based on scope
                const columnsData = this.getExportColumnsData(options);
                const issuesData = this.getExportIssuesData(options);
                const summaryData = this.getExportSummaryData(columnsData, issuesData);

                // Sheet 1: Columns (기둥 현황)
                const columnsSheet = this.createColumnsSheet(columnsData);
                XLSX.utils.book_append_sheet(wb, columnsSheet, '기둥 현황');

                // Sheet 2: Issues (이슈 목록)
                const issuesSheet = this.createIssuesSheet(issuesData);
                XLSX.utils.book_append_sheet(wb, issuesSheet, '이슈 목록');

                // Sheet 3: Summary (요약 통계)
                const summarySheet = this.createSummarySheet(summaryData);
                XLSX.utils.book_append_sheet(wb, summarySheet, '요약 통계');

                // Sheet 4: Stage Progress (공정별 진행률) - optional
                const stageSheet = this.createStageProgressSheet(columnsData);
                XLSX.utils.book_append_sheet(wb, stageSheet, '공정별 진행률');

                // Download file
                XLSX.writeFile(wb, filename);

                this.showToast(`Excel 파일이 다운로드되었습니다: ${filename}`, 'success');
                console.log('[Excel Export] Success:', { scope: options.scope, columns: columnsData.length, issues: issuesData.length });

            } catch (error) {
                console.error('[Excel Export] Error:', error);
                this.showToast('Excel 내보내기 중 오류가 발생했습니다: ' + error.message, 'error');
            } finally {
                this.isLoading = false;
                this.loadingMessage = '';
            }
        },

        /**
         * Get columns data based on export scope
         */
        getExportColumnsData(options) {
            let columns = Object.values(this.columns);

            switch (options.scope) {
                case 'selected':
                    // Export only selected cells
                    const selectedUids = new Set(this.selectedCells.map(c => c.uid));
                    columns = columns.filter(c => selectedUids.has(c.uid));
                    break;

                case 'filtered':
                    // Export based on current filters (jeolju, workflow, search)
                    if (this.selectedJeolju) {
                        const jeolju = this.jeoljuList.find(j => j.jeoljuId === this.selectedJeolju);
                        if (jeolju) {
                            columns = columns.filter(c => {
                                const colNum = parseInt(c.location?.column);
                                return colNum >= jeolju.startColumn && colNum <= jeolju.endColumn;
                            });
                        }
                    }
                    if (this.workflowFilter) {
                        columns = columns.filter(c => c.stage?.code === this.workflowFilter);
                    }
                    break;

                case 'floor':
                    // Export specific floor
                    const floorId = options.floorId || this.selectedFloor;
                    columns = columns.filter(c => c.floor === floorId || c.floorId === floorId);
                    break;

                case 'zone':
                    // Export specific zone
                    if (options.zoneId) {
                        columns = columns.filter(c => c.zone?.id === options.zoneId);
                    }
                    break;

                case 'all':
                default:
                    // All columns - no filtering
                    break;
            }

            return columns;
        },

        /**
         * Get issues data based on export scope
         */
        getExportIssuesData(options) {
            let issues = [...this.issues];

            if (options.scope === 'selected' && this.selectedCells.length > 0) {
                const selectedUids = new Set(this.selectedCells.map(c => c.uid));
                issues = issues.filter(i =>
                    i.affectedColumns?.some(uid => selectedUids.has(uid)) ||
                    selectedUids.has(i.columnUid)
                );
            }

            return issues;
        },

        /**
         * Get summary statistics
         */
        getExportSummaryData(columnsData, issuesData) {
            const statusCounts = {};
            const stageCounts = {};

            columnsData.forEach(col => {
                const status = col.status?.code || 'pending';
                const stage = col.stage?.code || 'none';

                statusCounts[status] = (statusCounts[status] || 0) + 1;
                stageCounts[stage] = (stageCounts[stage] || 0) + 1;
            });

            const completedCount = statusCounts['installed'] || statusCounts['completed'] || 0;
            const progressRate = columnsData.length > 0
                ? Math.round((completedCount / columnsData.length) * 100)
                : 0;

            return {
                totalColumns: columnsData.length,
                statusCounts,
                stageCounts,
                progressRate,
                openIssues: issuesData.filter(i => i.status === 'open' || i.status === 'in_progress').length,
                resolvedIssues: issuesData.filter(i => i.status === 'resolved').length,
                criticalIssues: issuesData.filter(i => i.severity === 'critical').length,
                exportedAt: new Date().toISOString(),
                selectedFloor: this.selectedFloor,
                selectedJeolju: this.selectedJeolju
            };
        },

        /**
         * Create Columns sheet with formatting
         */
        createColumnsSheet(columnsData) {
            // Prepare data rows
            const rows = columnsData.map(col => ({
                'UID': col.uid || '',
                '층': col.floor || col.floorId || this.selectedFloor || '',
                '행(Row)': col.location?.row || '',
                '열(Column)': col.location?.column || '',
                'Zone': col.zone?.name || col.zone?.displayName || '',
                '상태(Status)': this.getStatusLabel(col.status?.code),
                '공정(Stage)': this.getStageLabel(col.stage?.code),
                '진행률(%)': col.progress || 0,
                '잠금': col.status?.isLocked ? 'Y' : 'N',
                '최종수정': col.status?.updatedAt || col.updatedAt || ''
            }));

            // Create worksheet
            const ws = XLSX.utils.json_to_sheet(rows);

            // Apply column widths
            ws['!cols'] = [
                { wch: 20 },  // UID
                { wch: 8 },   // 층
                { wch: 6 },   // 행
                { wch: 8 },   // 열
                { wch: 15 },  // Zone
                { wch: 12 },  // 상태
                { wch: 12 },  // 공정
                { wch: 10 },  // 진행률
                { wch: 6 },   // 잠금
                { wch: 20 }   // 최종수정
            ];

            // Apply header styling (SheetJS community edition - basic styling)
            this.applyHeaderStyle(ws, 10);

            return ws;
        },

        /**
         * Create Issues sheet with formatting
         */
        createIssuesSheet(issuesData) {
            const rows = issuesData.map(issue => ({
                'Issue ID': issue.id || '',
                '기둥 UID': issue.columnUid || (issue.affectedColumns?.join(', ') || ''),
                '유형': this.getIssueTypeLabel(issue.type),
                '심각도': this.getSeverityLabel(issue.severity),
                '상태': this.getIssueStatusLabel(issue.status),
                '제목': issue.title || '',
                '설명': issue.description || '',
                '담당자': issue.assignedTo || '',
                '생성일': issue.createdAt || '',
                '해결일': issue.resolvedAt || '',
                '근본원인': issue.rootCause || '',
                '조치계획': issue.mitigationPlan || ''
            }));

            const ws = XLSX.utils.json_to_sheet(rows);

            // Apply column widths
            ws['!cols'] = [
                { wch: 15 },  // Issue ID
                { wch: 25 },  // 기둥 UID
                { wch: 10 },  // 유형
                { wch: 10 },  // 심각도
                { wch: 10 },  // 상태
                { wch: 30 },  // 제목
                { wch: 40 },  // 설명
                { wch: 12 },  // 담당자
                { wch: 18 },  // 생성일
                { wch: 18 },  // 해결일
                { wch: 30 },  // 근본원인
                { wch: 30 }   // 조치계획
            ];

            this.applyHeaderStyle(ws, 12);

            return ws;
        },

        /**
         * Create Summary sheet
         */
        createSummarySheet(summaryData) {
            const rows = [
                { '항목': '전체 기둥 수', '값': summaryData.totalColumns },
                { '항목': '진행률 (%)', '값': summaryData.progressRate + '%' },
                { '항목': '', '값': '' },
                { '항목': '=== 상태별 현황 ===', '값': '' }
            ];

            // Add status counts
            Object.entries(summaryData.statusCounts).forEach(([status, count]) => {
                rows.push({ '항목': this.getStatusLabel(status), '값': count });
            });

            rows.push({ '항목': '', '값': '' });
            rows.push({ '항목': '=== 공정별 현황 ===', '값': '' });

            // Add stage counts
            Object.entries(summaryData.stageCounts).forEach(([stage, count]) => {
                rows.push({ '항목': this.getStageLabel(stage), '값': count });
            });

            rows.push({ '항목': '', '값': '' });
            rows.push({ '항목': '=== 이슈 현황 ===', '값': '' });
            rows.push({ '항목': '진행중 이슈', '값': summaryData.openIssues });
            rows.push({ '항목': '해결된 이슈', '값': summaryData.resolvedIssues });
            rows.push({ '항목': 'Critical 이슈', '값': summaryData.criticalIssues });

            rows.push({ '항목': '', '값': '' });
            rows.push({ '항목': '=== 내보내기 정보 ===', '값': '' });
            rows.push({ '항목': '내보내기 시간', '값': new Date(summaryData.exportedAt).toLocaleString('ko-KR') });
            rows.push({ '항목': '선택된 층', '값': summaryData.selectedFloor || 'ALL' });
            rows.push({ '항목': '선택된 절주', '값': summaryData.selectedJeolju || 'ALL' });

            const ws = XLSX.utils.json_to_sheet(rows);

            ws['!cols'] = [
                { wch: 25 },  // 항목
                { wch: 30 }   // 값
            ];

            this.applyHeaderStyle(ws, 2);

            return ws;
        },

        /**
         * Create Stage Progress sheet
         */
        createStageProgressSheet(columnsData) {
            const stageProgress = {};

            // Calculate progress per stage
            this.stageConfigs.forEach(stage => {
                const stageColumns = columnsData.filter(c => c.stage?.code === stage.code);
                const total = stageColumns.length;
                const completed = stageColumns.filter(c =>
                    c.status?.code === 'installed' || c.status?.code === 'completed'
                ).length;

                stageProgress[stage.code] = {
                    label: stage.label,
                    total,
                    completed,
                    rate: total > 0 ? Math.round((completed / total) * 100) : 0
                };
            });

            const rows = Object.entries(stageProgress).map(([code, data]) => ({
                '공정코드': code,
                '공정명': data.label,
                '전체': data.total,
                '완료': data.completed,
                '진행률(%)': data.rate
            }));

            const ws = XLSX.utils.json_to_sheet(rows);

            ws['!cols'] = [
                { wch: 15 },  // 공정코드
                { wch: 15 },  // 공정명
                { wch: 10 },  // 전체
                { wch: 10 },  // 완료
                { wch: 12 }   // 진행률
            ];

            this.applyHeaderStyle(ws, 5);

            return ws;
        },

        /**
         * Apply header styling (basic - SheetJS community edition)
         */
        applyHeaderStyle(ws, numCols) {
            // Get header range
            const range = XLSX.utils.decode_range(ws['!ref']);

            // Note: Full styling requires SheetJS Pro or xlsx-style
            // For community edition, we can set basic properties
            // Styling will be applied when the user opens in Excel

            // Add autofilter to header row
            ws['!autofilter'] = { ref: ws['!ref'] };
        },

        /**
         * Get human-readable status label
         */
        getStatusLabel(code) {
            const labels = {
                'pending': '대기',
                'in_progress': '진행중',
                'completed': '완료',
                'installed': '설치완료',
                'delay': '지연',
                'blocked': '차단',
                'hold': '보류',
                'tc_hold': 'TC 보류',
                'ok': '정상',
                'shipping': '출하중',
                'design': '설계중'
            };
            return labels[code] || code || '-';
        },

        /**
         * Get human-readable stage label
         */
        getStageLabel(code) {
            const stage = this.stageConfigs.find(s => s.code === code);
            return stage?.label || code || '-';
        },

        /**
         * Get human-readable issue type label
         */
        getIssueTypeLabel(type) {
            const labels = {
                'tc': 'TC 이슈',
                'design': '설계 이슈',
                'delay': '지연',
                'quality': '품질',
                'safety': '안전',
                'other': '기타'
            };
            return labels[type] || type || '-';
        },

        /**
         * Get human-readable severity label
         */
        getSeverityLabel(severity) {
            const labels = {
                'critical': '심각',
                'high': '높음',
                'medium': '보통',
                'low': '낮음'
            };
            return labels[severity] || severity || '-';
        },

        /**
         * Get human-readable issue status label
         */
        getIssueStatusLabel(status) {
            const labels = {
                'open': '진행중',
                'in_progress': '처리중',
                'resolved': '해결됨',
                'closed': '종료'
            };
            return labels[status] || status || '-';
        },

        /**
         * Export with specific options - UI helper
         */
        exportExcelWithOptions(scope) {
            this.exportToExcel({ scope });
        },

        // ===== PDF Report Generation =====

        /**
         * PDF Report Modal State
         */
        pdfReportModalOpen: false,
        pdfReportType: 'summary', // 'summary' | 'detailed' | 'issues'
        pdfGenerating: false,

        /**
         * Open PDF Report Modal
         */
        openPdfReportModal() {
            this.pdfReportModalOpen = true;
            this.pdfReportType = 'summary';
        },

        /**
         * Close PDF Report Modal
         */
        closePdfReportModal() {
            this.pdfReportModalOpen = false;
        },

        /**
         * Generate PDF Report
         * WP-1-A: Uses external PdfGenerator module
         * @param {string} type - Report type: 'summary' | 'detailed' | 'issues'
         */
        async generatePDFReport(type = 'summary') {
            // Load export libraries on demand
            const loaded = await this.loadExportLibs();
            if (!loaded || typeof window.jspdf === 'undefined') {
                this.showToast('PDF 라이브러리 로드 실패. 페이지를 새로고침 후 다시 시도해주세요.', 'error');
                return;
            }

            this.pdfGenerating = true;
            this.showToast('PDF 보고서 생성 중...', 'info');

            try {
                // WP-1-A: Call external PdfGenerator module
                const result = window.PdfGenerator.generatePdfReport(type, {
                    columns: this.columns,
                    issues: this.issues,
                    zones: this.zones,
                    statusCodes: this.statusCodes,
                    selectedFloor: this.selectedFloor,
                    selectedJeolju: this.selectedJeolju
                });

                if (result.success) {
                    this.showToast(`PDF 보고서가 생성되었습니다: ${result.filename}`, 'success');
                    this.pdfReportModalOpen = false;
                } else {
                    this.showToast('PDF 생성 중 오류가 발생했습니다: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('[PDF Report] Error:', error);
                this.showToast('PDF 생성 중 오류가 발생했습니다: ' + error.message, 'error');
            } finally {
                this.pdfGenerating = false;
            }
        },

        // WP-1-A: PDF helper functions moved to js/utils/pdf-generator.js
        // addPdfCoverPage, addPdfSummaryPage moved to external module

        /**
         * @deprecated WP-1-A: Moved to external PdfGenerator module
         * Keeping stub for reference - see js/utils/pdf-generator.js
         */
        _pdfHelpersMoved() {
            // PDF generation functions moved to window.PdfGenerator:
            // - addPdfCoverPage()
            // - addPdfSummaryPage()
            // - calculateFloorProgress()
            // - addPdfDetailedPages()
            // - addPdfIssuesPage()
            // - addPdfPageNumbers()
        },

        // WP-1-A: calculateFloorProgress() moved to js/utils/pdf-generator.js

        /**
         * @deprecated WP-1-A: Moved to PdfGenerator module
         * Add Detailed Floor Pages to PDF
         */
        _addPdfDetailedPages_REMOVED(doc, margin, contentWidth) {
            const floorIds = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'RF'];
            const pageWidth = doc.internal.pageSize.getWidth();

            floorIds.forEach(floorId => {
                doc.addPage();
                let yPos = 20;

                // Page header
                doc.setFillColor(31, 111, 235);
                doc.rect(0, 0, pageWidth, 15, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(12);
                doc.text(`${floorId} 층 상세 현황`, margin, 10);

                yPos = 25;

                // Get floor columns
                const floorColumns = Object.values(this.columns).filter(c =>
                    c.floor === floorId || c.floorId === floorId
                );

                // Zone-based summary
                doc.setTextColor(60, 60, 60);
                doc.setFontSize(10);
                doc.text('Zone별 현황', margin, yPos);
                yPos += 6;

                const zoneData = this.zones.map(zone => {
                    const zoneCols = floorColumns.filter(c => c.zone?.id === zone.id || c.zoneId === zone.id);
                    const completed = zoneCols.filter(c => c.status === 'installed').length;
                    const active = zoneCols.filter(c => c.status === 'active').length;
                    const hold = zoneCols.filter(c => c.status === 'hold_tc' || c.status === 'hold_design').length;
                    const blocked = zoneCols.filter(c => c.status === 'hold_tc').length;

                    return [
                        zone.name || zone.id,
                        zoneCols.length.toString(),
                        completed.toString(),
                        active.toString(),
                        hold.toString(),
                        blocked.toString()
                    ];
                });

                doc.autoTable({
                    startY: yPos,
                    head: [['Zone', '전체', '완료', '진행중', '지연', '블록']],
                    body: zoneData,
                    margin: { left: margin, right: margin },
                    headStyles: { fillColor: [31, 111, 235], fontSize: 8 },
                    bodyStyles: { fontSize: 8 },
                    alternateRowStyles: { fillColor: [248, 249, 250] }
                });

                yPos = doc.lastAutoTable.finalY + 12;

                // Stage-based progress
                doc.setTextColor(60, 60, 60);
                doc.setFontSize(10);
                doc.text('공정(Stage)별 진행률', margin, yPos);
                yPos += 6;

                const stages = ['FA', 'SB', 'TC', 'TB', 'WD', 'CP'];
                const stageLabels = {
                    'FA': '철골(FA)',
                    'SB': '데크(SB)',
                    'TC': 'T/C 설치(TC)',
                    'TB': 'T/B 설치(TB)',
                    'WD': '용접(WD)',
                    'CP': '완료(CP)'
                };

                const stageData = stages.map(stage => {
                    const stageComplete = floorColumns.filter(c => {
                        const stageStatus = c.stages?.[stage];
                        return stageStatus === 'complete' || stageStatus === 'installed';
                    }).length;
                    const progress = floorColumns.length > 0
                        ? ((stageComplete / floorColumns.length) * 100).toFixed(1)
                        : '0.0';
                    return [stageLabels[stage] || stage, stageComplete.toString(), progress + '%'];
                });

                doc.autoTable({
                    startY: yPos,
                    head: [['공정', '완료', '진행률']],
                    body: stageData,
                    margin: { left: margin, right: margin },
                    headStyles: { fillColor: [35, 134, 54], fontSize: 8 },
                    bodyStyles: { fontSize: 8 },
                    alternateRowStyles: { fillColor: [248, 249, 250] },
                    tableWidth: 100
                });

                // Floor Issues Summary
                const floorIssues = this.issues.filter(issue =>
                    issue.floorId === floorId || issue.floor === floorId
                );

                if (floorIssues.length > 0) {
                    yPos = doc.lastAutoTable.finalY + 12;
                    doc.setTextColor(60, 60, 60);
                    doc.setFontSize(10);
                    doc.text(`이슈 현황 (${floorIssues.length}건)`, margin, yPos);
                    yPos += 6;

                    const issueData = floorIssues.slice(0, 10).map(issue => [
                        issue.id?.slice(-6) || '-',
                        this.getSeverityLabel(issue.severity),
                        (issue.title || issue.description || '-').slice(0, 30),
                        this.getIssueStatusLabel(issue.status)
                    ]);

                    doc.autoTable({
                        startY: yPos,
                        head: [['ID', '심각도', '제목', '상태']],
                        body: issueData,
                        margin: { left: margin, right: margin },
                        headStyles: { fillColor: [218, 54, 51], fontSize: 8 },
                        bodyStyles: { fontSize: 7 },
                        alternateRowStyles: { fillColor: [248, 249, 250] }
                    });
                }
            });
        },

        /**
         * Add Issues Page to PDF
         */
        addPdfIssuesPage(doc, margin, contentWidth) {
            const pageWidth = doc.internal.pageSize.getWidth();
            let yPos = 20;

            // Page header
            doc.setFillColor(218, 54, 51); // Red for issues
            doc.rect(0, 0, pageWidth, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.text('이슈 요약', margin, 10);

            yPos = 25;

            // Issue statistics
            const openIssues = this.issues.filter(i => i.status === 'open');
            const inProgressIssues = this.issues.filter(i => i.status === 'in_progress');
            const resolvedIssues = this.issues.filter(i => i.status === 'resolved');
            const criticalIssues = this.issues.filter(i => i.severity === 'critical');
            const highIssues = this.issues.filter(i => i.severity === 'high');

            doc.setTextColor(60, 60, 60);
            doc.setFontSize(10);
            doc.text('이슈 통계', margin, yPos);
            yPos += 6;

            const statsData = [
                ['전체 이슈', this.issues.length.toString()],
                ['미해결 (Open)', openIssues.length.toString()],
                ['처리중 (In Progress)', inProgressIssues.length.toString()],
                ['해결됨 (Resolved)', resolvedIssues.length.toString()],
                ['Critical 등급', criticalIssues.length.toString()],
                ['High 등급', highIssues.length.toString()]
            ];

            doc.autoTable({
                startY: yPos,
                head: [['항목', '건수']],
                body: statsData,
                margin: { left: margin, right: margin },
                headStyles: { fillColor: [218, 54, 51], fontSize: 9 },
                bodyStyles: { fontSize: 9 },
                tableWidth: 100
            });

            yPos = doc.lastAutoTable.finalY + 15;

            // Severity distribution
            doc.setTextColor(60, 60, 60);
            doc.setFontSize(10);
            doc.text('심각도별 분포', margin, yPos);
            yPos += 6;

            const severityCounts = {};
            this.issues.forEach(issue => {
                const sev = issue.severity || 'low';
                severityCounts[sev] = (severityCounts[sev] || 0) + 1;
            });

            const severityData = [
                ['Critical (긴급)', (severityCounts['critical'] || 0).toString()],
                ['High (높음)', (severityCounts['high'] || 0).toString()],
                ['Medium (보통)', (severityCounts['medium'] || 0).toString()],
                ['Low (낮음)', (severityCounts['low'] || 0).toString()]
            ];

            doc.autoTable({
                startY: yPos,
                head: [['심각도', '건수']],
                body: severityData,
                margin: { left: margin, right: margin },
                headStyles: { fillColor: [210, 153, 34], fontSize: 9 },
                bodyStyles: { fontSize: 9 },
                tableWidth: 100
            });

            yPos = doc.lastAutoTable.finalY + 15;

            // Unresolved issues list
            const unresolvedIssues = this.issues.filter(i =>
                i.status !== 'resolved' && i.status !== 'closed'
            );

            if (unresolvedIssues.length > 0) {
                doc.setTextColor(60, 60, 60);
                doc.setFontSize(10);
                doc.text(`미해결 이슈 목록 (${unresolvedIssues.length}건)`, margin, yPos);
                yPos += 6;

                const issueTableData = unresolvedIssues.slice(0, 20).map(issue => [
                    issue.id?.slice(-8) || '-',
                    issue.floorId || issue.floor || '-',
                    this.getSeverityLabel(issue.severity),
                    (issue.title || issue.description || '-').slice(0, 25),
                    this.getIssueStatusLabel(issue.status),
                    issue.createdAt ? new Date(issue.createdAt).toLocaleDateString('ko-KR') : '-'
                ]);

                doc.autoTable({
                    startY: yPos,
                    head: [['ID', '층', '심각도', '제목', '상태', '생성일']],
                    body: issueTableData,
                    margin: { left: margin, right: margin },
                    headStyles: { fillColor: [218, 54, 51], fontSize: 7 },
                    bodyStyles: { fontSize: 7 },
                    alternateRowStyles: { fillColor: [248, 249, 250] },
                    columnStyles: {
                        0: { cellWidth: 22 },
                        1: { cellWidth: 15 },
                        2: { cellWidth: 20 },
                        3: { cellWidth: 50 },
                        4: { cellWidth: 20 },
                        5: { cellWidth: 25 }
                    }
                });

                if (unresolvedIssues.length > 20) {
                    const remaining = unresolvedIssues.length - 20;
                    doc.setFontSize(8);
                    doc.setTextColor(100, 100, 100);
                    doc.text(`... 외 ${remaining}건`, margin, doc.lastAutoTable.finalY + 8);
                }
            }
        },

        /**
         * Get severity label in Korean
         */
        getSeverityLabel(severity) {
            const labels = {
                'critical': '긴급',
                'high': '높음',
                'medium': '보통',
                'low': '낮음'
            };
            return labels[severity] || severity || '-';
        },

        /**
         * Add page numbers to all pages
         */
        addPdfPageNumbers(doc) {
            const totalPages = doc.internal.getNumberOfPages();
            const pageHeight = doc.internal.pageSize.getHeight();
            const pageWidth = doc.internal.pageSize.getWidth();

            for (let i = 1; i <= totalPages; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(150, 150, 150);

                // Page number
                doc.text(`${i} / ${totalPages}`, pageWidth / 2, pageHeight - 8, { align: 'center' });

                // Footer line
                doc.setDrawColor(200, 200, 200);
                doc.line(15, pageHeight - 12, pageWidth - 15, pageHeight - 12);

                // Generation timestamp on first page footer
                if (i > 1) {
                    doc.text('P5 Dashboard Report', 15, pageHeight - 8);
                    doc.text(new Date().toLocaleDateString('ko-KR'), pageWidth - 15, pageHeight - 8, { align: 'right' });
                }
            }
        },

        /**
         * Handle file import
         */
        handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            this.processImportFile(file);
        },
        
        /**
         * Handle file drop
         */
        handleFileDrop(event) {
            event.target.classList.remove('dragover');
            const file = event.dataTransfer.files[0];
            if (file) this.processImportFile(file);
        },
        
        // ===== MGT Import Handlers =====
        
        /**
         * Handle MGT file input change
         */
        handleMgtImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            this.processMgtFile(file);
        },
        
        /**
         * Handle MGT file drop
         */
        handleMgtDrop(event) {
            event.target.classList.remove('dragover');
            const file = event.dataTransfer.files[0];
            if (file && file.name.endsWith('.mgt')) {
                this.processMgtFile(file);
            } else {
                this.showToast('MGT 파일만 지원됩니다', 'error');
            }
        },
        
        /**
         * Process MGT file
         */
        async processMgtFile(file) {
            this.mgtImportStatus = {
                loading: true,
                success: false,
                message: 'MGT 파일 읽는 중...',
                nodes: 0,
                elements: 0,
                cols: 0,
                rows: 0,
                excludedCols: [],
                parsedData: null
            };
            
            try {
                const content = await file.text();
                this.mgtImportStatus.message = '노드 데이터 파싱 중...';
                
                // Parse MGT inline (simplified version of mgt-parser.js)
                const parsed = this.parseMgtContent(content);
                
                this.mgtImportStatus = {
                    loading: false,
                    success: true,
                    message: '파싱 완료',
                    nodes: parsed.meta.totalNodes,
                    elements: parsed.meta.totalElements,
                    cols: parsed.gridConfig.cols,
                    rows: parsed.gridConfig.rows,
                    floors: parsed.gridConfig.floors,
                    excludedCols: parsed.gridConfig.excludedColumns,
                    parsedData: parsed
                };
                
                this.showToast(`MGT 파싱 완료: ${parsed.meta.totalNodes}개 노드, ${parsed.gridConfig.floors}개 층`, 'success');
                
            } catch (err) {
                this.mgtImportStatus.loading = false;
                this.mgtImportStatus.success = false;
                this.showToast('MGT 파싱 실패: ' + err.message, 'error');
            }
        },
        
        /**
         * Parse MGT content (inline parser)
         */
        parseMgtContent(content) {
            const lines = content.split('\n');
            const nodes = [];
            const elements = [];
            let inNodeSection = false;
            let inElementSection = false;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Section detection
                if (trimmed.startsWith('*NODE')) {
                    inNodeSection = true;
                    inElementSection = false;
                    continue;
                }
                if (trimmed.startsWith('*ELEMENT')) {
                    inNodeSection = false;
                    inElementSection = true;
                    continue;
                }
                if (trimmed.startsWith('*') && !trimmed.startsWith(';')) {
                    inNodeSection = false;
                    inElementSection = false;
                    continue;
                }
                
                // Parse nodes
                if (inNodeSection && /^\s*\d+/.test(trimmed)) {
                    const parts = trimmed.split(',').map(p => p.trim());
                    if (parts.length >= 4) {
                        const id = parseInt(parts[0]);
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);
                        const z = parseFloat(parts[3]);
                        if (!isNaN(id) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            nodes.push({ id, x, y, z });
                        }
                    }
                }
                
                // Parse elements
                if (inElementSection && /^\s*\d+/.test(trimmed)) {
                    const parts = trimmed.split(',').map(p => p.trim());
                    if (parts.length >= 6) {
                        const id = parseInt(parts[0]);
                        const type = parts[1].replace(/\s+/g, '');
                        const n1 = parseInt(parts[4]);
                        const n2 = parseInt(parts[5]);
                        if (!isNaN(id)) {
                            elements.push({ id, type, nodes: [n1, n2] });
                        }
                    }
                }
            }
            
            // Calculate grid config
            const xValues = [...new Set(nodes.map(n => n.x))].sort((a, b) => a - b);
            const yValues = [...new Set(nodes.map(n => n.y))].sort((a, b) => a - b);
            const zValues = [...new Set(nodes.map(n => n.z))].sort((a, b) => a - b);
            
            const minX = xValues[0] || 0;
            const excludedColumns = minX > 15 ? [1, 2] : [];
            
            // Generate floor mapping from Z values (F01~F10, RF)
            const floorLabels = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'RF'];
            const floorMapping = {};
            zValues.forEach((z, idx) => {
                // Use predefined labels for first 11 floors, then generate dynamically
                const floorId = idx < floorLabels.length ? floorLabels[idx] : `F${String(idx + 1).padStart(2, '0')}`;
                floorMapping[z] = floorId;
            });
            
            return {
                nodes,
                elements,
                gridConfig: {
                    cols: xValues.length,
                    rows: yValues.length,
                    floors: zValues.length,
                    excludedColumns,
                    xValues,
                    yValues,
                    zValues,
                    floorMapping
                },
                meta: {
                    totalNodes: nodes.length,
                    totalElements: elements.length,
                    parsedAt: new Date().toISOString()
                }
            };
        },
        
        /**
         * Apply parsed MGT config to dashboard
         */
        applyMgtConfig() {
            const parsed = this.mgtImportStatus.parsedData;
            if (!parsed) {
                this.showToast('적용할 데이터가 없습니다', 'error');
                return;
            }
            
            // Update grid config
            this.gridConfig.cols = parsed.gridConfig.cols;
            this.gridConfig.rows = parsed.gridConfig.rows;
            
            // Generate floors from Z values (F01~RF)
            const { zValues, floorMapping } = parsed.gridConfig;
            const floorLabels = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'RF'];
            this.floors = zValues.map((z, idx) => ({
                floorId: floorMapping[z],
                label: floorLabels[idx] || `F${String(idx + 1).padStart(2, '0')}`,
                zLevel: z,
                hasVariation: false,
                columnSize: '' // Can be populated later with actual section data
            }));
            
            // Update selected floor to first available
            if (this.floors.length > 0) {
                this.selectedFloor = this.floors[0].floorId;
                this.currentFloorLabel = this.floors[0].label;
            }
            
            // Generate zones from parsed data
            const totalCols = parsed.gridConfig.cols;
            const zoneSize = Math.ceil(totalCols / 3);
            
            this.zones = [
                {
                    id: 'zone_a',
                    name: 'ZONE A',
                    displayName: 'FAB',
                    description: 'Utility Support',
                    range: { startColumn: 3, endColumn: 3 + zoneSize - 1, startRow: 0, endRow: parsed.gridConfig.rows - 1 },
                    style: { primaryColor: '#238636', backgroundColor: 'rgba(35, 134, 54, 0.1)' }
                },
                {
                    id: 'zone_b',
                    name: 'ZONE B',
                    displayName: 'CUB',
                    description: 'Main Link',
                    range: { startColumn: 3 + zoneSize, endColumn: 3 + zoneSize * 2 - 1, startRow: 0, endRow: parsed.gridConfig.rows - 1 },
                    style: { primaryColor: '#1f6feb', backgroundColor: 'rgba(31, 111, 235, 0.1)' }
                },
                {
                    id: 'zone_c',
                    name: 'ZONE C',
                    displayName: 'COMPLEX',
                    description: 'Office/Amenity - 복합동',
                    range: { startColumn: 3 + zoneSize * 2, endColumn: totalCols + 2, startRow: 0, endRow: parsed.gridConfig.rows - 1 },
                    style: { primaryColor: '#d29922', backgroundColor: 'rgba(210, 153, 34, 0.1)' }
                }
            ];
            
            // Save to local storage
            this.saveToLocalStorage();
            
            // Reset import status
            this.mgtImportStatus.success = false;
            this.mgtImportStatus.parsedData = null;
            
            // Close admin panel
            this.showAdminPanel = false;
            
            const floorCount = this.floors.length;
            this.showToast(`그리드 설정 적용 완료: ${totalCols}열 × ${parsed.gridConfig.rows}행, ${floorCount}개 층`, 'success');
            console.log('[MGT] Config applied:', { cols: totalCols, rows: parsed.gridConfig.rows, floors: floorCount, zones: this.zones.length });
        },
        
        /**
         * Phase 8: Process imported file - shows preview before applying
         */
        processImportFile(file) {
            // File size check (5MB max)
            if (file.size > 5 * 1024 * 1024) {
                this.showToast('파일 크기가 5MB를 초과합니다', 'error');
                return;
            }

            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    // Reset import preview state
                    this.importPreview = {
                        fileName: file.name,
                        fileType: file.name.endsWith('.json') ? 'json' : 'csv',
                        rawData: e.target.result,
                        parsedData: [],
                        headers: [],
                        columnMapping: { uid: '', status: '', isLocked: '' },
                        stats: { total: 0, new: 0, update: 0, errors: 0 },
                        errors: [],
                        mode: 'update'
                    };

                    if (file.name.endsWith('.json')) {
                        this.parseJsonForPreview(e.target.result);
                    } else if (file.name.endsWith('.csv')) {
                        this.parseCsvForPreview(e.target.result);
                    } else {
                        this.showToast('지원하지 않는 파일 형식입니다', 'error');
                        return;
                    }

                    // Show preview modal
                    this.showImportPreview = true;
                } catch (err) {
                    this.showToast('파일 파싱 실패: ' + err.message, 'error');
                }
            };

            reader.readAsText(file);
        },

        /**
         * Phase 8: Parse JSON data for preview
         */
        parseJsonForPreview(jsonText) {
            const data = JSON.parse(jsonText);
            this.importPreview.rawData = data;

            // Parse columns
            if (data.columns) {
                const columnData = Object.values(data.columns);
                let newCount = 0, updateCount = 0;

                this.importPreview.parsedData = columnData.map(col => {
                    const exists = this.columns[col.uid];
                    if (exists) {
                        updateCount++;
                        col._importStatus = 'update';
                    } else {
                        newCount++;
                        col._importStatus = 'new';
                    }
                    return col;
                });

                this.importPreview.stats = {
                    total: columnData.length,
                    new: newCount,
                    update: updateCount,
                    errors: 0
                };
            } else {
                this.importPreview.errors.push('JSON에 columns 필드가 없습니다');
                this.importPreview.stats.errors = 1;
            }
        },

        /**
         * Phase 8: Parse CSV data for preview
         */
        parseCsvForPreview(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                this.importPreview.errors.push('CSV에 데이터가 없습니다');
                this.importPreview.stats.errors = 1;
                return;
            }

            // Parse headers
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            this.importPreview.headers = headers;

            // Auto-detect column mapping
            const uidIdx = headers.findIndex(h => h.toLowerCase() === 'uid');
            const statusIdx = headers.findIndex(h => h.toLowerCase() === 'status');
            const lockIdx = headers.findIndex(h => h.toLowerCase() === 'islocked');

            this.importPreview.columnMapping = {
                uid: uidIdx >= 0 ? headers[uidIdx] : '',
                status: statusIdx >= 0 ? headers[statusIdx] : '',
                isLocked: lockIdx >= 0 ? headers[lockIdx] : ''
            };

            // Parse data rows
            let newCount = 0, updateCount = 0, errorCount = 0;
            const parsedData = [];

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                const rowObj = {};

                headers.forEach((h, idx) => {
                    rowObj[h] = values[idx] || '';
                });

                // Determine import status
                const uid = uidIdx >= 0 ? values[uidIdx] : null;
                if (!uid) {
                    rowObj._importStatus = 'error';
                    errorCount++;
                    this.importPreview.errors.push(`행 ${i}: UID가 없습니다`);
                } else if (this.columns[uid]) {
                    rowObj._importStatus = 'update';
                    updateCount++;
                } else {
                    rowObj._importStatus = 'new';
                    newCount++;
                }

                parsedData.push(rowObj);
            }

            this.importPreview.parsedData = parsedData;
            this.importPreview.stats = {
                total: parsedData.length,
                new: newCount,
                update: updateCount,
                errors: errorCount
            };
        },

        /**
         * Phase 8: Recalculate import stats when mapping changes
         */
        recalculateImportStats() {
            if (this.importPreview.fileType !== 'csv') return;

            const uidHeader = this.importPreview.columnMapping.uid;
            if (!uidHeader) {
                this.importPreview.stats = { total: this.importPreview.parsedData.length, new: 0, update: 0, errors: this.importPreview.parsedData.length };
                this.importPreview.errors = ['UID 컬럼을 선택해주세요'];
                return;
            }

            let newCount = 0, updateCount = 0, errorCount = 0;
            this.importPreview.errors = [];

            this.importPreview.parsedData.forEach((row, idx) => {
                const uid = row[uidHeader];
                if (!uid) {
                    row._importStatus = 'error';
                    errorCount++;
                    if (this.importPreview.errors.length < 10) {
                        this.importPreview.errors.push(`행 ${idx + 2}: UID가 비어있습니다`);
                    }
                } else if (this.columns[uid]) {
                    row._importStatus = 'update';
                    updateCount++;
                } else {
                    row._importStatus = 'new';
                    newCount++;
                }
            });

            this.importPreview.stats = {
                total: this.importPreview.parsedData.length,
                new: newCount,
                update: updateCount,
                errors: errorCount
            };
        },

        /**
         * Phase 8: Execute the import based on preview settings
         */
        executeImport() {
            const mode = this.importPreview.mode;
            const fileType = this.importPreview.fileType;
            let imported = 0, created = 0;

            if (fileType === 'json') {
                const data = this.importPreview.rawData;

                if (mode === 'replace') {
                    // Replace all columns
                    this.columns = data.columns || {};
                    imported = Object.keys(this.columns).length;
                } else {
                    // Update/Merge
                    Object.entries(data.columns || {}).forEach(([uid, col]) => {
                        if (mode === 'update' && !this.columns[uid]) return;

                        if (this.columns[uid]) {
                            Object.assign(this.columns[uid], col);
                            imported++;
                        } else if (mode === 'merge') {
                            this.columns[uid] = col;
                            created++;
                        }
                    });
                }

                // Also import zones if present
                if (data.zones && (mode === 'replace' || mode === 'merge')) {
                    this.zones = data.zones;
                }
            } else if (fileType === 'csv') {
                const uidHeader = this.importPreview.columnMapping.uid;
                const statusHeader = this.importPreview.columnMapping.status;
                const lockHeader = this.importPreview.columnMapping.isLocked;

                if (!uidHeader) {
                    this.showToast('UID 컬럼을 선택해주세요', 'error');
                    return;
                }

                this.importPreview.parsedData.forEach(row => {
                    const uid = row[uidHeader];
                    if (!uid) return;

                    if (this.columns[uid]) {
                        // Update existing
                        if (statusHeader && row[statusHeader]) {
                            this.columns[uid].status.code = row[statusHeader];
                        }
                        if (lockHeader && row[lockHeader] !== undefined) {
                            this.columns[uid].status.isLocked = row[lockHeader] === 'true' || row[lockHeader] === true;
                        }
                        this.columns[uid].status.updatedAt = new Date().toISOString();
                        imported++;
                    } else if (mode === 'merge') {
                        // Create new (basic structure)
                        const [rowLabel, colPart] = uid.split('-X');
                        const colNum = parseInt(colPart);

                        this.columns[uid] = {
                            uid: uid,
                            location: { row: rowLabel, column: colNum },
                            status: {
                                code: statusHeader && row[statusHeader] ? row[statusHeader] : 'pending',
                                isLocked: lockHeader ? (row[lockHeader] === 'true') : false,
                                updatedAt: new Date().toISOString()
                            }
                        };
                        created++;
                    }
                });
            }

            this.saveToLocalStorage();
            this.isDirty = true;
            this.showImportPreview = false;

            const message = mode === 'merge'
                ? `가져오기 완료: ${imported}건 업데이트, ${created}건 생성`
                : `가져오기 완료: ${imported}건 업데이트`;
            this.showToast(message, 'success');
        },

        // Legacy import functions for backward compatibility
        importJsonData(data) {
            this.importPreview.rawData = data;
            this.importPreview.mode = 'update';
            this.executeImport();
        },

        importCsvData(csvText) {
            this.parseCsvForPreview(csvText);
            this.importPreview.mode = 'update';
            this.executeImport();
        },
        
        /**
         * Test API connection
         */
        async testApiConnection() {
            if (!this.apiUrl) return;
            
            this.showToast('Testing connection...', 'success');
            
            try {
                const response = await fetch(this.apiUrl + '?action=getZones');
                const data = await response.json();
                
                if (data.success) {
                    this.showToast('Connection successful!', 'success');
                } else {
                    this.showToast('API error: ' + (data.error || 'Unknown'), 'error');
                }
            } catch (err) {
                this.showToast('Connection failed: ' + err.message, 'error');
            }
        },
        
        /**
         * Enable sync
         */
        enableSync() {
            if (!this.apiUrl) return;
            this.configureSync(this.apiUrl);
        },
        
        /**
         * Disable sync
         */
        disableSync() {
            this.syncEnabled = false;
            if (typeof SyncModule !== 'undefined') {
                SyncModule.stopAutoSync();
            }
            this.showToast('Sync disabled', 'success');
        }
    };
}
</script>

<!-- Phase 7: 키보드 단축키 초기화 (Alpine 로드 후 실행) -->
<script>
document.addEventListener('alpine:init', () => {
    // Alpine이 초기화된 후 키보드 단축키 등록
    setTimeout(() => {
        const el = document.querySelector('[x-data]');
        if (el && el._x_dataStack && el._x_dataStack[0]) {
            el._x_dataStack[0].registerKeyboardShortcuts();
            console.log('[Keyboard Shortcuts] Registered successfully');
        }
    }, 100);
});
</script>

<!-- Phase 7: 모바일 하단 네비게이션 바 -->
<nav class="mobile-nav">
    <div class="mobile-nav-item active" @click="mobileNavTab = 'grid'; issuePanelOpen = false; notificationPanelOpen = false;">
        <span class="nav-icon">📊</span>
        <span>그리드</span>
    </div>
    <div class="mobile-nav-item" @click="mobileNavTab = 'issues'; toggleIssuePanel();" style="position: relative;">
        <span class="nav-icon">🚨</span>
        <span>이슈</span>
        <template x-if="openIssues.length > 0">
            <span class="nav-badge" x-text="openIssues.length > 9 ? '9+' : openIssues.length"></span>
        </template>
    </div>
    <div class="mobile-nav-item" @click="mobileNavTab = 'notifications'; toggleNotificationPanel();" style="position: relative;">
        <span class="nav-icon">🔔</span>
        <span>알림</span>
        <template x-if="unreadNotificationCount > 0">
            <span class="nav-badge" x-text="unreadNotificationCount > 9 ? '9+' : unreadNotificationCount"></span>
        </template>
    </div>
    <div class="mobile-nav-item" @click="mobileNavTab = 'settings'; showAdminPanel = true;">
        <span class="nav-icon">⚙️</span>
        <span>설정</span>
    </div>
</nav>

<!-- Phase 7: 빠른 상태 변경 액션 바 -->
<div class="quick-action-bar" :class="selectedCells.length > 0 ? 'visible' : ''">
    <div class="quick-action-info">
        <span class="quick-action-count" x-text="selectedCells.length"></span>
        <span class="quick-action-label">개 기둥 선택됨</span>
    </div>
    
    <div class="quick-action-buttons">
        <!-- 상태 변경 드롭다운 -->
        <div class="quick-action-dropdown">
            <button class="quick-action-btn">
                🔄 상태 변경
                <span class="keyboard-hint">S</span>
            </button>
            <div class="quick-action-menu">
                <template x-for="(status, code) in statusCodes" :key="code">
                    <div class="quick-action-menu-item" @click="quickChangeStatus(code)">
                        <span :style="'color:' + status.color">●</span>
                        <span x-text="status.label"></span>
                    </div>
                </template>
            </div>
        </div>

        <!-- 공정 상태 변경 드롭다운 -->
        <div class="quick-action-dropdown">
            <button class="quick-action-btn">
                🔧 공정 변경
                <span class="keyboard-hint">P</span>
            </button>
            <div class="quick-action-menu" style="min-width: 220px;">
                <div class="stage-select-grid">
                    <template x-for="stage in stageConfigs" :key="stage.code">
                        <div class="stage-select-item" @click="quickChangeStage(stage.code, 'active')">
                            <div class="stage-dot" :style="'background:' + stage.color"></div>
                            <span class="stage-name" x-text="stage.label"></span>
                        </div>
                    </template>
                </div>
                <div class="quick-action-menu-divider"></div>
                <div class="quick-action-menu-item" @click="quickMarkStageComplete()">
                    ✅ 현재 공정 완료
                </div>
            </div>
        </div>

        <!-- 이슈 등록 -->
        <button class="quick-action-btn" @click="openNewIssueModalWithSelected()">
            🚨 이슈 등록
            <span class="keyboard-hint">I</span>
        </button>

        <!-- Lock 토글 -->
        <div class="quick-action-dropdown">
            <button class="quick-action-btn" :class="{ 'locked': getSelectedLockCount() > 0 }" aria-label="선택한 기둥 잠금/해제">
                <span x-text="getSelectedLockCount() > 0 ? '🔒' : '🔓'"></span>
                <span x-text="getSelectedLockCount() + '/' + selectedCells.length"></span>
                <span class="keyboard-hint">L</span>
            </button>
            <div class="quick-action-menu" style="min-width: 150px;">
                <div class="quick-action-menu-item" @click="bulkLockSelected(true)">
                    🔒 모두 잠금
                </div>
                <div class="quick-action-menu-item" @click="bulkLockSelected(false)">
                    🔓 모두 해제
                </div>
            </div>
        </div>

        <!-- 선택 해제 -->
        <button class="quick-action-btn danger" @click="clearSelection()">
            ✕
            <span class="keyboard-hint">Esc</span>
        </button>
    </div>
</div>

<!-- Phase 7: 히스토리 토글 버튼 -->
<button class="history-toggle-btn" @click="historyPanelOpen = !historyPanelOpen" title="변경 히스토리">
    📜
</button>

<!-- Phase 7: 데이터 히스토리 패널 -->
<div class="history-panel" :class="historyPanelOpen ? 'open' : ''">
    <div class="history-panel-header">
        <h3>📜 변경 히스토리</h3>
        <button class="notification-close" @click="historyPanelOpen = false" aria-label="히스토리 패널 닫기">✕</button>
    </div>
    
    <!-- 필터 버튼 -->
    <div class="history-filters">
        <button class="history-filter-btn" 
                :class="historyFilter === 'all' ? 'active' : ''"
                @click="historyFilter = 'all'">전체</button>
        <button class="history-filter-btn" 
                :class="historyFilter === 'status' ? 'active' : ''"
                @click="historyFilter = 'status'">상태변경</button>
        <button class="history-filter-btn" 
                :class="historyFilter === 'stage' ? 'active' : ''"
                @click="historyFilter = 'stage'">공정</button>
        <button class="history-filter-btn" 
                :class="historyFilter === 'issue' ? 'active' : ''"
                @click="historyFilter = 'issue'">이슈</button>
    </div>

    <!-- 히스토리 목록 -->
    <div class="history-list">
        <template x-if="filteredHistory.length === 0">
            <div class="history-empty">
                <div class="history-empty-icon">📭</div>
                <div>변경 내역이 없습니다</div>
            </div>
        </template>

        <template x-for="group in groupedHistory" :key="group.date">
            <div class="history-date-group">
                <div class="history-date-label" x-text="group.dateLabel"></div>
                <template x-for="item in group.items" :key="item.id">
                    <div class="history-item" @click="onHistoryItemClick(item)">
                        <div class="history-item-icon" :class="item.type">
                            <span x-text="getHistoryIcon(item.type)"></span>
                        </div>
                        <div class="history-item-content">
                            <div class="history-item-title" x-text="item.description"></div>
                            <div class="history-item-meta">
                                <span class="history-item-column" x-text="item.targetId"></span>
                                <span x-text="formatHistoryTime(item.timestamp)"></span>
                                <template x-if="item.user">
                                    <span x-text="'by ' + item.user"></span>
                                </template>
                            </div>
                        </div>
                        <!-- Phase 12-2: View Source Button -->
                        <template x-if="item.sourceId">
                            <button class="history-source-btn"
                                    @click.stop="openContextSource(item.sourceId)"
                                    title="View original context source">
                                📄
                            </button>
                        </template>
                    </div>
                </template>
            </div>
        </template>
    </div>
</div>

<!-- Phase 7: 키보드 단축키 도움말 모달 -->
<div x-show="shortcutsModalOpen"
     x-transition:enter="transition ease-out duration-200"
     x-transition:enter-start="opacity-0"
     x-transition:enter-end="opacity-100"
     x-transition:leave="transition ease-in duration-150"
     x-transition:leave-start="opacity-100"
     x-transition:leave-end="opacity-0"
     class="shortcuts-modal-overlay"
     @click.self="shortcutsModalOpen = false"
     style="display: none;">
    <div class="shortcuts-modal">
        <div class="shortcuts-modal-header">
            <h2>⌨️ 키보드 단축키</h2>
            <button class="modal-close-btn" @click="shortcutsModalOpen = false" aria-label="키보드 단축키 도움말 닫기">✕</button>
        </div>
        <div class="shortcuts-modal-body">
            <!-- 일반 단축키 -->
            <div class="shortcuts-section">
                <h3>일반</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>?</kbd> 또는 <kbd>/</kbd></span>
                        <span class="shortcut-desc">단축키 도움말</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>Esc</kbd></span>
                        <span class="shortcut-desc">패널/모달 닫기</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>R</kbd></span>
                        <span class="shortcut-desc">데이터 동기화</span>
                    </div>
                </div>
            </div>

            <!-- 패널 단축키 -->
            <div class="shortcuts-section">
                <h3>패널 토글</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>G</kbd></span>
                        <span class="shortcut-desc">요약 패널</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>E</kbd></span>
                        <span class="shortcut-desc">이슈 패널</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>N</kbd></span>
                        <span class="shortcut-desc">알림 패널</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>H</kbd></span>
                        <span class="shortcut-desc">히스토리 패널</span>
                    </div>
                </div>
            </div>

            <!-- 선택 단축키 -->
            <div class="shortcuts-section">
                <h3>선택</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>A</kbd></span>
                        <span class="shortcut-desc">전체 선택</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>D</kbd></span>
                        <span class="shortcut-desc">선택 해제</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>Shift</kbd> + 클릭</span>
                        <span class="shortcut-desc">범위 선택</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys">드래그</span>
                        <span class="shortcut-desc">다중 선택</span>
                    </div>
                </div>
            </div>

            <!-- 작업 단축키 -->
            <div class="shortcuts-section">
                <h3>작업 (기둥 선택 시)</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>S</kbd></span>
                        <span class="shortcut-desc">상태 변경</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>P</kbd></span>
                        <span class="shortcut-desc">공정 변경</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>I</kbd></span>
                        <span class="shortcut-desc">이슈 등록</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>L</kbd></span>
                        <span class="shortcut-desc">🔒 Lock 토글 (AI 덮어쓰기 방지)</span>
                    </div>
                </div>
            </div>

            <!-- 필터 단축키 -->
            <div class="shortcuts-section">
                <h3>공정 필터</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>1</kbd></span>
                        <span class="shortcut-desc">HMB제작</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>2</kbd></span>
                        <span class="shortcut-desc">면조립</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>3</kbd></span>
                        <span class="shortcut-desc">대조립</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>4</kbd></span>
                        <span class="shortcut-desc">HMB+PSRC</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>5</kbd></span>
                        <span class="shortcut-desc">FORM</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>6</kbd></span>
                        <span class="shortcut-desc">앰베드</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>0</kbd></span>
                        <span class="shortcut-desc">필터 초기화</span>
                    </div>
                </div>
            </div>

            <!-- Phase 7: 층/절주 단축키 -->
            <div class="shortcuts-section">
                <h3>층/절주 탐색</h3>
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>F</kbd></span>
                        <span class="shortcut-desc">층 선택기 열기</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>PgUp</kbd></span>
                        <span class="shortcut-desc">상위 층 이동</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>PgDn</kbd></span>
                        <span class="shortcut-desc">하위 층 이동</span>
                    </div>
                    <div class="shortcut-item">
                        <span class="shortcut-keys"><kbd>J</kbd></span>
                        <span class="shortcut-desc">절주 필터 순환</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="shortcuts-modal-footer">
            <span class="shortcuts-hint">💡 대부분의 단축키는 입력 필드에서 비활성화됩니다</span>
        </div>
    </div>
</div>

<!-- Bulk Edit Panel (appears when cells selected) -->
<div class="bulk-edit-panel" x-show="selectedCells.length > 0" x-cloak>
    <span class="bulk-count" x-text="selectedCells.length + '개 선택됨'"></span>
    <div class="bulk-actions">
        <button class="bulk-status-btn installed" @click="bulkChangeStatus('installed')">✅ 설치완료</button>
        <button class="bulk-status-btn active" @click="bulkChangeStatus('active')">🔵 진행중</button>
        <button class="bulk-status-btn pending" @click="bulkChangeStatus('pending')">⚪ 대기</button>
        <button class="bulk-status-btn hold" @click="bulkChangeStatus('hold_tc')">🔴 Hold</button>
    </div>
    <button class="btn" @click="clearSelection()" style="font-size:11px;">✕ 취소</button>
</div>

<!-- Mobile Bottom Navigation -->
<nav class="bottom-nav" x-show="isMobile" role="navigation" aria-label="모바일 네비게이션">
    <button class="bottom-nav-item"
            :class="{ 'active': mobileView === 'grid' }"
            @click="mobileView = 'grid'; sidebarOpen = false"
            aria-label="그리드 보기">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
        </svg>
        <span>그리드</span>
    </button>

    <button class="bottom-nav-item"
            :class="{ 'active': sidebarOpen }"
            @click="sidebarOpen = !sidebarOpen; mobileView = 'filter'"
            aria-label="필터">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>
        </svg>
        <span>필터</span>
    </button>

    <button class="bottom-nav-item"
            @click="newIssueModalOpen = true"
            aria-label="이슈 추가">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
        </svg>
        <span>추가</span>
    </button>

    <button class="bottom-nav-item"
            :class="{ 'active': notificationPanelOpen }"
            @click="notificationPanelOpen = !notificationPanelOpen"
            aria-label="알림">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
        </svg>
        <span>알림</span>
    </button>

    <button class="bottom-nav-item"
            :class="{ 'active': showAdminPanel }"
            @click="showAdminPanel = !showAdminPanel"
            aria-label="설정">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
        </svg>
        <span>설정</span>
    </button>
</nav>

<!-- PWA: Service Worker Registration -->
<script>
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then((registration) => {
                console.log('[PWA] Service Worker registered:', registration.scope);

                // Check for updates
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // New version available
                            if (window.showToast) {
                                window.showToast('New version available! Refresh to update.', 'info');
                            }
                        }
                    });
                });
            })
            .catch((error) => {
                console.error('[PWA] Service Worker registration failed:', error);
            });
    });
}
</script>

</body>
</html>
